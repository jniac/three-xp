(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3763],{33022:function(e,n,t){"use strict";t.d(n,{Main:function(){return O}});var a=t(78485),r=t(98579),o=t(91659),i=t(85679),l=t(47174),c=t(94588),s=t(1060),u=t(77405),f=t(28142),p=t(96966),m=t(81861);let d=new(t(26772)).x;function x(e){return new Promise(n=>{d.load(e,e=>{n(e)})})}let h=new m.I;var v=t(70155);let g="\n\nstruct FloatRamp {\n  float a;\n  float b;\n  float t;\n};\n\nstruct Vec2Ramp {\n  vec2 a;\n  vec2 b;\n  float t;\n};\n\nstruct Vec3Ramp {\n  vec3 a;\n  vec3 b;\n  float t;\n};\n\nstruct Vec4Ramp {\n  vec4 a;\n  vec4 b;\n  float t;\n};\n\n".concat((0,v.C)("vecX",e=>{let n=e[0].toUpperCase()+e.slice(1)+"Ramp";return"\n\n".concat(n," ramp(float t, T a, T b) {\n  return ").concat(n,"(a, b, t);\n}\n\n").concat(n," ramp(float t, T a, T b, T c) {\n  if (t < .5) {\n    return ").concat(n,"(a, b, t * 2.0);\n  } else {\n    return ").concat(n,"(b, c, (t - 0.5) * 2.0);\n  }\n}\n\n").concat(n," ramp(float t, T a, T b, T c, T d) {\n  if (t < .33) {\n    return ").concat(n,"(a, b, t * 3.0);\n  } else if (t < .66) {\n    return ").concat(n,"(b, c, (t - 0.33) * 3.0);\n  } else {\n    return ").concat(n,"(c, d, (t - 0.66) * 3.0);\n  }\n}\n\n").slice(1,-1)})),w="\n#ifndef GLSL_RAMP\n#define GLSL_RAMP\n".concat(s.i,"\n").concat(g,"\n#endif\n"),_={white:new i.Color("#ffffff"),grey10:new i.Color("#f0f0f0"),grey20:new i.Color("#e0e0e0"),notSoWhite:new i.Color("#f8f8e8"),yellow:new i.Color("#fff700"),black:new i.Color("#110111"),red:new i.Color("#dd1a41"),brightSkin:new i.Color("#ebd8c6"),petrol:new i.Color("#005e6b"),brightGreen:new i.Color("#22c891"),darkGreen:new i.Color("#002f1c"),sand:new i.Color("#e6db9f")};class y extends i.Mesh{static createMaterial(e){let{color:n,shaded:t,emissiveIntensity:a,side:r}={...y.defaultProps,...e};return t?new i.MeshPhysicalMaterial({color:n,emissiveIntensity:a,emissive:a>0?n:void 0,side:r}):new i.MeshBasicMaterial({color:n})}}y.defaultProps={color:_.black,radius:1.3,align:.5,thickness:.3,innerRadiusRatio:null,shaded:!0,emissiveIntensity:.333};class b extends y{constructor(e){let{radius:n,thickness:t,align:a,innerRadiusRatio:r,color:o,shaded:l,...s}={...y.defaultProps,...e},u=n-t*a,f=n+t*(1-a);r&&(u=n*r,f=n),super(new i.RingGeometry(u,f,128),y.createMaterial({...e,side:i.DoubleSide})),(0,c.N)(this,s)}}class P extends i.Mesh{constructor(e){let{radius:n,thickness:t,align:a,innerRadiusRatio:r,color:o,shaded:l,emissiveIntensity:s,...u}={...y.defaultProps,...e},f=n-t*a,p=n+t*(1-a);r&&(f=n*r,p=n),super(new i.TorusGeometry((f+p)/2,(p-f)/2,128,512),y.createMaterial({...e,side:i.FrontSide})),(0,c.N)(this,u)}}class C extends b{constructor(e){super(e),this.material.onBeforeCompile=e=>l.b.with(e).defines({USE_UV:""}).fragment.top(w).fragment.after("map_fragment","\n      vec2 p = vUv - 0.5;\n      float alpha = atan(p.y, p.x) / 6.2831853;\n      alpha = 1.0 - mod(alpha + 0.0, 1.0);\n      Vec3Ramp r = ramp(alpha,\n        ".concat((0,l.R)(_.black),",\n        ").concat((0,l.R)(_.white),",\n        ").concat((0,l.R)(_.yellow),");\n      diffuseColor.rgb = mix(r.a, r.b, easeInOut4(r.t));\n    "))}}var M=t(71052);class k extends i.Group{constructor({globalIntensity:e=1,debug:n=!1}={}){super(),this.name="lights";let t=new i.HemisphereLight("#dbebf0","#645d61",e);this.add(t);let a=new i.RectAreaLight("#e8e6d3",1.3*e);a.position.set(10,10,10),a.width=40,a.height=40,a.lookAt(0,0,0),this.add(a),n&&this.add(new M.Z(a));let r=new i.AmbientLight("#f2f0dd",.8*e);this.add(r)}}function S(e){let{precision:n=3}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=0,a=0,r=0;function o(){return"vec3(".concat(t.toFixed(n),", ").concat(a.toFixed(n),", ").concat(r.toFixed(n),")")}switch(typeof e){case"number":return t=(e>>16&255)/255,a=(e>>8&255)/255,r=(255&e)/255,o();case"string":if(e.startsWith("#")){if(4===e.length)return t=parseInt(e[1]+e[1],16)/255,a=parseInt(e[2]+e[2],16)/255,r=parseInt(e[3]+e[3],16)/255,o();return S(parseInt(e.slice(1),16),{precision:n})}throw Error("Invalid string: ".concat(e));case"object":if(Array.isArray(e))return[t,a,r]=e,o();if("r"in e)return t=e.r,a=e.g,r=e.b,o();if("x"in e)return t=e.x,a=e.y,r=e.z,o();throw Error("Invalid object: ".concat(e))}return"vec3(1.0, 0.0, 1.0)"}u.UM;var z=t(55244);let I="\n  ".concat(i.ShaderChunk.cube_uv_reflection_fragment,"\n  ").concat(z.v,"\n\n  varying vec3 vPosition;\n  varying vec3 vWorldNormal;\n\n  struct Plane {\n    vec3 origin;\n    vec3 normal;\n  };\n\n  float signedDistanceToPlane(Plane plane, vec3 p) {\n    return dot(plane.normal, p - plane.origin);\n  }\n\n  vec3 checker3(vec3 position, float scale, float edgeWidth, vec3 color1, vec3 color2) {\n    // Scale the position to control the size of the checker cubes\n    vec3 scaledPos = position / scale;\n\n    // Get the integer part (checker grid location)\n    vec3 checkerPos = floor(scaledPos);\n\n    // Get the fractional part (inside each cube)\n    vec3 fractPos = fract(scaledPos);\n\n    // Calculate the checkerboard pattern (even/odd cubes)\n    float checkerSum = mod(checkerPos.x + checkerPos.y + checkerPos.z, 2.0);\n\n    // Smooth transition using smoothstep on the fractional position\n    float edgeX = smoothstep(0.0, edgeWidth, fractPos.x);\n    float edgeY = smoothstep(0.0, edgeWidth, fractPos.y);\n    float edgeZ = smoothstep(0.0, edgeWidth, fractPos.z);\n\n    // Combine the edges to create a smooth transition\n    float blend = edgeX * edgeY * edgeZ;\n    blend = smoothstep(0.0, edgeWidth, min(min(fractPos.x, fractPos.y), fractPos.z));\n    \n    // Interpolate between black and white with the smoothstep value\n    vec3 baseColor = checkerSum == 0.0 ? color1 : color2;\n    vec3 oppositeColor = checkerSum == 0.0 ? color2 : color1;\n\n    // Use the smooth transition to blend between colors\n    return mix(baseColor, oppositeColor, blend);\n  }\n\n  float sphereGrid(vec3 position, float scale, float edgeWidth) {\n    // Scale the position to control the size of the checker cubes\n    vec3 scaledPos = position / scale;\n\n    // Get the integer part (checker grid location)\n    vec3 checkerPos = floor(scaledPos);\n\n    // Get the fractional part (inside each cube)\n    vec3 fractPos = fract(scaledPos);\n\n    vec3 p = fractPos - 0.5;\n    float alpha = 1.0 - length(p) * 2.0;\n\n    return smoothstep(0.0, edgeWidth, alpha - 0.1);    \n  }\n\n  void main() {\n    vec3 p = vWorldNormal * 0.33;\n    float n1 = snoise(p * 6.0 * 0.2 + 0.2);\n    float n2 = snoise(p * 20.0 + 10.1);\n    float n3 = snoise(p * 40.0 + 10.1);\n    float n4 = snoise(p * 1400.0 + 13.1);\n    float n = n1 * 0.5;\n    n += pow(fract((n1 + n2 * 0.015 + n3 * 0.01 + n4 * 0.005) * 85.0), 4.0) * 0.5;\n    n += pow(fract((n1 + n2 * 0.015) * 85.0), 4.0) * 0.25;\n    n += n4 * 0.2;\n    n += 0.8;\n    n = pow(n, 0.3);\n    float alpha = n;\n\n    gl_FragColor.rgb = mix(").concat(S(_.white),", ").concat(S(_.brightSkin),", alpha);\n    gl_FragColor.a = 1.0;\n\n    // float x = sphereGrid(vPosition, 1.0, 0.01);\n    // gl_FragColor.rgb = mix(").concat(S(_.black),", ").concat(S(_.brightSkin),", x);\n    // gl_FragColor.rgb = checker3(vPosition, 1.0, 0.1, ").concat(S(_.black),", ").concat(S(_.brightSkin),");\n  }\n");class V extends i.Mesh{constructor({debug:e=!1}={}){super(new i.IcosahedronGeometry(5.5,12),new i.ShaderMaterial({depthWrite:!1,side:i.BackSide,vertexShader:"\n  varying vec3 vWorldNormal;\n  varying vec3 vPosition;\n\n  vec3 rotate(mat4 m, vec3 v) {\n    return vec3(\n      dot(v, vec3(m[0][0], m[1][0], m[2][0])),  // X component\n      dot(v, vec3(m[0][1], m[1][1], m[2][1])),  // Y component\n      dot(v, vec3(m[0][2], m[1][2], m[2][2]))   // Z component\n    );\n  }\n\n  void main() {\n    vPosition = position;\n    vWorldNormal = normalize(rotate(modelMatrix, position));\n\n    // gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    // Ignore the position, we only need the normal:\n    gl_Position = projectionMatrix * vec4(rotate(modelViewMatrix, position), 1.0);\n  }\n",fragmentShader:I,uniforms:{}})),e&&(this.material=new i.MeshBasicMaterial({depthWrite:!1,color:"white",wireframe:!0})),this.onBeforeRender=(e,n,t,a,r,o)=>{this.position.copy(t.position)},this.renderOrder=-1,this.frustumCulled=!1,this.name="a-sky"}}var T=t(98828);class A extends i.Mesh{constructor(e){let{radius:n,...t}={...A.defaultProps,...e},a=new i.IcosahedronGeometry(n,18),r=new i.MeshPhysicalMaterial({});r.onBeforeCompile=e=>l.b.with(e).defines({USE_UV:""}).fragment.top(w).fragment.after("map_fragment","\n        vec2 p = vUv - 0.5;\n        float alpha = easeInOut(vUv.y, 1.6, 0.5);\n        Vec3Ramp r = ramp(alpha, ".concat((0,l.R)(_.black),", ").concat((0,l.R)(_.white),", ").concat((0,l.R)(_.yellow),");\n        diffuseColor.rgb = mix(r.a, r.b, easeInOut3(r.t));\n      ")),super(a,r),(0,c.N)(this,t)}}A.defaultProps={radius:1};class G{set(e){this.props={...this.props,...e},this.props.center=this.props.center.clone(),this.props.normal=this.props.normal.clone().normalize(),this.props.binormal=this.props.binormal.clone().normalize()}update(e){let{radius:n,turnVelocity:t,turn:a,center:r,normal:o,binormal:i}=this.props,l=a+t*e;this.props.turn=l,this.target.position.copy(r).addScaledVector(o,n*Math.cos(l*Math.PI*2)).addScaledVector(i,n*Math.sin(l*Math.PI*2))}constructor(e,n){this.target=e,this.set({...G.defaultProps,...n})}}G.defaultProps={center:new i.Vector3,normal:new i.Vector3(1,0,0),binormal:new i.Vector3(0,1,0),radius:1,turnVelocity:1,turn:0};class j extends i.Mesh{get satellite(){var e;return null!==(e=this._satellite)&&void 0!==e?e:this._satellite=new G(this)}constructor(e){let{radius:n,singleColor:t,emmissiveIntensity:a,lerpIn:r,lerpOut:o,...u}={...j.defaultProps,...e},{colorTop:f=null!=t?t:j.defaultProps.colorTop,colorBottom:p=null!=t?t:j.defaultProps.colorBottom}={...e},m=new i.IcosahedronGeometry(n,12),d=new i.MeshPhysicalMaterial({color:f,emissive:p});d.onBeforeCompile=e=>{l.b.with(e).defines({USE_UV:""}).uniforms({uLerpIn:{value:r},uLerpOut:{value:o},uColorTop:{value:new i.Color(f)},uColorBottom:{value:new i.Color(p)}}).fragment.top(s.i,T.U).fragment.mainBeforeAll("\n          float alpha = inverseLerp(uLerpIn, uLerpOut, vUv.y);\n          vec3 sphereColor = mix(uColorBottom, uColorTop, easeInOut3(alpha));\n        ").fragment.after("map_fragment","\n          diffuseColor.rgb = sphereColor;\n        ").fragment.after("emissivemap_fragment","\n          totalEmissiveRadiance.rgb = sphereColor * ".concat(a.toFixed(2),";\n        "))},super(m,d),this._satellite=null,(0,c.N)(this,u)}}j.defaultProps={radius:.225,singleColor:null,colorTop:_.white,colorBottom:_.yellow,emmissiveIntensity:.25,lerpIn:-.2,lerpOut:1.2};class R extends i.Mesh{constructor(e){let n=new i.IcosahedronGeometry(.4,12),t=new i.MeshPhysicalMaterial({});t.onBeforeCompile=e=>l.b.with(e).varying({vWorldPosition:"vec3",vNormalWorld:"vec3",vViewDir:"vec3"}).vertex.mainAfterAll("\n        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n        vNormalWorld = normalize(mat3(modelMatrix) * normal);\n        vViewDir = normalize(cameraPosition - vWorldPosition);\n      ").fragment.top(s.i,"\n\nfloat contrast(float mValue, float mScale, float mMidPoint) {\n	// Why clamp? If necessary, it has to be done outside of this function.\n	// return clamp((mValue - mMidPoint) * mScale + mMidPoint, 0.0, 1.0);\n	return (mValue - mMidPoint) * mScale + mMidPoint;\n}\n\nfloat contrast(float mValue, float mScale) {\n	return contrast(mValue, mScale, 0.5);\n}\n\nvec3 contrast(vec3 mValue, float mScale, float mMidPoint) {\n	return vec3(contrast(mValue.r, mScale, mMidPoint), contrast(mValue.g, mScale, mMidPoint), contrast(mValue.b, mScale, mMidPoint));\n}\n\nvec3 contrast(vec3 mValue, float mScale) {\n	return contrast(mValue, mScale, 0.5);\n}\n\nfloat greyscaleFloat(vec3 color) {\n	return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 greyscale(vec3 color) {\n    return vec3(greyscaleFloat(color));\n}\n\nvec3 greyscale(vec3 color, float alpha) {\n    return mix(color, greyscale(color), alpha);\n}\n\n").fragment.after("map_fragment","\n        float fresnel = dot(vNormalWorld, vViewDir);\n        vec3 inner = ".concat((0,l.R)(_.white),";\n        vec3 outer = ").concat((0,l.R)(_.black),";\n        float alpha = easeInOut(1.0 - pow(fresnel, 1.5), 2.0, 0.0);\n        diffuseColor.rgb = mix(inner, outer, alpha);\n      ")).fragment.mainAfterAll("\n        // Final tuning\n        gl_FragColor.rgb = mix(contrast(greyscale(gl_FragColor.rgb), 1.5), diffuseColor.rgb, alpha);\n      "),super(n,t),(0,c.N)(this,e)}}class L extends i.Mesh{constructor(e){let{color:n,thickness:t,length:a,shaded:r,...o}={...L.defaultProps,...e};super(new i.CylinderGeometry(t/2,t/2,a,12,1).rotateZ(.5*Math.PI),r?new i.MeshPhysicalMaterial({color:n}):new i.MeshBasicMaterial({color:n})),(0,c.N)(this,o)}}function F(e,n){return n.add(e),e}function*N(e,n){let t=yield*function*(e){let{ticker:n,scene:t}=e;n.set({activeDuration:p.v.development?3:180}),x("https://threejs.org/examples/textures/equirectangular/royal_esplanade_1k.hdr").then(n=>{new i.PMREMGenerator(e.renderer).fromEquirectangular(n).texture});let a=new i.Group;return t.add(a),yield()=>{a.removeFromParent()},a}(e);if(1===n.renderCount){let{camera:n}=e;n.fov=e.aspect>1?25:2*Math.atan(Math.tan(25*Math.PI/180/2)/e.aspect)*180/Math.PI,n.far=1e3,n.updateProjectionMatrix(),n.position.set(0,0,10)}t.add(new V),t.add(new k);let a=F(new A,t);t.add(new C({z:-1,radius:1.4,innerRadiusRatio:.805})),t.add(new P({z:-1,radius:.75,thickness:.01,color:_.yellow,emissiveIntensity:1})),t.add(new P({z:-1,radius:.8,thickness:.01,color:_.notSoWhite})),f.T.seed(6789402);let r=f.T.createPicker([[1,4],[2,2],[4,1]]);for(let{i:n}of function*(e){let n=0,t={get i(){return n},get t(){return n/8},get count(){return 8}};for(;n<8;n++)yield t}(8)){let a=f.T.pick(_),o=f.T.pick(_),l=new j({z:-1,radius:.1*r(),colorTop:a,colorBottom:o});l.rotation.set(f.T.between(2*Math.PI),f.T.between(2*Math.PI),f.T.between(2*Math.PI)),t.add(l),l.satellite.set({radius:0===n?.875:f.T.between(.25,.75)*(0,u.t7)(1,1.5,n),center:new i.Vector3(0,0,-1-.4*n),turnVelocity:f.T.between(.05,.25)}),yield e.ticker.onTick(e=>{l.satellite.update(e.deltaTime)})}let o=new i.Group;o.rotation.z=-.25*Math.PI,t.add(o),o.add(new j({x:-1.5,z:.5,singleColor:_.yellow})),o.add(new P({x:-1.81,radius:.1,thickness:.01,color:_.notSoWhite}));let l=F(new P({x:-2.315,radius:.2,thickness:.01,color:_.notSoWhite}),o);F(new L({x:-.2,thickness:.01,length:.4,shaded:!0,color:_.notSoWhite}),l),o.add(new j({x:1.7,z:.5,lerpIn:0,lerpOut:1})),o.add(new j({x:1.4,radius:.1,singleColor:_.black}));let s=F(new R({x:2.3}),o);F(new P({radius:.43,thickness:.015,color:_.black}),s),o.add(new L({x:1.5,thickness:.015,color:_.black}));let m=new i.Group;m.rotation.z=.25*Math.PI,t.add(m),m.add(new L({x:-1.6,thickness:.01,length:.35,shaded:!0,color:_.notSoWhite})),m.add(new L({x:1.6,thickness:.01,length:.35,shaded:!0,color:_.notSoWhite}));let d=new i.Group;d.rotation.y=.5*Math.PI,t.add(d),d.add(new L({x:-1.2,thickness:.01,length:.35,shaded:!0,color:_.notSoWhite})),d.add(new L({x:1.2,thickness:.01,length:.35,shaded:!0,color:_.notSoWhite})),(function(e){let n=e.split(".").pop();switch(n){case"hdr":return x(e);case"exr":return new Promise(n=>{h.load(e,e=>{n(e)})});default:return Promise.reject("Unsupported texture format: ".concat(n))}})("https://threejs.org/examples/textures/piz_compressed.exr").then(e=>{e.mapping=i.EquirectangularReflectionMapping,s.material.envMap=e,s.material.envMapIntensity=.25,s.material.envMapRotation.set(-.1*Math.PI,Math.PI,0),s.material.roughness=.3,s.material.metalness=.5,s.material.needsUpdate=!0,a.material.envMap=e,a.material.roughness=.2,a.material.envMapIntensity=.5,a.material.envMapRotation.set(-.1*Math.PI,Math.PI,0),a.material.needsUpdate=!0});let v=F(new i.Group,t);v.rotation.z=.25*Math.PI;class g extends i.Group{constructor(e){super();{let e=new i.CylinderGeometry(15,15,5,6,1,!0).rotateY(Math.PI/6),n=new i.MeshPhysicalMaterial({color:new i.Color("white").lerp(_.black,.995),side:i.BackSide,flatShading:!0});F(new i.Mesh(e,n),this)}{let e=new i.CylinderGeometry(15,15,5,6,60,!0).rotateY(Math.PI/6),n=new i.MeshPhysicalMaterial({color:_.black,wireframe:!0,flatShading:!0,side:i.BackSide});F(new i.Mesh(e,n),this)}(0,c.N)(this,e)}}F(new g({y:7.8}),v),F(new g({y:-7.8}),v)}function O(){return(0,a.jsx)("div",{className:"absolute-through",children:(0,a.jsx)(r.V,{className:"bg-[#ddd]",children:(0,a.jsx)(o.hR,{children:(0,a.jsx)(o.kB,{fn:N})})})})}L.defaultProps={color:_.black,thickness:.01,shaded:!1,length:1}},98579:function(e,n,t){"use strict";t.d(n,{V:function(){return f}});var a=t(78485),r=t(27275),o=t(37457),i=t(12144),l=t(48583),c=t(87387),s=t.n(c);let u=[s().frame,s().full];function f(e){let[n,t]=(0,r.useState)(0),{ref:c}=(0,l.Nv)(function*(e){yield(0,i.f)(e,{onSize:n=>{let{x:t,y:a}=n.size;e.classList.toggle(s().landscape,t>a)}});let n=!1;yield(0,o.p)(document.documentElement,[[{key:"f",noModifiers:!0},a=>{a.event.preventDefault(),document.fullscreenElement!==e?(e.requestFullscreen(),n=!1):!1===n?(n=!0,t(1)):(document.exitFullscreen(),t(0))}]])},[]),{children:f,className:p}=e;return(0,a.jsx)("div",{ref:c,className:[s().Billboard,s().landscape,u[n],null!=p?p:""].join(" "),children:f})}},96966:function(e,n,t){"use strict";t.d(n,{v:function(){return r}});let a="/three-xp/assets/",r={development:!1,assetsPath:a,assets:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return"".concat(a).concat(e)}}},47174:function(e,n,t){"use strict";t.d(n,{b:function(){return g},R:function(){return _}});var a=t(32717),r=t(85679);let o=["common","uv_pars_vertex","displacementmap_pars_vertex","color_pars_vertex","fog_pars_vertex","normal_pars_vertex","morphtarget_pars_vertex","skinning_pars_vertex","shadowmap_pars_vertex","logdepthbuf_pars_vertex","clipping_planes_pars_vertex","uv_vertex","color_vertex","morphcolor_vertex","beginnormal_vertex","morphnormal_vertex","skinbase_vertex","skinnormal_vertex","defaultnormal_vertex","normal_vertex","begin_vertex","morphtarget_vertex","skinning_vertex","displacementmap_vertex","project_vertex","logdepthbuf_vertex","clipping_planes_vertex","worldpos_vertex","shadowmap_vertex","fog_vertex","common","packing","dithering_pars_fragment","color_pars_fragment","uv_pars_fragment","map_pars_fragment","alphamap_pars_fragment","alphatest_pars_fragment","alphahash_pars_fragment","aomap_pars_fragment","lightmap_pars_fragment","emissivemap_pars_fragment","iridescence_fragment","cube_uv_reflection_fragment","envmap_common_pars_fragment","envmap_physical_pars_fragment","fog_pars_fragment","lights_pars_begin","normal_pars_fragment","lights_physical_pars_fragment","transmission_pars_fragment","shadowmap_pars_fragment","bumpmap_pars_fragment","normalmap_pars_fragment","clearcoat_pars_fragment","iridescence_pars_fragment","roughnessmap_pars_fragment","metalnessmap_pars_fragment","logdepthbuf_pars_fragment","clipping_planes_pars_fragment","clipping_planes_fragment","logdepthbuf_fragment","map_fragment","color_fragment","alphamap_fragment","alphatest_fragment","alphahash_fragment","roughnessmap_fragment","metalnessmap_fragment","normal_fragment_begin","normal_fragment_maps","clearcoat_normal_fragment_begin","clearcoat_normal_fragment_maps","emissivemap_fragment","lights_physical_fragment","lights_fragment_begin","lights_fragment_maps","lights_fragment_end","aomap_fragment","transmission_fragment","opaque_fragment","tonemapping_fragment","colorspace_fragment","fog_fragment","premultiplied_alpha_fragment","dithering_fragment"];var i=t(79509);class l{static from(e,n){if(n instanceof i.Observable){if("number"==typeof n.value)return new l(e,n);throw Error("Observable value must be a number")}let t=typeof n;return"object"===t&&(n.constructor===Object||n instanceof r.Uniform)&&"value"in n?new l(e,n):"string"===t?new l(e,{value:new r.Color(n)}):new l(e,{value:n})}get value(){return this.target.value}computeDeclaration(){let e=this.name,n=this.target.value,t="";if(n instanceof Float32Array)return"uniform float ".concat(e,"[").concat(n.length,"];");if(Array.isArray(n)&&(t="[".concat(n.length,"]"),n=n[0]),"number"==typeof n)return"uniform float ".concat(e).concat(t,";");if(n.isVector2)return"uniform vec2 ".concat(e).concat(t,";");if(n.isVector3||n.isColor)return"uniform vec3 ".concat(e).concat(t,";");if(n.isVector4||n.isQuaternion)return"uniform vec4 ".concat(e).concat(t,";");if(n.isMatrix3)return"uniform mat3 ".concat(e).concat(t,";");if(n.isMatrix4)return"uniform mat4 ".concat(e).concat(t,";");if(n.isTexture)return n.isCubeTexture?"uniform samplerCube ".concat(e).concat(t,";"):"uniform sampler2D ".concat(e).concat(t,";");throw console.log("unhandled value:",n),Error('unhandled value: "'.concat(null==n?void 0:n.constructor.name,'"'))}constructor(e,n){this.name=e,this.target=n}}function c(){let e=(0,a._)(["","s*",""],["","\\s*",""]);return c=function(){return e},e}let s=null,u=e=>(s=e,g),f="// ShaderForge (injected code) ->",p="// <- ShaderForge",m=e=>"".concat(f,"\n").concat(e.trim(),"\n").concat(p),d=e=>{let n=e=>e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),t=RegExp(String.raw(c(),n(p),n(f)),"g");return e.replaceAll(t,"")};class x{getPattern(e){let{throwError:n=!0}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t="#include <".concat(e,">"),a=this.type;if(n&&!1===s[a].includes(t))throw Error('"'.concat(t,'" is not present in the shader template program.'));return{pattern:t,type:a}}replace(e,n){if(e instanceof RegExp){let{type:t}=this;s[t].match(e),s[t]=s[t].replace(e,m(n))}else{let{type:t,pattern:a}=this.getPattern(e),r=m(n);s[t]=s[t].replace(a,r)}return g}inject(e,n,t){let{type:a,pattern:r}=this.getPattern(n),o="after"===e?"".concat(r,"\n").concat(m(t)):"".concat(m(t),"\n").concat(r);return s[a]=s[a].replace(r,o),g}injectTokenComments(){for(let e of o){let{type:n,pattern:t}=this.getPattern(e,{throwError:!1});s[n]=s[n].replace(t,"\n        ".concat(t,"\n        // ShaderForge TOKEN: ").concat(e,"\n      "))}return g}header(e){let n=this.type;return s[n]="".concat(e,"\n").concat(s[n]),g}before(e,n){return this.inject("before",e,n)}after(e,n){return this.inject("after",e,n)}top(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];return s[this.type]=s[this.type].replace("void main() {","\n      ".concat(m(n.join("\n\n")),"\n      void main() {\n    ")),g}mainBeforeAll(e){return s[this.type]=s[this.type].replace("void main() {","void main() {\n        ".concat(m(e))),g}mainAfterAll(e){return s[this.type]=s[this.type].replace(/}\s*$/,"\n      ".concat(m(e),"\n    }")),g}uniforms(e){if("string"==typeof e)this.top(e);else{let n=[];for(let[t,a]of Object.entries(e)){let e=l.from(t,a);n.push(e.computeDeclaration())}this.top(n.join("\n")),function(e){for(let[n,t]of Object.entries(e)){let e=l.from(n,t);if(n in s.uniforms){if(e.value!==s.uniforms[n].value)throw Error("Shader redefinition! (Uniform values are not equal)")}else s.uniforms[n]=e}}(e)}return g}clean(){return s[this.type]=d(s[this.type]),g}printFinalCode(){return console.log(s[this.type].replace(/#include <(.*)>/g,(e,n)=>{let t=r.ShaderChunk[n];if(!t)throw Error('Shader chunk "'.concat(n,'" not found'));return t})),g}constructor(e){this.type=e}}let h=new x("fragmentShader"),v=new x("vertexShader"),g=Object.assign(function(e){return e&&u(e),g},{shaderName:function(e){return s.shaderName="".concat(e," (ShaderForge)"),g},defines:function(e){return s.defines?Object.assign(s.defines,e):s.defines=e,g},uniforms:function(e){return v.uniforms(e),h.uniforms(e),g},varying:function(e){let n="";if("string"==typeof e)n=e;else{let t=[];for(let[n,a]of Object.entries(e))t.push("varying ".concat(a," ").concat(n,";"));n=t.join("\n")}return v.top(n),h.top(n),g},top:function(e){return v.top(e),h.top(e),g},vertex:v,fragment:h,header:function(e){return h.header(e),v.header(e),g},clean:function(){return h.clean(),v.clean(),g},with:u,wrap:(e,n)=>(e.onBeforeCompile=e=>{s=e},e)}),w=new r.Color;function _(e){let{r:n,g:t,b:a}=w.set(e);return"vec3(".concat(n.toFixed(3),", ").concat(t.toFixed(3),", ").concat(a.toFixed(3),")")}},94588:function(e,n,t){"use strict";t.d(n,{N:function(){return i}});var a=t(85679),r=t(81796);new a.Vector3(0,0,0),new a.Euler(0,0,0,"XYZ"),new a.Vector3(1,1,1);let o={x:0,y:0,z:0,rotationX:0,rotationY:0,rotationZ:0,rotationOrder:"XYZ",rotationUnit:"rad",scaleX:1,scaleY:1,scaleZ:1,scaleScalar:1,visible:void 0,name:void 0,parent:void 0};function i(e,n){let{x:t,y:i,z:l,position:c=new a.Vector3(t,i,l),rotationX:s,rotationY:u,rotationZ:f,rotationOrder:p,rotationUnit:m,rotation:d,scaleX:x,scaleY:h,scaleZ:v,scaleScalar:g,scale:w=new a.Vector3(x,h,v).multiplyScalar(g),visible:_,name:y,parent:b}={...o,...n};return(0,r.Q7)(c,e.position),(0,r.Gg)(null!=d?d:[s,u,f,p,m],e.rotation),(0,r.Q7)(w,e.scale),void 0!==_&&(e.visible=_),void 0!==y&&(e.name=y),void 0!==b&&b.add(e),e}},26917:function(e,n,t){"use strict";t.d(n,{l:function(){return a}});let a="\n#ifndef GLSL_BASIC\n#define GLSL_BASIC\n\nfloat clamp01(float x) {\n  return x < 0.0 ? 0.0 : x > 1.0 ? 1.0 : x;\n}\n\n#endif\n"},1060:function(e,n,t){"use strict";t.d(n,{i:function(){return o}});var a=t(26917);let r=["linear"];for(let e=1;e<=10;e++)r.push("easeIn".concat(e)),r.push("easeOut".concat(e)),r.push("easeInOut".concat(e)),r.push("easeOutIn".concat(e));let o="\n#ifndef GLSL_EASING\n#define GLSL_EASING\n\n".concat(a.l,"\n\nfloat easePow1(float x) {\n  return x;\n}\n\nfloat easePow2(float x) {\n  return x * x;\n}\n\nfloat easePow3(float x) {\n  return x * x * x;\n}\n\nfloat easePow4(float x) {\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow5(float x) {\n  float x0 = x;\n  x *= x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow6(float x) {\n  x *= x * x;\n  return x *= x;\n}\n\nfloat easePow7(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow8(float x) {\n  x *= x;\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow9(float x) {\n  x *= x * x;\n  return x *= x * x;\n}\n\nfloat easePow10(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x * x;\n  return x0 * x;\n}\n\nfloat linear(float x) {\n  return clamp01(x);\n}\n\n").concat(Array.from({length:10},(e,n)=>{let t=n+1;return"\n\nfloat easeIn".concat(t," (float x) {\n  return easePow").concat(t,"(clamp01(x));\n}\nfloat easeOut").concat(t," (float x) {\n  return 1.0 - easePow").concat(t,"(clamp01(1.0 - x));\n}\nfloat easeInOut").concat(t," (float x) {\n  return x < 0.5 \n    ? 0.5 * easePow").concat(t,"(2.0 * x) \n    : 1.0 - 0.5 * easePow").concat(t,"(2.0 * (1.0 - x));\n}\nfloat easeOutIn").concat(t," (float x) {\n  return x < 0.5\n    ? 0.5 * (1.0 - easePow").concat(t,"(1.0 - x * 2.0))\n    : 1.0 - 0.5 * (1.0 - easePow").concat(t,"(2.0 * x - 1.0));\n}\n\n").trim()}).join("\n\n"),"\n\n\n// https://www.desmos.com/calculator/mqou4lf9zc?lang=fr\nfloat easeInOut(float x, float p, float i) {\n  return  x <= 0.0 ? 0.0 :\n          x >= 1.0 ? 1.0 :\n          x <= i ? 1.0 / pow(i, p - 1.0) * pow(x, p) :\n          1.0 - 1.0 / pow(1.0 - i, p - 1.0) * pow(1.0 - x, p);\n}\n\n// https://www.desmos.com/calculator/nrjlezusdv\nfloat easeInThenOut(float x, float p) {\n  return 1.0 - pow(abs(2.0 * x - 1.0), p);\n}\n\n#endif\n")},55244:function(e,n,t){"use strict";t.d(n,{v:function(){return r}});var a=t(70155);let r="\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\n\n\n\n\n// 2D:\n\nvec3 mod289_2d(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289_2d(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute_2d(vec3 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289_2d(i); // Avoid truncation effects in permutation\n  vec3 p = permute_2d( permute_2d( i.y + vec3(0.0, i1.y, 1.0 ))\n		+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// 3D: \n\nfloat snoise(vec3 v)\n{ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\n\n\n// addons:\n// Fractal noise, based on Stefan Gustavson's Simplex noise\n".concat((0,a.C)(["vec2","vec3"],"\n  float fnoise(T p, int octaves, float persistence) {\n    float total = 0.0;           // Final noise value\n    float amplitude = 1.0;       // Initial amplitude\n    float frequency = 1.0;       // Initial frequency\n    float maxValue = 0.0;        // Used for normalization\n\n    for (int i = 0; i < octaves; i++) {\n      total += snoise(p * frequency) * amplitude;\n\n      maxValue += amplitude;   // Keep track of max amplitude\n      amplitude *= persistence; // Reduce amplitude for next octave\n      frequency *= 2.0;        // Increase frequency for next octave\n    }\n\n    // Normalize the result to stay within the range [0, 1]\n    return total / maxValue;\n  }\n"),"\n")},70155:function(e,n,t){"use strict";t.d(n,{C:function(){return r}});let a={vecX:["float","vec2","vec3","vec4"]},r=(e,n)=>{let t=[],r=Array.isArray(e)?e:[e].map(e=>e in a?a[e]:e).flat();if("function"==typeof n)for(let e of r)t.push(n(e).replaceAll(/\bT\b/g,e));else for(let e of r)t.push(n.replaceAll(/\bT\b/g,e));return t.join("\n")}},98828:function(e,n,t){"use strict";t.d(n,{U:function(){return o}});var a=t(26917),r=t(70155);let o="\n  ".concat(a.l,"\n\n  float sin01(float x) {\n    return 0.5 + 0.5 * sin(x * 6.283185307179586);\n  }\n\n  vec2 scaleAround(vec2 p, vec2 c, float s) {\n    return c + (p - c) / s;\n  }\n\n  // Same as mix, but clamped.\n  ").concat((0,r.C)("vecX","\n    T lerp(in T a, in T b, in float x) {\n      return mix(a, b, clamp01(x));\n    }\n  "),"\n\n  float inverseLerpUnclamped(in float a, in float b, float x) {\n    return (x - a) / (b - a);\n  }\n\n  float inverseLerp(in float a, in float b, float x) {\n    return clamp01((x - a) / (b - a));\n  }\n\n  float threshold(in float x, in float thresholdValue) {\n    return x < thresholdValue ? 0. : 1.;\n  }\n\n  float threshold(in float x, in float thresholdValue, in float width) {\n    return width < 1e-9 \n      ? (x < thresholdValue ? 0. : 1.)\n      : clamp01((x - thresholdValue + width * .5) / width);\n  }\n\n  mat3 extractRotation(mat4 matrix) {\n    return mat3(matrix[0].xyz, matrix[1].xyz, matrix[2].xyz);\n  }\n\n  vec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    float x = c * p.x + s * p.y;\n    float y = -s * p.x + c * p.y;\n    return vec2(x, y);\n  }\n\n  vec2 rotateAround(vec2 p, float a, vec2 c) {\n    return c + rotate(p - c, a);\n  }\n\n  vec2 rotateScaleAround(vec2 p, float a, float s, vec2 c) {\n    return c + rotate((p - c) / s, a);\n  }\n  \n  float positiveModulo(float x) {\n    x = mod(x, 1.0);\n    return x < 0.0 ? x + 1.0 : x;\n  }\n\n  float positiveModulo(float x, float modulo) {\n    x = mod(x, modulo);\n    return x < 0.0 ? x + modulo : x;\n  }\n\n  // Limit a value to a maximum that the function tends to reach when x -> ∞\n  // https://www.desmos.com/calculator/0vewkbnscu\n  float limited(float x, float maxValue) {\n    return x <= 0.0 ? x : maxValue * x / (maxValue + x);\n  }\n\n  // https://www.desmos.com/calculator/0vewkbnscu\n  float limited(float x, float minValue, float maxValue) {\n    float d = maxValue - minValue;\n    float xd = x - minValue;\n    return x <= minValue ? x : minValue + d * xd / (d + xd);\n  }\n\n  float sqLength(in vec2 p) {\n    return p.x * p.x + p.y * p.y;\n  }\n\n  float sqLength(in vec3 p) {\n    return p.x * p.x + p.y * p.y + p.z * p.z;\n  }\n\n  float pcurve(float x, float a, float b) {\n    float k = pow(a + b, a + b) / (pow(a, a) * pow(b, b));\n    return k * pow(x, a) * pow(1.0 - x, b);\n  }\n\n  float hash(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n  }\n\n  ").concat((0,r.C)("vecX","\n    T min3(in T a, in T b, in T c) {\n      return min(min(a, b), c);\n    }\n  "),"\n\n  ").concat((0,r.C)("vecX","\n    T min4(in T a, in T b, in T c, in T d) {\n      return min(min(a, b), min(c, d));\n    }\n  "),"\n")},87387:function(e){e.exports={Billboard:"billboard_Billboard__1od0V",landscape:"billboard_landscape__OR09y",frame:"billboard_frame__m5PEh",full:"billboard_full__0I_hQ"}}}]);