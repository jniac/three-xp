(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7908],{1029:(n,t,e)=>{"use strict";e.d(t,{N:()=>r});let a={vecX:["float","vec2","vec3","vec4"]},r=(n,t)=>{let e=[],r=Array.isArray(n)?n:[n].map(n=>n in a?a[n]:n).flat();if("function"==typeof t)for(let n of r)e.push(t(n).replaceAll(/\bT\b/g,n));else for(let n of r)e.push(t.replaceAll(/\bT\b/g,n));return e.join("\n")}},8144:(n,t,e)=>{"use strict";e.d(t,{H:()=>o});var a=e(65927),r=e(1029);let o="\n".concat(a.S,"\n\n#ifndef GLSL_UTILS\n#define GLSL_UTILS\n\nfloat sin01(float x) {\n  return 0.5 + 0.5 * sin(x * 6.283185307179586);\n}\n\nvec2 scaleAround(vec2 p, vec2 c, float s) {\n  return c + (p - c) / s;\n}\n\n// Same as mix, but clamped.\n").concat((0,r.N)("vecX","\n  T lerp(in T a, in T b, in float x) {\n    return mix(a, b, clamp01(x));\n  }\n"),"\n\nfloat inverseLerpUnclamped(in float a, in float b, float x) {\n  return (x - a) / (b - a);\n}\n\nfloat inverseLerp(in float a, in float b, float x) {\n  return clamp01((x - a) / (b - a));\n}\n\nfloat remap(in float x, in float a, in float b, in float c, in float d) {\n  return c + (d - c) * inverseLerp(a, b, x);\n}\n\n// Remap from [-1, 1] to [0, 1]\nfloat remap1101(in float x) {\n  return clamp01(0.5 + 0.5 * x);\n}\n\n").concat((0,r.N)("vecX","\n  T oneMinus(in T x) {\n    return 1.0 - x;\n  }\n"),"\n\n// Returns x^p, but handles negative x values correctly.\nfloat spow(in float x, in float p) {\n  return x >= 0.0 ? pow(x, p) : -pow(-x, p);\n}\n\nfloat threshold(in float x, in float thresholdValue) {\n  return x < thresholdValue ? 0. : 1.;\n}\n\nfloat threshold(in float x, in float thresholdValue, in float width) {\n  return width < 1e-9 \n    ? (x < thresholdValue ? 0. : 1.)\n    : clamp01((x - thresholdValue + width * .5) / width);\n}\n\nmat3 extractRotation(mat4 matrix) {\n  return mat3(matrix[0].xyz, matrix[1].xyz, matrix[2].xyz);\n}\n\nvec2 rotate(vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  float x = c * p.x + s * p.y;\n  float y = -s * p.x + c * p.y;\n  return vec2(x, y);\n}\n\nvec2 rotateAround(vec2 p, float a, vec2 c) {\n  return c + rotate(p - c, a);\n}\n\nvec2 rotateScaleAround(vec2 p, float a, float s, vec2 c) {\n  return c + rotate((p - c) / s, a);\n}\n\nfloat positiveModulo(float x) {\n  x = mod(x, 1.0);\n  return x < 0.0 ? x + 1.0 : x;\n}\n\n// Modulo that keeps the result in the range [0, modulo]\nfloat positiveModulo(float x, float modulo) {\n  x = mod(x, modulo);\n  return x < 0.0 ? x + modulo : x;\n}\n\n// Modulo that keeps the result in the range [-m/2, m/2]\nfloat middleModulo(float x, float modulo) {\n  x = mod(x, modulo);\n  return x < -modulo / 2.0 ? x + modulo : x > modulo / 2.0 ? x - modulo : x;\n}\n\n// Limit a value to a maximum that the function tends to reach when x -> ∞\n// https://www.desmos.com/calculator/0vewkbnscu\nfloat limited(float x, float maxValue) {\n  return x <= 0.0 ? x : maxValue * x / (maxValue + x);\n}\n\n// Symmetric version of limited\n// \n// Limit a value to a maximum that the function tends to reach when x -> ∞\n// and a minimum (-maximum) that the function tends to reach when x -> -∞\n// https://www.desmos.com/calculator/0vewkbnscu\nfloat slimited(float x, float maxValue) {\n  return x <= 0.0\n    ? -limited(-x, maxValue)\n    : limited(x, maxValue);\n}\n\n// https://www.desmos.com/calculator/0vewkbnscu\nfloat limited(float x, float minValue, float maxValue) {\n  float d = maxValue - minValue;\n  float xd = x - minValue;\n  return x <= minValue ? x : minValue + d * xd / (d + xd);\n}\n\n// Symmetric version of limited\nfloat slimited(float x, float minValue, float maxValue) {\n  return x <= 0.0\n    ? -limited(-x, maxValue, minValue)\n    : limited(x, minValue, maxValue);\n}\n\nfloat sqLength(in vec2 p) {\n  return p.x * p.x + p.y * p.y;\n}\n\nfloat sqLength(in vec3 p) {\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\nfloat pcurve(float x, float a, float b) {\n  float k = pow(a + b, a + b) / (pow(a, a) * pow(b, b));\n  return k * pow(x, a) * pow(1.0 - x, b);\n}\n\nfloat hash(float p) {\n  return fract(sin(p * 12.9898) * 43758.5453);\n}\n\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat hash(vec3 p) {\n  return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n}\n\nfloat hash(vec4 p) {\n  return fract(sin(dot(p, vec4(12.9898, 78.233, 45.164, 94.673))) * 43758.5453);\n}\n\nvec2 hash2(float p) {\n  return vec2(hash(p), hash(p + 1.0));\n}\n\nvec2 hash2(vec2 p) {\n  return vec2(hash(p.x), hash(p.y));\n}\n\nvec2 hash2(vec3 p) {\n  return vec2(hash(p.xy), hash(p.yz));\n}\n\nvec2 hash2(vec4 p) {\n  return vec2(hash(p.xyz), hash(p.yzw));\n}\n\nvec3 hash3(float p) {\n  return vec3(hash2(p),  hash(p + 2.0));\n}\n\nvec3 hash3(vec2 p) {\n  return vec3(hash2(p), hash(p));\n}\n\nvec3 hash3(vec3 p) {\n  return vec3(hash(p.x), hash(p.y), hash(p.z));\n}\n\nvec3 hash3(vec4 p) {\n  return vec3(hash(p.xy), hash(p.yz), hash(p.zw));\n}\n\nfloat hash_alt(float p) {\n  return fract(sin(p * 127.1) * 311.7);\n}\n\nfloat hash_alt(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 269.5);\n}\n\nfloat hash_alt(vec3 p) {\n  return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 269.5);\n}\n\nfloat hash_alt(vec4 p) {\n  return fract(sin(dot(p, vec4(127.1, 311.7, 74.7, 113.5))) * 269.5);\n}\n\n").concat((0,r.N)("vecX","\n  T min3(in T a, in T b, in T c) {\n    return min(min(a, b), c);\n  }\n"),"\n\n").concat((0,r.N)("vecX","\n  T min4(in T a, in T b, in T c, in T d) {\n    return min(min(a, b), min(c, d));\n  }\n"),"\n\n#endif // GLSL_UTILS\n")},14277:(n,t,e)=>{"use strict";e.d(t,{D:()=>r});var a=e(67203);function r(){let[n,t]=(0,a.useState)(!1);return(0,a.useLayoutEffect)(()=>{t(!0)},[]),n}},16465:(n,t,e)=>{"use strict";e.d(t,{Y:()=>l});var a=e(49797),r=e(7147);let o={shadowColor:"#808080",luminosity:1,rampPower:1,onBeforeCompile:void 0};class l extends a.V9B{constructor(n){let{rampPower:t,shadowColor:e,luminosity:l,onBeforeCompile:c,...u}={...o,...n},i={uSunPosition:{value:new a.Pq0(.5,.7,.3)},uShadowColor:{value:new a.Q1f(e)},uRampPower:{value:t},uLuminosity:{value:l}};super(u),this.onBeforeCompile=n=>{r.bI.with(n).uniforms(i).varying({vWorldNormal:"vec3"}).vertex.mainAfterAll("\n          vWorldNormal = mat3(modelMatrix) * normal;\n          #ifdef USE_INSTANCING\n            vWorldNormal = mat3(instanceMatrix) * vWorldNormal;\n          #endif\n        ").fragment.after("map_fragment","\n          vec3 normal = normalize(vWorldNormal);\n          vec3 lightDirection = normalize(uSunPosition);\n          float light = dot(normal, lightDirection) * 0.5 + 0.5;\n          light = pow(light, uRampPower);\n          diffuseColor.rgb *= mix(uShadowColor * uLuminosity, vec3(1.0), light);\n        "),null==c||c(n)},this.sunPosition=i.uSunPosition.value}}},17099:(n,t,e)=>{"use strict";e.d(t,{c:()=>c});var a=e(79105);let r=n=>n,o={weightsAreNormalized:!1,indexOffset:0,forbiddenItems:[]};function l(){let n=(0,a.K2)((0,a.K2)((0,a.Ts)(a.KP)));function t(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:a.KP;return"string"==typeof t&&(t=t.split("").reduce((n,t)=>7*n+t.charCodeAt(0),0)),n=(0,a.K2)((0,a.K2)((0,a.Ts)(t))),f}function e(){return n=(0,a.K2)(n),(0,a.Tj)(n)}function l(n){switch(n.length){default:return[0,1,r];case 1:return[0,n[0],r];case 2:return[n[0],n[1],r];case 3:return[n[0],n[1],n[2]]}}function c(){for(var n=arguments.length,t=Array(n),a=0;a<n;a++)t[a]=arguments[a];let[r,o,c]=l(t);return r+(o-r)*c(e())}function u(){for(var n,t=arguments.length,a=Array(t),r=0;r<t;r++)a[r]=arguments[r];let[l,c,{weightsAreNormalized:u,indexOffset:i,forbiddenItems:f}]=function(n){let[t,e=null,a]=n,r={...o,...a};if(Array.isArray(t))return[t,e,r];if("object"==typeof t)return[Object.values(t),e?Object.values(e):null,r];throw Error("pick: unsupported options type")}(a);if(f.length>0){let t=new Set;for(let n of f){let e=l.indexOf(n);e>=0&&t.add(e)}if(l=l.filter((n,e)=>!t.has(e)),c=null!=(n=null==c?void 0:c.filter((n,e)=>!t.has(e)))?n:null,0===l.length)throw Error("pick: all items are forbidden")}if(null===c){let n=Math.floor(e()*l.length);return i&&(n+=i,(n%=l.length)<0&&(n+=l.length)),l[n]}if(!u){let n=c.reduce((n,t)=>n+t,0);c=c.map(t=>t/n)}let s=e(),x=0;for(let n=0;n<l.length;n++)if(s<(x+=c[n]))return l[n];throw Error("among: unreachable")}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=e(),r=e(),o=Math.sqrt(-2*Math.log(a)),l=2*Math.PI*r;return[n+t*o*Math.cos(l),n+t*o*Math.sin(l)]}let f={seed:t,seedMax:function(){return a.Zu},reset:function(){return t(a.KP),f},next:function(){return n=(0,a.K2)(n),f},getState:function(){return n},setState:function(t){return n=t&a.Zu,f},random:e,between:c,around:function(){for(var n=arguments.length,t=Array(n),a=0;a<n;a++)t[a]=arguments[a];let[o=1,l=r]=t,c=2*e();return(c>1?1:-1)*l(c>1?c-1:c)*o},int:function(){for(var n=arguments.length,t=Array(n),a=0;a<n;a++)t[a]=arguments[a];let[r,o,c]=l(t);return r+Math.floor(c(e())*(o-r))},chance:function(n){return e()<n},shuffle:function(n){let{mutate:t=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=t&&Array.isArray(n)?n:[...n],r=a.length;for(let n=0;n<r;n++){let t=Math.floor(r*e()),o=a[n];a[n]=a[t],a[t]=o}return a},pick:u,createPicker:function(n){let t=n.map(n=>{let[t]=n;return t}),e=n.map(n=>{let[t,e]=n;return e}),a=e.reduce((n,t)=>n+t,0);for(let[n,t]of e.entries())e[n]=t/a;return()=>u(t,e,{weightsAreNormalized:!0})},vector:function(n,t){let[e=0,a=1]=Array.isArray(t)?t:[null==t?void 0:t.min,null==t?void 0:t.max];for(let t of Object.keys(n))n[t]=c(e,a);return n},unitVector2:function(n){let t=2*Math.PI*e();return n.x=Math.cos(t),n.y=Math.sin(t),n},unitVector3:function(n){let t=e(),a=e(),r=2*Math.PI*t,o=Math.acos(1-2*a);return n.x=Math.sin(o)*Math.cos(r),n.y=Math.sin(o)*Math.sin(r),n.z=Math.cos(o),n},normalVector:function(n){let t=Object.keys(n),e=t.length,a=Math.sqrt(e);for(let r=0;r<e;r+=2){let[o,l]=i();n[t[r]]=o/a,r+1<e&&(n[t[r+1]]=l/a)}return n},unitVector:function(n){let t=Object.keys(n),e=t.length,a=0;for(let r=0;r<e;r+=2){let[o,l]=i();n[t[r]]=o,a+=o*o,r+1<e&&(n[t[r+1]]=l,a+=l*l)}a=Math.sqrt(a);for(let r=0;r<e;r++)n[t[r]]/=a;return n},boxMuller:i,quaternion:function(n){let t=e(),a=e(),r=e(),o=Math.sqrt(1-t),l=Math.sqrt(t);return n.x=o*Math.sin(2*Math.PI*a),n.y=o*Math.cos(2*Math.PI*a),n.z=l*Math.sin(2*Math.PI*r),n.w=l*Math.cos(2*Math.PI*r),n},insideCircle:function(n,t){let a=2*e()*Math.PI,r=Math.sqrt(e())*n;return t.x=r*Math.cos(a),t.y=r*Math.sin(a),t}};return f}let c=class{constructor(n){Object.assign(this,l().seed(n))}};Object.assign(c,l())},22899:(n,t,e)=>{"use strict";e.d(t,{I:()=>o});var a=e(65927);let r=["linear"];for(let n=1;n<=10;n++)r.push("easeIn".concat(n)),r.push("easeOut".concat(n)),r.push("easeInOut".concat(n)),r.push("easeOutIn".concat(n));let o="\n#ifndef GLSL_EASING\n#define GLSL_EASING\n\n".concat(a.S,"\n\nfloat easePow1(float x) {\n  return x;\n}\n\nfloat easePow2(float x) {\n  return x * x;\n}\n\nfloat easePow3(float x) {\n  return x * x * x;\n}\n\nfloat easePow4(float x) {\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow5(float x) {\n  float x0 = x;\n  x *= x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow6(float x) {\n  x *= x * x;\n  return x *= x;\n}\n\nfloat easePow7(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow8(float x) {\n  x *= x;\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow9(float x) {\n  x *= x * x;\n  return x *= x * x;\n}\n\nfloat easePow10(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x * x;\n  return x0 * x;\n}\n\nfloat linear(float x) {\n  return clamp01(x);\n}\n\n").concat(Array.from({length:10},(n,t)=>{let e=t+1;return"\n\n  float easeIn".concat(e," (float x) {\n    return easePow").concat(e,"(clamp01(x));\n  }\n  float easeOut").concat(e," (float x) {\n    return 1.0 - easePow").concat(e,"(clamp01(1.0 - x));\n  }\n  float easeInOut").concat(e," (float x) {\n    return x < 0.5 \n      ? 0.5 * easePow").concat(e,"(2.0 * x) \n      : 1.0 - 0.5 * easePow").concat(e,"(2.0 * (1.0 - x));\n  }\n  float easeOutIn").concat(e," (float x) {\n    return x < 0.5\n      ? 0.5 * (1.0 - easePow").concat(e,"(1.0 - x * 2.0))\n      : 1.0 - 0.5 * (1.0 - easePow").concat(e,"(2.0 * x - 1.0));\n  }\n\n").trim()}).join("\n\n"),"\n\n\n// https://www.desmos.com/calculator/mqou4lf9zc?lang=fr\nfloat easeInOut(float x, float p, float i) {\n  return  x <= 0.0 ? 0.0 :\n          x >= 1.0 ? 1.0 :\n          x <= i ? 1.0 / pow(i, p - 1.0) * pow(x, p) :\n          1.0 - 1.0 / pow(1.0 - i, p - 1.0) * pow(1.0 - x, p);\n}\n\n// https://www.desmos.com/calculator/nrjlezusdv\nfloat easeInThenOut(float x, float p) {\n  return 1.0 - pow(abs(2.0 * x - 1.0), p);\n}\n\n#endif\n")},65927:(n,t,e)=>{"use strict";e.d(t,{S:()=>a});let a="\n#ifndef GLSL_BASIC\n#define GLSL_BASIC\n\nfloat clamp01(float x) {\n  return x < 0.0 ? 0.0 : x > 1.0 ? 1.0 : x;\n}\n\nvec2 clamp01(vec2 x) {\n  return vec2(clamp01(x.x), clamp01(x.y));\n}\n\nvec3 clamp01(vec3 x) {\n  return vec3(clamp01(x.x), clamp01(x.y), clamp01(x.z));\n}\n\nvec4 clamp01(vec4 x) {\n  return vec4(clamp01(x.x), clamp01(x.y), clamp01(x.z), clamp01(x.w));\n}\n\n#endif\n"},66620:(n,t,e)=>{"use strict";e.d(t,{_:()=>o});var a=e(89868),r=e(44138);function o(n,t){var e=(0,r._)(n,t,"update");return(0,a._)(n,e)}},79105:(n,t,e)=>{"use strict";e.d(t,{K2:()=>l,KP:()=>r,Tj:()=>c,Ts:()=>o,Zu:()=>a});let a=0x7fffffff,r=123456,o=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r;if(Number.isNaN(n))throw Error("NaN is not a valid seed.");let t=n;if(10>Math.abs(t)&&(t*=1e6),t%=a,(t=t<0?t+a:t)>1)return t&a;if(0===t)return r;throw Error("Impossible. ".concat(t))},l=n=>n=Math.imul(n,48271)&a,c=n=>(n-1)/(a-1)},88575:(n,t,e)=>{"use strict";e.d(t,{O0:()=>a.O0,XW:()=>a.XW});var a=e(82143)},92845:(n,t,e)=>{Promise.resolve().then(e.bind(e,32595))}},n=>{var t=t=>n(n.s=t);n.O(0,[9459,5611,7190,6564,4189,7962,9635,8921,7953,4512,7775,7436,146,6726,3445,9332,3414,9717,1763,2143,2595,1319,6852,7358],()=>t(92845)),_N_E=n.O()}]);