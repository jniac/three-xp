(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6219],{3009:(e,t,n)=>{"use strict";n.d(t,{Zt:()=>a,zf:()=>i,QS:()=>s});let i="\n#ifndef GLSL_BEND\n#define GLSL_BEND\n  vec4 applyBend(vec4 position, float factor, mat4 bendMatrix, mat4 bendMatrixInverse) {\n    float q = 1.0 / factor;\n    \n    if (abs(factor) < 0.0001)\n      return position;\n    \n    position = bendMatrixInverse * position;\n    vec2 center = vec2(0.0, q);\n    float a = position.x / q;\n    float r = center.y - position.y;\n    position.x = center.x + r * sin(a);\n    position.y = center.y + -r * cos(a);\n    position = bendMatrix * position;\n    return position;\n  }\n#endif\n";var r=n(49797),o=n(7147);function a(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"white";return{uBendFactor:{value:0},uBendMatrix:{value:e.clone()},uBendMatrixInverse:{value:e.clone().invert()},uMyColor:{value:new r.Q1f(t)}}}function s(e,t){o.bI.with(e).uniforms(t).vertex.top(i).vertex.replace("project_vertex","\n  vec4 mvPosition = vec4( transformed, 1.0 );\n  #ifdef USE_BATCHING\n    mvPosition = batchingMatrix * mvPosition;\n  #endif\n  #ifdef USE_INSTANCING\n    mvPosition = instanceMatrix * mvPosition;\n  #endif\n  mvPosition = modelMatrix * mvPosition;\n  mvPosition = applyBend(mvPosition, uBendFactor, uBendMatrix, uBendMatrixInverse);\n  mvPosition = viewMatrix * mvPosition;\n  gl_Position = projectionMatrix * mvPosition;\n")}},14203:(e,t,n)=>{"use strict";n.d(t,{O:()=>r});var i=n(1029);let r="\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; \n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat permute(float x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nfloat taylorInvSqrt(float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\n\n\n\n\n// 2D:\n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n		+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// 3D: \n\nfloat snoise(vec3 v)\n{ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\n\n// 4D:\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n						\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v) {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n  // First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n  // Other corners\n\n  // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n  //  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n  //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n  // Permutations\n  i = mod289(i); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n  // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n  // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n  // Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n  // Mix contributions from the five corners\n  vec3 m0 = max(0.57 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.57 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 60.1 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\n\n\n\n// addons:\n// Fractal noise, based on Stefan Gustavson's Simplex noise\n".concat((0,i.N)(["vec2","vec3","vec4"],"\n  float fnoise(T p, int octaves, float persistence) {\n    float total = 0.0;           // Final noise value\n    float amplitude = 1.0;       // Initial amplitude\n    float frequency = 1.0;       // Initial frequency\n    float maxValue = 0.0;        // Used for normalization\n\n    for (int i = 0; i < octaves; i++) {\n      total += snoise(p * frequency) * amplitude;\n\n      maxValue += amplitude;   // Keep track of max amplitude\n      amplitude *= persistence; // Reduce amplitude for next octave\n      frequency *= 2.0;        // Increase frequency for next octave\n    }\n\n    // Normalize the result to stay within the range [0, 1]\n    return total / maxValue;\n  }\n\n  float fnoise(T p, int octaves) {\n    return fnoise(p, octaves, 0.5);\n  }\n\n  float fnoise(T p) {\n    return fnoise(p, 4, 0.5);\n  }\n"),"\n\nfloat snoiseFast4D(vec4 p) {\n  const float SCALAR = 0.01;\n  float a = SCALAR * dot(p.xy * 0.3, vec2(-127.1, 311.7));\n  float b = SCALAR * dot(p.zw * 0.8, vec2(269.5, -183.3));\n  float c = SCALAR * dot(p.wx * 6.0, vec2(23.14069, 2.665157));\n  float d = SCALAR * dot(p.zy * 1.3, vec2(-12.9898, 78.233));\n  return (snoise(vec2(a, b)) + snoise(vec2(d, c))) * 0.5;\n}\n\nfloat fnoiseFast4D(vec4 p, int octaves, float persistence) {\n  float total = 0.0;           // Final noise value\n  float amplitude = 1.0;       // Initial amplitude\n  float frequency = 1.0;       // Initial frequency\n  float maxValue = 0.0;        // Used for normalization\n\n  for (int i = 0; i < octaves; i++) {\n    total += snoiseFast4D(p * frequency) * amplitude;\n\n    maxValue += amplitude;   // Keep track of max amplitude\n    amplitude *= persistence; // Reduce amplitude for next octave\n    frequency *= 2.0;        // Increase frequency for next octave\n  }\n\n  // Normalize the result to stay within the range [0, 1]\n  return total / maxValue;\n}\n")},21667:(e,t,n)=>{"use strict";n.d(t,{G:()=>a});let i=new WeakMap,r=(e=>()=>{let t=i.get(e);if(void 0===t){let t=e();return i.set(e,t),t}return t})(()=>{let e=new WeakMap;return{resizeObserver:new ResizeObserver(t=>{for(let n of t){let t=e.get(n.target);if(t)for(let e of t)e(n)}}),resizeObserverMap:e}});class o{get width(){return this.size.x}get height(){return this.size.y}get aspect(){return this.size.x/this.size.y}constructor(e,t){this.element=e,this.size=t}}function a(e,t){let{onSize:n}=function(e){if("function"==typeof e)return{onSize:e};let{onSize:t=()=>{}}=null!=e?e:{};return{onSize:t}}(t),i=new DOMPoint(0,0);if(e instanceof Window){let t=()=>{i.x=window.innerWidth,i.y=window.innerHeight,n(new o(e,i))};return e.addEventListener("resize",t),t(),{destroy:()=>{e.removeEventListener("resize",t)}}}{var a;let{resizeObserver:t,resizeObserverMap:s}=r();t.observe(e);let l=null!=(a=s.get(e))?a:new Set,c=t=>{i.x=t.contentRect.width,i.y=t.contentRect.height,n(new o(e,i))};return s.set(e,l),l.add(c),{destroy:()=>{let n=s.get(e);if(!n)throw Error("Wtf??? No callbacks found for element");n.delete(c),0===n.size&&(s.delete(e),t.unobserve(e))}}}}},22899:(e,t,n)=>{"use strict";n.d(t,{I:()=>o});var i=n(65927);let r=["linear"];for(let e=1;e<=10;e++)r.push("easeIn".concat(e)),r.push("easeOut".concat(e)),r.push("easeInOut".concat(e)),r.push("easeOutIn".concat(e));let o="\n#ifndef GLSL_EASING\n#define GLSL_EASING\n\n".concat(i.S,"\n\nfloat easePow1(float x) {\n  return x;\n}\n\nfloat easePow2(float x) {\n  return x * x;\n}\n\nfloat easePow3(float x) {\n  return x * x * x;\n}\n\nfloat easePow4(float x) {\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow5(float x) {\n  float x0 = x;\n  x *= x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow6(float x) {\n  x *= x * x;\n  return x *= x;\n}\n\nfloat easePow7(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow8(float x) {\n  x *= x;\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow9(float x) {\n  x *= x * x;\n  return x *= x * x;\n}\n\nfloat easePow10(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x * x;\n  return x0 * x;\n}\n\nfloat linear(float x) {\n  return clamp01(x);\n}\n\n").concat(Array.from({length:10},(e,t)=>{let n=t+1;return"\n\n  float easeIn".concat(n," (float x) {\n    return easePow").concat(n,"(clamp01(x));\n  }\n  float easeOut").concat(n," (float x) {\n    return 1.0 - easePow").concat(n,"(clamp01(1.0 - x));\n  }\n  float easeInOut").concat(n," (float x) {\n    return x < 0.5 \n      ? 0.5 * easePow").concat(n,"(2.0 * x) \n      : 1.0 - 0.5 * easePow").concat(n,"(2.0 * (1.0 - x));\n  }\n  float easeOutIn").concat(n," (float x) {\n    return x < 0.5\n      ? 0.5 * (1.0 - easePow").concat(n,"(1.0 - x * 2.0))\n      : 1.0 - 0.5 * (1.0 - easePow").concat(n,"(2.0 * x - 1.0));\n  }\n\n").trim()}).join("\n\n"),"\n\n\n// https://www.desmos.com/calculator/mqou4lf9zc?lang=fr\nfloat easeInOut(float x, float p, float i) {\n  return  x <= 0.0 ? 0.0 :\n          x >= 1.0 ? 1.0 :\n          x <= i ? 1.0 / pow(i, p - 1.0) * pow(x, p) :\n          1.0 - 1.0 / pow(1.0 - i, p - 1.0) * pow(1.0 - x, p);\n}\n\n// https://www.desmos.com/calculator/nrjlezusdv\nfloat easeInThenOut(float x, float p) {\n  return 1.0 - pow(abs(2.0 * x - 1.0), p);\n}\n\n#endif\n")},25027:(e,t,n)=>{"use strict";n.d(t,{AboutScene:()=>B});var i=n(28535),r=n(76999),o=n(57368),a=n(49797),s=n(39571);let l={name:"FilmShader",uniforms:{tDiffuse:{value:null},time:{value:0},intensity:{value:.5},grayscale:{value:!1}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		#include <common>

		uniform float intensity;
		uniform bool grayscale;
		uniform float time;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 base = texture2D( tDiffuse, vUv );

			float noise = rand( fract( vUv + time ) );

			vec3 color = base.rgb + base.rgb * clamp( 0.1 + noise, 0.0, 1.0 );

			color = mix( base.rgb, color, intensity );

			if ( grayscale ) {

				color = vec3( luminance( color ) ); // assuming linear-srgb

			}

			gl_FragColor = vec4( color, base.a );

		}`};class c extends s.o{constructor(e=.5,t=!1){super(),this.uniforms=a.LlO.clone(l.uniforms),this.material=new a.BKk({name:l.name,uniforms:this.uniforms,vertexShader:l.vertexShader,fragmentShader:l.fragmentShader}),this.uniforms.intensity.value=e,this.uniforms.grayscale.value=t,this._fsQuad=new s.F(this.material)}render(e,t,n,i){this.uniforms.tDiffuse.value=n.texture,this.uniforms.time.value+=i,this.renderToScreen?e.setRenderTarget(null):(e.setRenderTarget(t),this.clear&&e.clear()),this._fsQuad.render(e)}dispose(){this.material.dispose(),this._fsQuad.dispose()}}var u=n(33540),f=n(31763),d=n(94065),h=n(77794),p=n(7147),v=n(79911),x=n(55227),m=n(14203),g=n(8144),y=n(56002),w=n(6726),z=n(67235),b=n(36508),S=n(36398),A=n(13565),M=n(35375);let P="".concat(M.$.assetsPath,"fonts/Lithops-Regular.woff2");async function C(e){let t=new a.I9Y(1024,1024),n=document.createElement("canvas");n.width=t.x,n.height=t.y;let i=new FontFace("Lithops","url(".concat(P,")"));await i.load(),await document.fonts.ready;let r=n.getContext("2d");r.fillStyle="#000",r.fillRect(0,0,t.x,t.y),r.fillStyle="#ffffff",r.font="430px Lithops";let o=10;r.fillText("Procedural Design",-100,o+=330),r.fillText("Algorithmic Art",-300,o+=330),r.fillText("Generative Art",-300,o+=330);let s=new a.GOR(n);return s.colorSpace=a.er$,new A.q({size:t,filter:"linear",generateMipmaps:!0}).shaders({initial:{uniforms:{uStencilMap:{value:s}},fragmentTop:"\n          ".concat("\n  const int MAX_KERNEL_RADIUS = 20;\n  float signedDistanceField(sampler2D uTexture, vec2 vUv, vec2 uTexelSize, int uKernelRadius) {\n    float centerValue = texture2D(uTexture, vUv).r;\n    bool inside = centerValue > 0.5;\n\n    float minDistance = 1e20;\n\n    for (int dy = -MAX_KERNEL_RADIUS; dy <= MAX_KERNEL_RADIUS; dy++) {\n      for (int dx = -MAX_KERNEL_RADIUS; dx <= MAX_KERNEL_RADIUS; dx++) {\n        if (abs(dx) > uKernelRadius || abs(dy) > uKernelRadius) continue;\n\n        vec2 offset = vec2(float(dx), float(dy)) * uTexelSize;\n        vec2 sampleUv = vUv + offset;\n        float sampleValue = texture2D(uTexture, sampleUv).r;\n\n        if ((inside && sampleValue <= 0.5) || (!inside && sampleValue > 0.5)) {\n          float dist = length(offset);\n          minDistance = min(minDistance, dist);\n        }\n      }\n    }\n\n    return inside ? -minDistance : minDistance;\n  }\n","\n          ").concat(g.H,"\n        "),fragmentColor:"\n          vec4 stencilTexel = texture2D(uStencilMap, vUv);\n          int kernelRadius = 20;\n          vec2 texelSize = 1.0 / uTextureSize;\n          \n          float dist = \n            signedDistanceField(uStencilMap, vUv, texelSize, kernelRadius);\n          \n          dist = dist >= 0.0 \n            ? dist\n            : spow(dist * 1000.0, 2.0) / 1000.0; // compress negative distances \n          \n          dist /= length(texelSize * float(kernelRadius) / 1.414213); // normalize by max distance in kernel\n\n          gl_FragColor = vec4(dist, stencilTexel.r, 0.0, 1.0);\n          // gl_FragColor = vec4(stencilTexel.r, 1.0, 1.0, 1.0);\n      "}}).initialize(e).currentTexture()}var R=n(77674),D=n(74740),T=n(30123),L=n(74842),Y=n(44019),I=n(3009),X=n(45553),O=n(3293),E=n(44694),F=n(80446);class U{get length(){return this.getLength()}set length(e){this.setLength(e)}*positions(){yield this.start.x,yield this.start.y,yield this.start.z,yield this.end.x,yield this.end.y,yield this.end.z}*colors(){yield this.startColor.r,yield this.startColor.g,yield this.startColor.b,yield this.endColor.r,yield this.endColor.g,yield this.endColor.b}getChild(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];let i=this;for(let e of t)i=i.children[e];return i}getLength(){return this.start.distanceTo(this.end)}setLength(e){let{_v:t}=(0,R._)(U,U,_),n=t.subVectors(this.end,this.start).normalize();return this.end.copy(this.start).addScaledVector(n,e),this}mulLength(e){let{_v:t}=(0,R._)(U,U,_);return t.subVectors(this.end,this.start).multiplyScalar(e),this.end.copy(this.start).add(t),this}isRoot(){return null===this.parent}isLeaf(){return 0===this.children.length}allDescendantsCount(){let e=1;for(let t of this.children)e+=t.allDescendantsCount();return e}*allDescendantsColors(){for(let e of this.allDescendants({includeSelf:!0}))yield*e.colors()}*allDescendantsPositions(){for(let e of this.allDescendants({includeSelf:!0}))yield*e.positions()}*allDescendants(){let{includeSelf:e=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};for(let t of(e&&(yield this),this.children))yield*t.allDescendants({includeSelf:!0})}*allLeaves(){let{includeSelf:e=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};for(let t of this.allDescendants({includeSelf:e}))t.isLeaf()&&(yield t)}split(e){let{angle:t="45deg",length:n=1,lengthVariationFactor:i=1,altDir:r,altDirWeight:o=0}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},s=new a.Pq0().subVectors(this.end,this.start),l=s.length();if(s.divideScalar(l),r){let e=(0,Y.jj)(r).normalize();(0,X.z)(s,e,o,s)}let c=(0,E.ey)(t);for(let t=0;t<e;t++){let r=n*Math.pow(i,F.n.number(-1,1)),o=new U(this.end,new a.Pq0().addVectors(this.end,s.clone().applyAxisAngle(this.normal,c).applyAxisAngle(s,2*Math.PI*t/e).multiplyScalar(r)),this.normal);o.parent=this,this.children.push(o)}return this}constructor(e,t,n){this.start=e,this.end=t,this.normal=n,this.parent=null,this.children=[],this.startColor=new a.Q1f("white"),this.endColor=new a.Q1f("white")}}var _={writable:!0,value:{_v:new a.Pq0}};class N extends a.YJl{setPositionOnScene(e){return this.positionOnScene=e,this}enableBend(){let e={rotationZ:"90deg",rotationY:"20deg"},t=(0,I.Zt)((0,O.w)(e));return this.material.onBeforeCompile=e=>{p.bI.with(e).uniforms({...t,uTime:this.uTime}).vertex.top(I.zf,m.O);let n=e.vertexShader,i=e.vertexShader.indexOf("vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );"),r=e.vertexShader.indexOf("vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );");e.vertexShader=n.substring(0,i)+"\n          vec4 start = vec4( instanceStart, 1.0 );\n          vec4 end = vec4( instanceEnd, 1.0 );\n\n          start = modelMatrix * start;\n          end = modelMatrix * end;\n\n          start = applyBend(start, uBendFactor, uBendMatrix, uBendMatrixInverse);\n          end = applyBend(end, uBendFactor, uBendMatrix, uBendMatrixInverse);\n\n          float time = uTime * 0.15;\n          float noiseScale = 0.825;\n          float startNoise = snoise(vec4(start.xyz * noiseScale, time)) * instanceStart.y;\n          float endNoise = snoise(vec4(end.xyz * noiseScale, time)) * instanceEnd.y;\n\n          start.xz += vec2(1.0, -1.0) * startNoise * 0.01;\n          end.xz += vec2(1.0, -1.0) * endNoise * 0.01;\n\n          start = viewMatrix * start;\n          end = viewMatrix * end;\n        "+n.substring(r+54)},this.bendUniforms=t,this.bendTransform=e,this}updateBendTransform(e){return this.bendUniforms&&((0,O.w)(e,this.bendUniforms.uBendMatrix.value),this.bendUniforms.uBendMatrixInverse.value.copy(this.bendUniforms.uBendMatrix.value).invert()),this}update(e){if(this.uTime.value+=e,this.bendUniforms){let e=this.uTime.value;this.bendUniforms.uBendFactor.value=.33*(.1*Math.sin(1.5*e)+.03*Math.sin(3.34*e)+.01*Math.sin(4.732*e))}return this}constructor(e=256789,{splitIndices:t=[[2]]}={}){super(),this.uTime={value:0},this.bendUniforms=null,this.bendTransform=null;let n=new U(new a.Pq0(0,0,0),new a.Pq0(0,1,0),new a.Pq0(1,0,0));for(let i of(F.n.setRandom("parkmiller",e),n.split(3,{angle:"15deg",lengthVariationFactor:1.8}),t))n.getChild(...i).mulLength(1.2).split(3,{angle:"20deg",lengthVariationFactor:1.4});for(let e of[...n.allLeaves()])e.split(6,{angle:"70deg",length:.28,altDir:[0,1,1],altDirWeight:.5}),e.split(1,{angle:"0deg",length:.17,altDir:[0,1,1],altDirWeight:.5});for(let e of[...n.allLeaves()])e.split(11,{angle:"70deg",length:.12,altDir:[0,1,0],altDirWeight:.5});for(let e of[...n.allLeaves()])e.split(13,{angle:"70deg",length:.04,altDir:[0,1,0],altDirWeight:.75});{let e=new a.Q1f("#ecde0d"),t=new a.Q1f("#fff"),i=0,r=new Set(n.allLeaves()),o=new Set,s=()=>{[r,o]=[o,r]},l=e=>Math.min(1,Math.max(0,e));for(;r.size>0;){for(let n of r)n.endColor.lerpColors(e,t,l(i/3)),n.startColor.lerpColors(e,t,l((i+1)/3)),n.parent&&o.add(n.parent);r.clear(),s(),i++}}let i=new D.n;i.setPositions([...n.allDescendantsPositions()]),i.setColors([...n.allDescendantsColors()]);let r=new T.G({color:"white",worldUnits:!0,linewidth:.0015,vertexColors:!0});(0,v.mj)(new L.b(i,r),this),this.scale.setScalar(.25),this.material=r}}var j=new WeakMap;class q extends h.u{drawLayout(e,t){this.clear();let{rect:n}=(0,i._)(this,j),r=["#f0f","#0ff","#ff0"].map(e=>new a.Q1f(e)),o=0,[s,l]=(0,d.wX)(t);for(let t of e.allLeaves())t.getUvRect({out:n,flipY:!0}).transform(-s/2,-l/2,s,l),this.rect(n,{color:r[o],diagonals:!0,corners:{size:.05}}),o=(o+1)%r.length;return this}constructor(...e){super(...e),(0,r._)(this,j,{writable:!0,value:void 0}),(0,o._)(this,j,{rect:new w.M_})}}function B(){let e=(0,u.Fw)(),t=(0,S.B)();return(0,u.dB)("my-scene",async function*(n){let i=new c(.5,!1);e.pipeline.composer.addPass(i),yield()=>e.pipeline.composer.removePass(i);let r={uAboutMap:{value:await C(e.renderer)},uPlaneSize:{value:new a.I9Y},uTime:b.Rv.get("three").uTime},o=new a.V9B({transparent:!0});o.onBeforeCompile=e=>p.bI.with(e).defines("USE_UV").uniforms(r).fragment.top(g.H,m.O,y.p,x.M).fragment.top("\n        float siiiin(float x) {\n          return sin(x * 3.14159265);\n        }\n      ").fragment.after("map_fragment","\n        float timeScale = 0.05;\n        vec2 uv = applyUvSize(vUv, uPlaneSize.x / uPlaneSize.y, 1.0);\n        float d = texture(uAboutMap, uv).r;\n        float n = fnoise(vec3(uv * 0.25 * vec2(1.0, 8.0), uTime * timeScale), 3);\n        float n2 = fnoise(vec3(uv * 0.25 * vec2(1.0, 8.0), (uTime + 1.3) * timeScale), 3);\n        // n = spow(n, 2.0);\n        d += n * 0.75;\n        // d += -0.5 * (sin(uTime) * 0.5 + 0.5);\n        d = smoothstep(0.0, 0.05, d);\n        // diffuseColor.rgb = mix(".concat((0,p.eR)("#979687"),", ").concat((0,p.eR)("#220793"),", d);\n        // diffuseColor.rgb = ").concat((0,p.eR)("#979687"),";\n        // diffuseColor.rgb = ").concat((0,p.eR)("#220793"),";\n\n        n2 = n2 * 0.8 + 0.5;\n\n        // diffuseColor.rgb = mix(").concat((0,p.eR)("#0993efff"),", ").concat((0,p.eR)("#220793"),", mix(n2, siiiin(n2 * 5.0), 0.15));\n        float t = mix(n2, siiiin(n2 * 5.0), 0.15);\n        Vec3Ramp r = ramp(t, ").concat((0,p.eR)("#0993efff"),", ").concat((0,p.eR)("#2556d2ff"),", ").concat((0,p.eR)("#220793"),");\n        diffuseColor.rgb = mix(r.a, r.b, r.t);\n\n        // gamma correction\n        diffuseColor.rgb = pow(diffuseColor.rgb, vec3(2.2));\n        diffuseColor.a *= oneMinus(d);\n      "));let s=(0,v.mj)(new a.eaF(new a.bdM,o),n),l=z.Q.send(f.n).assertPayload(),u=(0,v.mj)(new q,n);u.visible=!1;let d=(0,v.mj)(new N,n).setPositionOnScene(e=>{d.position.set(-(.16*e.x),-(.48*e.y),.75),d.rotation.set(0,.25,0)}).enableBend();yield e.ticker.onTick(e=>{d.updateBendTransform({position:d.position,rotationZ:"90deg",rotationY:"20deg"}),d.update(e.deltaTime)}),yield t.changeObs.onChange({executeImmediately:!0},()=>{var e;if(!1===t.isReady)return;u.visible&&u.drawLayout(t.root,l.dampedVertigo.state.realSize);let[n,i]=l.dampedVertigo.state.realSize,o=t.left.getUvRect({flipY:!0}).transform(-n/2,-i/2,n,i);s.position.set(o.centerX,o.centerY,0),s.scale.set(o.width,o.height,1),r.uPlaneSize.value.set(o.width,o.height),null==(e=d.positionOnScene)||e.call(d,l.dampedVertigo.state.realSize)})},[]),null}},26584:(e,t,n)=>{"use strict";n.d(t,{DevHideNextJs:()=>r});var i=n(67203);function r(){return(0,i.useEffect)(()=>{let e=document.querySelector("nextjs-portal");null==e||e.setAttribute("style","display: none !important")}),null}},35375:(e,t,n)=>{"use strict";n.d(t,{$:()=>r});let i="/three-xp/assets/",r={development:!1,assetsPath:i,assets:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return"".concat(i).concat(e)}}},36398:(e,t,n)=>{"use strict";n.d(t,{AboutLayoutProvider:()=>d,B:()=>f});var i=n(70691),r=n(67203),o=n(21667),a=n(18479),s=n(42206),l=n(85795);class c{get isReady(){return this.changeObs.value>0}constructor(){this.changeObs=new l.ObservableNumber(0),this.root=new s.$x({direction:"vertical"}).add(new s.$x({name:"header",size:["1rel",64]}),new s.$x({size:["1rel",2]}),new s.$x({name:"bottom",size:["1rel","1fr"]}).add(new s.$x({name:"left",size:["1fr","1rel"]}),new s.$x({size:[2,"1rel"]}),new s.$x({size:["1fr","1rel"]}))),this.header=this.root.find("header"),this.left=this.root.find("left")}}let u=(0,r.createContext)(null);function f(){return(0,r.useContext)(u)}function d(e){let{children:t}=e,n=(0,r.useMemo)(()=>new c,[]),{ref:s}=(0,a.useEffects)(function*(e){let t=e.parentElement;yield(0,o.G)(t,{onSize:e=>{n.root.setSize(e.size.x,e.size.y),n.root.computeLayout(),n.changeObs.value++,window.requestAnimationFrame(()=>{n.changeObs.value++})}})},[]);return(0,i.jsxs)(u.Provider,{value:n,children:[(0,i.jsx)("div",{ref:s,style:{display:"none"}}),t]})}},42206:(e,t,n)=>{"use strict";n.d(t,{OP:()=>h.OP,EU:()=>h.EU,LN:()=>l,$x:()=>z}),function(e){e[e.Auto=0]="Auto",e[e.Absolute=1]="Absolute",e[e.Relative=2]="Relative",e[e.OppositeRelative=3]="OppositeRelative",e[e.SmallerRelative=4]="SmallerRelative",e[e.LargerRelative=5]="LargerRelative",e[e.Fraction=6]="Fraction"}(l||(l={}));let i={abs:l.Absolute,rel:l.Relative,opp:l.OppositeRelative,sm:l.SmallerRelative,lg:l.LargerRelative,fr:l.Fraction},r={"%":l.Relative,part:l.Fraction,sh:l.Fraction},o={...i,...r},a=Object.fromEntries(Object.entries(o).map(e=>{let[t,n]=e;return[n,t]}));class s{static parse(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new s;return t.parse(e),t}set(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.type;this.value=e,this.type=t}compute(e,t){switch(this.type){case l.Absolute:return this.value;case l.Relative:return this.value*e;case l.OppositeRelative:return this.value*t;case l.SmallerRelative:return this.value*Math.min(e,t);case l.LargerRelative:return this.value*Math.max(e,t);case l.Auto:case l.Fraction:return e}}parse(e){return!function(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new s;if("auto"===e)return n.value=1,n.type=l.Auto;if("number"==typeof e)return n.value=e,n.type=l.Absolute;if("string"!=typeof e)throw console.log("received:",e),Error("Invalid scalar declaration");let i=e.match(/([\d\.]+)([a-z%]+)?$/);if(!i)throw console.log("received:",e),Error("Invalid scalar declaration");let[r,a,c]=i,u=Number.parseFloat(a),f=null!=(t=o[c])?t:l.Absolute;if(Number.isNaN(u))throw Error("Invalid scalar declaration");"%"===c&&(u/=100),n.value=u,n.type=f}(e,this),this}toString(){return"".concat(this.value).concat(a[this.type])}constructor(e=0,t=l.Absolute){this.value=e,this.type=t}}var l,c=n(44694),u=n(6726),f=n(43107),d=n(69975),h=n(56905);let p=new d.Y,v=[];function x(e,t,n,i,r){let o=0,a=0;if(i===h.OP.Horizontal&&(e.sizeX.type===l.Auto||e.sizeX.type===l.Fraction)&&(n=Math.max(0,n-Math.max(0,r.top-p.top)-Math.max(0,r.bottom-p.bottom))),i===h.OP.Vertical&&(e.sizeY.type===l.Auto||e.sizeY.type===l.Fraction)&&(t=Math.max(0,t-Math.max(0,r.left-p.left)-Math.max(0,r.right-p.right))),null!==e.aspect){let r=!1;if(e.sizeX.type===l.Auto)r=e.sizeY.type!==l.Auto||i===h.OP.Horizontal;else if(e.sizeY.type===l.Auto)r=!1;else throw Error('When aspect ratio is defined, at least one of the sizeX or sizeY must be "auto"');r?a=(o=e.sizeX.compute(t,n))/e.aspect:o=(a=e.sizeY.compute(n,t))*e.aspect}else o=e.sizeX.compute(t,n),a=e.sizeY.compute(n,t);e.rect.width=e.extraSizeX.compute(o,a),e.rect.height=e.extraSizeY.compute(a,o)}let m=new u.M_;function g(e,t,n){if(Array.isArray(e)){let[i,r]=e;return t.parse(i),n.parse(r),[t,n]}return"object"==typeof e?(t.parse(e.x),n.parse(e.y)):(t.parse(e),n.parse(e)),[t,n]}function y(e){if(!1===Array.isArray(e))return[e,e,e,e];if(1===e.length)return[e[0],e[0],e[0],e[0]];if(2===e.length)return[e[0],e[1],e[0],e[1]];if(4===e.length)return e;throw Error("Invalid number of arguments")}function w(e){return"*"===e?()=>!0:"string"==typeof e?t=>t.name===e:e instanceof RegExp?t=>e.test(t.name):e}class z{set(e){if(void 0!==e.name&&(this.name=e.name),void 0!==e.direction&&(this.direction=(0,h.T$)(e.direction)),void 0!==e.positioning&&(this.positioning=(0,h.$P)(e.positioning)),void 0!==e.offset&&g(e.offset,this.offsetX,this.offsetY),void 0!==e.offsetX&&this.offsetX.parse(e.offsetX),void 0!==e.offsetY&&this.offsetY.parse(e.offsetY),void 0!==e.size&&g(e.size,this.sizeX,this.sizeY),void 0!==e.sizeX&&this.sizeX.parse(e.sizeX),void 0!==e.sizeY&&this.sizeY.parse(e.sizeY),void 0!==e.aspect&&(this.aspect=e.aspect),void 0!==e.alignChildren){let{x:t,y:n}=(0,c.wX)(e.alignChildren);this.alignChildrenX=t,this.alignChildrenY=n}if(void 0!==e.alignChildrenX&&(this.alignChildrenX=e.alignChildrenX),void 0!==e.alignChildrenY&&(this.alignChildrenY=e.alignChildrenY),void 0!==e.alignSelf){let{x:t,y:n}=(0,c.wX)(e.alignSelf);this.alignSelfX=t,this.alignSelfY=n}if(void 0!==e.alignSelfX&&(this.alignSelfX=e.alignSelfX),void 0!==e.alignSelfY&&(this.alignSelfY=e.alignSelfY),void 0!==e.padding){let[t,n,i,r]=y(e.padding);this.padding[0].parse(t),this.padding[1].parse(n),this.padding[2].parse(i),this.padding[3].parse(r)}if(void 0!==e.paddingTop&&this.padding[0].parse(e.paddingTop),void 0!==e.paddingRight&&this.padding[1].parse(e.paddingRight),void 0!==e.paddingBottom&&this.padding[2].parse(e.paddingBottom),void 0!==e.paddingLeft&&this.padding[3].parse(e.paddingLeft),void 0!==e.margin){let[t,n,i,r]=y(e.margin);this.margin[0].parse(t),this.margin[1].parse(n),this.margin[2].parse(i),this.margin[3].parse(r)}if(void 0!==e.marginTop&&this.margin[0].parse(e.marginTop),void 0!==e.marginRight&&this.margin[1].parse(e.marginRight),void 0!==e.marginBottom&&this.margin[2].parse(e.marginBottom),void 0!==e.marginLeft&&this.margin[3].parse(e.marginLeft),void 0!==e.gap&&this.gap.parse(e.gap),void 0!==e.spacing){let[t,n,i,r,o]=function(e){if(!1===Array.isArray(e))return[e,e,e,e,e];let[t,...n]=e;return[t,...y(n)]}(e.spacing);this.gap.parse(t),this.padding[0].parse(n),this.padding[1].parse(i),this.padding[2].parse(r),this.padding[3].parse(o)}return void 0!==e.userData&&Object.assign(this.userData,e.userData),this}setDirection(e){return this.direction=(0,h.T$)(e),this}setPositioning(e){return this.positioning=(0,h.$P)(e),this}setOffset(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];if(t[0]&&"object"==typeof t[0]){let{x:e,y:n=e}=t[0];this.offsetX.parse(e),this.offsetY.parse(n)}else{let[e,n=e]=t;this.offsetX.parse(e),this.offsetY.parse(n)}return this}setSize(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];if(t[0]&&"object"==typeof t[0]){let{x:e,y:n=e}=t[0];this.sizeX.parse(e),this.sizeY.parse(n)}else{let[e,n=e]=t;this.sizeX.parse(e),this.sizeY.parse(n)}return this}setOffsetSizeAsAbsoluteRect(e){return this.offsetX.set(e.x,l.Absolute),this.offsetY.set(e.y,l.Absolute),this.sizeX.set(e.width,l.Absolute),this.sizeY.set(e.height,l.Absolute),this}setAlign(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e;return this.alignChildrenX=e,this.alignChildrenY=t,this}setUserData(e){return Object.assign(this.userData,e),this}setPadding(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];1===t.length&&Array.isArray(t[0])&&(t=t[0]);let[i,r,o,a]=y(t);return this.padding[0].parse(i),this.padding[1].parse(r),this.padding[2].parse(o),this.padding[3].parse(a),this}setGap(e){return this.gap.parse(e),this}setSpacing(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];let[i,...r]=t;return this.setGap(i),r.length>0?this.setPadding.apply(this,r):this.setPadding(i),this}isRoot(){return null===this.parent}isLeaf(){return 0===this.children.length}depth(){let e=0,t=this;for(;t;)t=t.parent,e++;return e}*allDescendants(){let{includeSelf:e=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};for(let t of(e&&(yield this),this.children))yield*t.allDescendants({includeSelf:!0})}descendantsCount(){let{includeSelf:e=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=0;for(let n of this.allDescendants({includeSelf:e}))t++;return t}*allAncestors(){let{includeSelf:e=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e?this:this.parent;for(;t;)yield t,t=t.parent}*allLeaves(){let{includeSelf:e=!0}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};for(let t of this.allDescendants({includeSelf:e}))0===t.children.length&&(yield t)}leavesCount(){let{includeSelf:e=!0}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=0;for(let n of this.allLeaves({includeSelf:e}))t++;return t}path(){let e=[],t=this;for(;t.parent;)e.push(t.parent.children.indexOf(t)),t=t.parent;return e.reverse()}get(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];let i=t[0]&&"object"==typeof t[0]&&Symbol.iterator in t[0]?t[0]:t,r=this;for(let e of i)if(e<0&&(e=r.children.length+e),!(r=r.children[e]))return null;return r}find(e){let{includeSelf:t=!0}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for(let n of(e=w(e),this.allDescendants({includeSelf:t})))if(e(n))return n;return null}*findAll(e){let{includeSelf:t=!0}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for(let n of(e=w(e),this.allDescendants({includeSelf:t})))e(n)&&(yield n)}pointCast(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];let[i,r]=1===t.length?[t[0].x,t[0].y]:t;for(let e of this.allLeaves())if(e.rect.containsXY(i,r))return e;return null}getRoot(){let e=this;for(;e.parent;)e=e.parent;return e}add(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];for(let e of t)e.removeFromParent(),e.parent=this,this.children.push(e);return this}populate(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];if(1===t.length&&"object"==typeof t[0]){let{count:e,...n}=t[0];return this.populate(e,n)}let[i,r]=t;for(let e=0;e<i;e++)this.add(new z(r));return this}addTo(e){return e.add(this),this}prepend(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];for(let e of t)e.removeFromParent(),this.children.unshift(e),e.parent=this;return this}prependTo(e){return e.prepend(this),this}removeFromParent(){return this.parent&&(this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent=null),this}remove(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];for(let e of t)e.parent===this&&e.removeFromParent();return this}sort(e){return this.children.sort(e),this}tangentSize(){var e,t;return(null!=(t=null==(e=this.parent)?void 0:e.direction)?t:this.direction)===h.OP.Horizontal?this.sizeX:this.sizeY}normalSize(){return this.direction===h.OP.Horizontal?this.sizeX:this.sizeY}getUvRect(e){let{out:t=new u.M_,flipY:n}=e;return t.copy(this.rect).relativeTo(this.getRoot().rect),n&&(t.y=1-t.y-t.height),t}parse(e){let t;if(!e)return;let n=/(\w+)(?:\(([^)]+)\))?/g,i=[];for(;null!==(t=n.exec(e));){let e=t[1],n=t[2]?t[2].split(",").map(e=>e.trim()):[];i.push({token:e,args:n})}for(let{token:t,args:n}of i)switch(t){case"horizontal":this.direction=h.OP.Horizontal;break;case"vertical":this.direction=h.OP.Vertical;break;case"size":{let[e,t=e]=n;this.sizeX.parse(e),this.sizeY.parse(t);break}default:throw console.log(e,i),Error('Unknow type: "'.concat(t,'"'))}}computeLayout(){this.isRoot()&&function(e){let{offsetX:t,offsetY:n,sizeX:i,sizeY:r}=e;for(let e of[t,n,i,r])if(e.type!==l.Absolute)throw Error("Root space must have absolute offset and size");e.rect.set(t.value,n.value,i.value,r.value)}(this);let e=[this];for(;e.length>0;){let t=e.shift();!function(e){let{direction:t,alignChildrenX:n,alignChildrenY:i}=e,[r,o]=(0,f.mn)(e.children,e=>+!e.enabled);if(o)for(let e of o)for(let t of e.allDescendants({includeSelf:!0}))t.rect.set(0,0,0,0);if(void 0===r)return;var a,s,c,u,g,y,w=e;let{width:z,height:b}=w.rect;for(let e of w.padding)if(e.type===l.Fraction)throw Error("Share padding is not allowed");p.setTRBL(w.padding[0].compute(b,z),w.padding[1].compute(z,b),w.padding[2].compute(b,z),w.padding[3].compute(z,b));let{x:S,y:A,width:M,height:P}=m.copy(e.rect).shrink(p),C=e.gap.compute(M,P),[R,D,T,L,Y]=r.reduce((e,n)=>{if(n.positioning===h.EU.Detached)e[0].push(n);else{e[1].push(n);let i=t===h.OP.Horizontal?n.sizeX:n.sizeY;i.type!==l.Fraction&&i.type!==l.Auto?e[2].push(n):(e[3].push(n),e[4]+=i.value)}return e},[[],[],[],[],0]);for(;v.length<e.children.length;)v.push(new d.Y);let{width:I,height:X}=e.rect;for(let t=0;t<e.children.length;t++){let n=e.children[t];v[t].setTRBL(n.margin[0].compute(X,I),n.margin[1].compute(I,X),n.margin[2].compute(X,I),n.margin[3].compute(I,X))}let O=Array.from({length:D.length+1}),E=0,F=0;if(t===h.OP.Horizontal){E+=F=Math.max(v[0].left,p.left),O[0]=F;for(let e=1,t=D.length;e<t;e++)E+=F=Math.max(v[e-1].right,v[e].left,C),O[e]=F;D.length>0&&(E+=F=Math.max(v[D.length-1].right,p.right),O[D.length]=F)}else{E+=F=Math.max(v[0].top,p.top),O[0]=F;for(let e=1,t=D.length;e<t;e++)E+=F=Math.max(v[e-1].bottom,v[e].top,C),O[e]=F;D.length>0&&(E+=F=Math.max(v[D.length-1].bottom,p.bottom),O[D.length]=F)}for(let e of R){x(e,M,P,t,v[0]);let r=M-e.rect.width,o=P-e.rect.height;e.rect.x=S+r*(null!=(a=e.alignSelfX)?a:n)+e.offsetX.compute(M,P),e.rect.y=A+o*(null!=(s=e.alignSelfY)?s:i)+e.offsetY.compute(P,M)}let U=0;if(t===h.OP.Horizontal)for(let e=0,n=T.length;e<n;e++){let n=T[e];x(n,M,P,t,v[e]),U+=n.rect.width}else for(let e=0,n=T.length;e<n;e++){let n=T[e];x(n,M,P,t,v[e]),U+=n.rect.height}let _=(t===h.OP.Horizontal?e.rect.width:e.rect.height)-U-E,N=_>0?_/Y:0;if(t===h.OP.Horizontal)for(let e=0,n=L.length;e<n;e++){let n=L[e];x(n,N*n.sizeX.value,P,t,v[e])}else for(let e=0,n=L.length;e<n;e++){let n=L[e];x(n,M,N*n.sizeY.value,t,v[e])}let j=0;if(t===h.OP.Horizontal)for(let t of(j=e.rect.width-E,D))j-=t.rect.width;else for(let t of(j=e.rect.height-E,D))j-=t.rect.height;if(t===h.OP.Horizontal){let t=e.rect.x+O[0]+j*n;for(let e=0,n=D.length;e<n;e++){let n=D[e],r=n.offsetX.compute(n.rect.width,n.rect.height),o=n.offsetY.compute(n.rect.height,n.rect.width);if(n.rect.x=r+t,n.sizeY.type===l.Fraction||n.sizeY.type===l.Auto){let t=Math.max(0,v[e].top-p.top),r=Math.max(0,v[e].bottom-p.bottom);n.rect.y=o+m.y+t+(m.height-n.rect.height-t-r)*(null!=(c=n.alignSelfY)?c:i)}else n.rect.y=o+m.y+(m.height-n.rect.height)*(null!=(u=n.alignSelfY)?u:i);t+=n.rect.width+O[e+1]}}else{let t=e.rect.y+O[0]+j*i;for(let e=0,i=D.length;e<i;e++){let i=D[e],r=i.offsetX.compute(i.rect.width,i.rect.height),o=i.offsetY.compute(i.rect.height,i.rect.width);if(i.sizeX.type===l.Fraction||i.sizeX.type===l.Auto){let t=Math.max(0,v[e].left-p.left),o=Math.max(0,v[e].right-p.right);i.rect.x=r+m.x+t+(m.width-i.rect.width-t-o)*(null!=(g=i.alignSelfX)?g:n)}else i.rect.x=r+m.x+(m.width-i.rect.width)*(null!=(y=i.alignSelfX)?y:n);i.rect.y=o+t,t+=i.rect.height+O[e+1]}}}(t),e.push(...t.children)}return this}get root(){throw Error("Space.root is deprecated. Use Space.getRoot() instead.")}constructor(e){this.enabled=!0,this.name="",this.parent=null,this.children=[],this.direction=h.OP.Horizontal,this.positioning=h.EU.Flow,this.aspect=null,this.offsetX=new s(0,l.Absolute),this.offsetY=new s(0,l.Absolute),this.sizeX=new s(1,l.Auto),this.sizeY=new s(1,l.Auto),this.extraSizeX=new s(1,l.Relative),this.extraSizeY=new s(1,l.Relative),this.padding=[new s(0,l.Absolute),new s(0,l.Absolute),new s(0,l.Absolute),new s(0,l.Absolute)],this.margin=[new s(0,l.Absolute),new s(0,l.Absolute),new s(0,l.Absolute),new s(0,l.Absolute)],this.gap=new s(0,l.Absolute),this.alignChildrenX=.5,this.alignChildrenY=.5,this.alignSelfX=null,this.alignSelfY=null,this.rect=new u.M_,this.userData={},e&&("object"==typeof e?this.set(e):this.direction=e)}}},43107:(e,t,n)=>{"use strict";function i(e,t){for(let n of e)if(t(n))return!0;return!1}function r(e,t){for(let n of e)if(!t(n))return!1;return!0}function o(e,t,n){let i=[];function r(e){let t=[];return i[e]=t,t}if(void 0!==n)for(let e=0;e<n;e++)r(e);for(let n of e){var o;let e=t(n);(null!=(o=i[e])?o:r(e)).push(n)}return i}function*a(e){let t;for(let n of e)void 0!==t&&(yield[t,n]),t=n}function s(e,t){let n,i=-1/0;for(let r of e){let e=t(r);e>i&&(i=e,n=r)}return n}function l(e){let t=new Set;return n=>{let i=e(n);return!t.has(i)&&(t.add(i),!0)}}function c(e){return(t,n)=>{if(null!==t&&"object"!=typeof t)throw Error("Accumulator must be an object");let i=null===t?{}:t,r=e(n);return i[r]||(i[r]=[]),i[r].push(n),i}}n.d(t,{Ju:()=>a,Si:()=>r,VY:()=>c,mn:()=>o,pD:()=>l,vj:()=>s,zN:()=>i})},45553:(e,t,n)=>{"use strict";n.d(t,{z:()=>l});var i=n(49797);let r=new i.Pq0,o=new i.Pq0,a=new i.Pq0,s=new i.Pq0;function l(e,t,n){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:s;a.crossVectors(e,t),1e-6>a.lengthSq()&&(a.set(1,0,0).cross(e),1e-6>a.lengthSq()&&a.set(0,1,0).cross(e));let l=e.length(),c=t.length();r.copy(e).divideScalar(l),o.copy(t).divideScalar(c);let u=Math.acos(Math.min(Math.max(r.dot(o),-1),1));if(1e-6>Math.abs(u))i.lerpVectors(e,t,n);else{a.normalize();let e=u*n,t=Math.cos(e),s=Math.sin(e);i.copy(r).multiplyScalar(t).addScaledVector(o.copy(a).cross(r),s).multiplyScalar((1-n)*l+n*c)}return i}},55227:(e,t,n)=>{"use strict";n.d(t,{M:()=>a});var i=n(22899),r=n(1029);let o="\n\nstruct FloatRamp {\n  float a;\n  float b;\n  float t;\n};\n\nstruct Vec2Ramp {\n  vec2 a;\n  vec2 b;\n  float t;\n};\n\nstruct Vec3Ramp {\n  vec3 a;\n  vec3 b;\n  float t;\n};\n\nstruct Vec4Ramp {\n  vec4 a;\n  vec4 b;\n  float t;\n};\n\n".concat((0,r.N)("vecX",e=>{let t=e[0].toUpperCase()+e.slice(1)+"Ramp";return"\n\n// 1 stop (simple linear interpolation)\n".concat(t," ramp(float t, T a, T b) {\n  return ").concat(t,"(a, b, t);\n}\n\n// 2 stops\n").concat(t," ramp(float t, T a, T b, T c) {\n  if (t < 0.5) {\n    return ").concat(t,"(a, b, t * 2.0);\n  } else {\n    return ").concat(t,"(b, c, t * 2.0 - 1.0);\n  }\n}\n\n// 4 stops\n").concat(t," ramp(float t, T a, T b, T c, T d) {\n  if (t < 0.333) {\n    return ").concat(t,"(a, b, t * 3.0);\n  } else if (t < 0.666) {\n    return ").concat(t,"(b, c, t * 3.0 - 1.0);\n  } else {\n    return ").concat(t,"(c, d, t * 3.0 - 2.0);\n  }\n}\n\n// 5 stops\n").concat(t," ramp(float t, T a, T b, T c, T d, T e) {\n  if (t < 0.25) {\n    return ").concat(t,"(a, b, t * 4.0);\n  } else if (t < 0.5) {\n    return ").concat(t,"(b, c, t * 4.0 - 1.0);\n  } else if (t < 0.75) {\n    return ").concat(t,"(c, d, t * 4.0 - 2.0);\n  } else {\n    return ").concat(t,"(d, e, t * 4.0 - 3.0);\n  }\n}\n\n").slice(1,-1)})),a="\n#ifndef GLSL_RAMP\n#define GLSL_RAMP\n".concat(i.I,"\n").concat(o,"\n#endif\n")},56002:(e,t,n)=>{"use strict";n.d(t,{p:()=>i});let i='\n  // sizeMode: 0 for "contain", 1 for "cover"\n  vec2 applyUvSize(vec2 uv, float outerAspect, float innerAspect, float sizeMode, vec2 align, vec2 scale) {\n    align.y = 1.0 - align.y; // Flip y-coordinate\n    if ((outerAspect > innerAspect) != (sizeMode == 1.0)) { // XOR condition for mode\n      float scaleFactor = outerAspect / innerAspect;\n      uv.x = (uv.x - align.x) * scaleFactor + align.x; // Adjust x-coordinate\n    } else {\n      float scaleFactor = innerAspect / outerAspect;\n      uv.y = (uv.y - align.y) * scaleFactor + align.y; // Adjust y-coordinate\n    }\n    uv = (uv - align) / scale + align;\n    return uv;\n  }\n\n  vec2 applyUvSize(vec2 uv, float outerAspect, float innerAspect, float sizeMode, vec2 align, float scale) {\n    return applyUvSize(uv, outerAspect, innerAspect, sizeMode, align, vec2(scale));\n  }\n\n  vec2 applyUvSize(vec2 uv, float outerAspect, float innerAspect, float sizeMode, vec2 align) {\n    return applyUvSize(uv, outerAspect, innerAspect, sizeMode, align, vec2(1.0));\n  }\n\n  vec2 applyUvSize(vec2 uv, float outerAspect, float innerAspect, float sizeMode) {\n    return applyUvSize(uv, outerAspect, innerAspect, sizeMode, vec2(0.5));\n  }\n\n  vec2 applyUvSize(vec2 uv, float outerAspect, float innerAspect) {\n    return applyUvSize(uv, outerAspect, innerAspect, 1.0);\n  }\n'},56905:(e,t,n)=>{"use strict";var i,r,o;function a(e){if(e in o)return e;if("string"==typeof e)return"flow"===e?o.Flow:o.Detached;throw Error("Invalid positioning value: ".concat(e))}function s(e){if(e in r)return e;if("string"==typeof e)return"horizontal"===e?r.Horizontal:r.Vertical;throw Error("Invalid direction value: ".concat(e))}n.d(t,{$P:()=>a,EU:()=>o,OP:()=>r,T$:()=>s}),function(e){e[e.Flow=0]="Flow",e[e.Detached=1]="Detached",e[e.Horizontal=2]="Horizontal",e[e.Vertical=3]="Vertical"}(i||(i={})),function(e){e[e.Horizontal=2]="Horizontal",e[e.Vertical=3]="Vertical"}(r||(r={})),function(e){e[e.Flow=0]="Flow",e[e.Detached=1]="Detached"}(o||(o={}))},66620:(e,t,n)=>{"use strict";n.d(t,{_:()=>o});var i=n(89868),r=n(44138);function o(e,t){var n=(0,r._)(e,t,"update");return(0,i._)(e,n)}},69626:(e,t,n)=>{Promise.resolve().then(n.bind(n,36398)),Promise.resolve().then(n.bind(n,25027)),Promise.resolve().then(n.t.bind(n,92439,23)),Promise.resolve().then(n.bind(n,26584)),Promise.resolve().then(n.bind(n,87548)),Promise.resolve().then(n.bind(n,42436)),Promise.resolve().then(n.bind(n,18479))},79105:(e,t,n)=>{"use strict";n.d(t,{K2:()=>a,KP:()=>r,Tj:()=>s,Ts:()=>o,Zu:()=>i});let i=0x7fffffff,r=123456,o=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r;if(Number.isNaN(e))throw Error("NaN is not a valid seed.");let t=e;if(10>Math.abs(t)&&(t*=1e6),t%=i,(t=t<0?t+i:t)>1)return t&i;if(0===t)return r;throw Error("Impossible. ".concat(t))},a=e=>e=Math.imul(e,48271)&i,s=e=>(e-1)/(i-1)},80446:(e,t,n)=>{"use strict";n.d(t,{n:()=>r});var i=n(79105);let r=function e(){let t=Math.random,n=()=>{};function r(e){let t=0;for(let n=0;n<e.length;n++)t=(t<<5)-t+e.charCodeAt(n)|0;return t}function o(){for(var e=arguments.length,n=Array(e),i=0;i<e;i++)n[i]=arguments[i];if(0===n.length)return t();if(1===n.length)return t()*n[0];if(2===n.length)return t()*(n[1]-n[0])+n[0];throw Error("Invalid arguments")}function a(){for(var e=arguments.length,n=Array(e),i=0;i<e;i++)n[i]=arguments[i];if(1===n.length)return Math.floor(t()*n[0]);if(2===n.length)return Math.floor(t()*(n[1]-n[0]))+n[0];throw Error("Invalid arguments")}function s(e){let{weightsAreNormalized:n=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(0===e.length)throw Error("Weights array is empty");if(!1===n){let n=e.reduce((e,t)=>e+t,0),i=t()*n,r=0;for(let t=0;t<e.length;t++)if(i<(r+=e[t]))return t;return e.length-1}{let n=t(),i=0;for(let t=0;t<e.length;t++)if(n<(i+=e[t]))return t;return e.length-1}}let l={new:function(){for(var t=arguments.length,n=Array(t),i=0;i<t;i++)n[i]=arguments[i];return e().setRandom(...n)},setRandom:function(){for(var e=arguments.length,o=Array(e),a=0;a<e;a++)o[a]=arguments[a];let[s,c=0]=o,u="string"==typeof c?r(c):c;if("parkmiller"===s){let e=i.Ts(u);t=()=>(e=i.K2(e),i.Tj(e)),n=t=>{e=i.Ts(t)}}else{if(void 0!==s&&"function"!=typeof s)throw Error("Invalid random function");t=null!=s?s:Math.random,n=()=>{}}return n(u),l},seed:function(e){return n("string"==typeof e?r(e):null!=e?e:0),l},get random(){return t},chance:function(e){return t()<e},number:o,float:o,f:o,sign:function(){return .5>t()?-1:1},int:a,i:a,hexColor:function(){let e=Math.floor(0xffffff*t());return"#".concat(e.toString(16).padStart(6,"0"))},pickIndex:s,pick:function(e,n){if(0===e.length)throw Error("Array is empty");if(n)return e[s(n)];let i=Math.floor(t()*e.length);return e[i]},createPicker:function(e){let t=e.map(e=>e[0]),n=e.map(e=>e[1]),i=t.reduce((e,t)=>e+t,0);for(let e=0;e<t.length;e++)t[e]/=i;return()=>n[s(t,{weightsAreNormalized:!0})]},direction2:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{x:0,y:0},n=t()*Math.PI*2;return e.x=Math.cos(n),e.y=Math.sin(n),e},direction3:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{x:0,y:0,z:0},n=t(),i=t(),r=2*Math.PI*n,o=Math.acos(1-2*i);return e.x=Math.sin(o)*Math.cos(r),e.y=Math.sin(o)*Math.sin(r),e.z=Math.cos(o),e},quaternion:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{x:0,y:0,z:0,w:1},n=t(),i=t(),r=t(),o=Math.sqrt(1-n),a=Math.sqrt(n);return e.x=o*Math.sin(2*Math.PI*i),e.y=o*Math.cos(2*Math.PI*i),e.z=a*Math.sin(2*Math.PI*r),e.w=a*Math.cos(2*Math.PI*r),e},shuffleIndexes:function*(e){if(e<=0)throw Error("N must be greater than 0");let n=0,i=Math.floor((2+2*t())*e);for(;1!==function(e,t){for(;0!==t;)[e,t]=[t,e%t];return e}(e,i);){if(++n>1e3)throw Error("Failed to find a suitable a value after 1000 attempts");i=e+Math.floor(t()*e)}let r=Math.floor(t()*e);for(let t=0;t<e;t++)yield(r+t*i)%e}};return l}()},92439:()=>{}},e=>{var t=t=>e(e.s=t);e.O(0,[5662,5611,7190,6564,7962,9635,8921,7953,4512,7775,7436,4842,146,6726,3445,9332,3414,9717,1763,2143,3540,3565,1319,6852,7358],()=>t(69626)),_N_E=e.O()}]);