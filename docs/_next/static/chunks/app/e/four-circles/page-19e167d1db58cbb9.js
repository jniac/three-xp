(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[8091],{1029:(n,e,t)=>{"use strict";t.d(e,{N:()=>o});let r={vecX:["float","vec2","vec3","vec4"]},o=(n,e)=>{let t=[],o=Array.isArray(n)?n:[n].map(n=>n in r?r[n]:n).flat();if("function"==typeof e)for(let n of o)t.push(e(n).replaceAll(/\bT\b/g,n));else for(let n of o)t.push(e.replaceAll(/\bT\b/g,n));return t.join("\n")}},8144:(n,e,t)=>{"use strict";t.d(e,{H:()=>a});var r=t(65927),o=t(1029);let a="\n".concat(r.S,"\n\n#ifndef GLSL_UTILS\n#define GLSL_UTILS\n\nfloat sin01(float x) {\n  return 0.5 + 0.5 * sin(x * 6.283185307179586);\n}\n\nvec2 scaleAround(vec2 p, vec2 c, float s) {\n  return c + (p - c) / s;\n}\n\n// Same as mix, but clamped.\n").concat((0,o.N)("vecX","\n  T lerp(in T a, in T b, in float x) {\n    return mix(a, b, clamp01(x));\n  }\n"),"\n\nfloat inverseLerpUnclamped(in float a, in float b, float x) {\n  return (x - a) / (b - a);\n}\n\nfloat inverseLerp(in float a, in float b, float x) {\n  return clamp01((x - a) / (b - a));\n}\n\nfloat remap(in float x, in float a, in float b, in float c, in float d) {\n  return c + (d - c) * inverseLerp(a, b, x);\n}\n\n// Remap from [-1, 1] to [0, 1]\nfloat remap1101(in float x) {\n  return clamp01(0.5 + 0.5 * x);\n}\n\n").concat((0,o.N)("vecX","\n  T oneMinus(in T x) {\n    return 1.0 - x;\n  }\n"),"\n\n// Returns x^p, but handles negative x values correctly.\nfloat spow(in float x, in float p) {\n  return x >= 0.0 ? pow(x, p) : -pow(-x, p);\n}\n\nfloat threshold(in float x, in float thresholdValue) {\n  return x < thresholdValue ? 0. : 1.;\n}\n\nfloat threshold(in float x, in float thresholdValue, in float width) {\n  return width < 1e-9 \n    ? (x < thresholdValue ? 0. : 1.)\n    : clamp01((x - thresholdValue + width * .5) / width);\n}\n\nmat3 extractRotation(mat4 matrix) {\n  return mat3(matrix[0].xyz, matrix[1].xyz, matrix[2].xyz);\n}\n\nvec2 rotate(vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  float x = c * p.x + s * p.y;\n  float y = -s * p.x + c * p.y;\n  return vec2(x, y);\n}\n\nvec2 rotateAround(vec2 p, float a, vec2 c) {\n  return c + rotate(p - c, a);\n}\n\nvec2 rotateScaleAround(vec2 p, float a, float s, vec2 c) {\n  return c + rotate((p - c) / s, a);\n}\n\nfloat positiveModulo(float x) {\n  x = mod(x, 1.0);\n  return x < 0.0 ? x + 1.0 : x;\n}\n\n// Modulo that keeps the result in the range [0, modulo]\nfloat positiveModulo(float x, float modulo) {\n  x = mod(x, modulo);\n  return x < 0.0 ? x + modulo : x;\n}\n\n// Modulo that keeps the result in the range [-m/2, m/2]\nfloat middleModulo(float x, float modulo) {\n  x = mod(x, modulo);\n  return x < -modulo / 2.0 ? x + modulo : x > modulo / 2.0 ? x - modulo : x;\n}\n\n// Limit a value to a maximum that the function tends to reach when x -> ∞\n// https://www.desmos.com/calculator/0vewkbnscu\nfloat limited(float x, float maxValue) {\n  return x <= 0.0 ? x : maxValue * x / (maxValue + x);\n}\n\n// Symmetric version of limited\n// \n// Limit a value to a maximum that the function tends to reach when x -> ∞\n// and a minimum (-maximum) that the function tends to reach when x -> -∞\n// https://www.desmos.com/calculator/0vewkbnscu\nfloat slimited(float x, float maxValue) {\n  return x <= 0.0\n    ? -limited(-x, maxValue)\n    : limited(x, maxValue);\n}\n\n// https://www.desmos.com/calculator/0vewkbnscu\nfloat limited(float x, float minValue, float maxValue) {\n  float d = maxValue - minValue;\n  float xd = x - minValue;\n  return x <= minValue ? x : minValue + d * xd / (d + xd);\n}\n\n// Symmetric version of limited\nfloat slimited(float x, float minValue, float maxValue) {\n  return x <= 0.0\n    ? -limited(-x, maxValue, minValue)\n    : limited(x, minValue, maxValue);\n}\n\nfloat sqLength(in vec2 p) {\n  return p.x * p.x + p.y * p.y;\n}\n\nfloat sqLength(in vec3 p) {\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\nfloat pcurve(float x, float a, float b) {\n  float k = pow(a + b, a + b) / (pow(a, a) * pow(b, b));\n  return k * pow(x, a) * pow(1.0 - x, b);\n}\n\nfloat hash(float p) {\n  return fract(sin(p * 12.9898) * 43758.5453);\n}\n\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat hash(vec3 p) {\n  return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n}\n\nfloat hash(vec4 p) {\n  return fract(sin(dot(p, vec4(12.9898, 78.233, 45.164, 94.673))) * 43758.5453);\n}\n\nvec2 hash2(float p) {\n  return vec2(hash(p), hash(p + 1.0));\n}\n\nvec2 hash2(vec2 p) {\n  return vec2(hash(p.x), hash(p.y));\n}\n\nvec2 hash2(vec3 p) {\n  return vec2(hash(p.xy), hash(p.yz));\n}\n\nvec2 hash2(vec4 p) {\n  return vec2(hash(p.xyz), hash(p.yzw));\n}\n\nvec3 hash3(float p) {\n  return vec3(hash2(p),  hash(p + 2.0));\n}\n\nvec3 hash3(vec2 p) {\n  return vec3(hash2(p), hash(p));\n}\n\nvec3 hash3(vec3 p) {\n  return vec3(hash(p.x), hash(p.y), hash(p.z));\n}\n\nvec3 hash3(vec4 p) {\n  return vec3(hash(p.xy), hash(p.yz), hash(p.zw));\n}\n\nfloat hash_alt(float p) {\n  return fract(sin(p * 127.1) * 311.7);\n}\n\nfloat hash_alt(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 269.5);\n}\n\nfloat hash_alt(vec3 p) {\n  return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 269.5);\n}\n\nfloat hash_alt(vec4 p) {\n  return fract(sin(dot(p, vec4(127.1, 311.7, 74.7, 113.5))) * 269.5);\n}\n\n").concat((0,o.N)("vecX","\n  T min3(in T a, in T b, in T c) {\n    return min(min(a, b), c);\n  }\n"),"\n\n").concat((0,o.N)("vecX","\n  T min4(in T a, in T b, in T c, in T d) {\n    return min(min(a, b), min(c, d));\n  }\n"),"\n\n#endif // GLSL_UTILS\n")},14203:(n,e,t)=>{"use strict";t.d(e,{O:()=>o});var r=t(1029);let o="\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; \n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat permute(float x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nfloat taylorInvSqrt(float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\n\n\n\n\n// 2D:\n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n		+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// 3D: \n\nfloat snoise(vec3 v)\n{ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\n\n// 4D:\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n						\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v) {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n  // First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n  // Other corners\n\n  // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n  //  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n  //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n  // Permutations\n  i = mod289(i); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n  // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n  // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n  // Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n  // Mix contributions from the five corners\n  vec3 m0 = max(0.57 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.57 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 60.1 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\n\n\n\n// addons:\n// Fractal noise, based on Stefan Gustavson's Simplex noise\n".concat((0,r.N)(["vec2","vec3","vec4"],"\n  float fnoise(T p, int octaves, float persistence) {\n    float total = 0.0;           // Final noise value\n    float amplitude = 1.0;       // Initial amplitude\n    float frequency = 1.0;       // Initial frequency\n    float maxValue = 0.0;        // Used for normalization\n\n    for (int i = 0; i < octaves; i++) {\n      total += snoise(p * frequency) * amplitude;\n\n      maxValue += amplitude;   // Keep track of max amplitude\n      amplitude *= persistence; // Reduce amplitude for next octave\n      frequency *= 2.0;        // Increase frequency for next octave\n    }\n\n    // Normalize the result to stay within the range [0, 1]\n    return total / maxValue;\n  }\n\n  float fnoise(T p, int octaves) {\n    return fnoise(p, octaves, 0.5);\n  }\n\n  float fnoise(T p) {\n    return fnoise(p, 4, 0.5);\n  }\n"),"\n\nfloat snoiseFast4D(vec4 p) {\n  const float SCALAR = 0.01;\n  float a = SCALAR * dot(p.xy * 0.3, vec2(-127.1, 311.7));\n  float b = SCALAR * dot(p.zw * 0.8, vec2(269.5, -183.3));\n  float c = SCALAR * dot(p.wx * 6.0, vec2(23.14069, 2.665157));\n  float d = SCALAR * dot(p.zy * 1.3, vec2(-12.9898, 78.233));\n  return (snoise(vec2(a, b)) + snoise(vec2(d, c))) * 0.5;\n}\n\nfloat fnoiseFast4D(vec4 p, int octaves, float persistence) {\n  float total = 0.0;           // Final noise value\n  float amplitude = 1.0;       // Initial amplitude\n  float frequency = 1.0;       // Initial frequency\n  float maxValue = 0.0;        // Used for normalization\n\n  for (int i = 0; i < octaves; i++) {\n    total += snoiseFast4D(p * frequency) * amplitude;\n\n    maxValue += amplitude;   // Keep track of max amplitude\n    amplitude *= persistence; // Reduce amplitude for next octave\n    frequency *= 2.0;        // Increase frequency for next octave\n  }\n\n  // Normalize the result to stay within the range [0, 1]\n  return total / maxValue;\n}\n")},14277:(n,e,t)=>{"use strict";t.d(e,{D:()=>o});var r=t(67203);function o(){let[n,e]=(0,r.useState)(!1);return(0,r.useLayoutEffect)(()=>{e(!0)},[]),n}},17099:(n,e,t)=>{"use strict";t.d(e,{c:()=>l});var r=t(79105);let o=n=>n,a={weightsAreNormalized:!1,indexOffset:0,forbiddenItems:[]};function i(){let n=(0,r.K2)((0,r.K2)((0,r.Ts)(r.KP)));function e(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r.KP;return"string"==typeof e&&(e=e.split("").reduce((n,e)=>7*n+e.charCodeAt(0),0)),n=(0,r.K2)((0,r.K2)((0,r.Ts)(e))),u}function t(){return n=(0,r.K2)(n),(0,r.Tj)(n)}function i(n){switch(n.length){default:return[0,1,o];case 1:return[0,n[0],o];case 2:return[n[0],n[1],o];case 3:return[n[0],n[1],n[2]]}}function l(){for(var n=arguments.length,e=Array(n),r=0;r<n;r++)e[r]=arguments[r];let[o,a,l]=i(e);return o+(a-o)*l(t())}function s(){for(var n,e=arguments.length,r=Array(e),o=0;o<e;o++)r[o]=arguments[o];let[i,l,{weightsAreNormalized:s,indexOffset:c,forbiddenItems:u}]=function(n){let[e,t=null,r]=n,o={...a,...r};if(Array.isArray(e))return[e,t,o];if("object"==typeof e)return[Object.values(e),t?Object.values(t):null,o];throw Error("pick: unsupported options type")}(r);if(u.length>0){let e=new Set;for(let n of u){let t=i.indexOf(n);t>=0&&e.add(t)}if(i=i.filter((n,t)=>!e.has(t)),l=null!=(n=null==l?void 0:l.filter((n,t)=>!e.has(t)))?n:null,0===i.length)throw Error("pick: all items are forbidden")}if(null===l){let n=Math.floor(t()*i.length);return c&&(n+=c,(n%=i.length)<0&&(n+=i.length)),i[n]}if(!s){let n=l.reduce((n,e)=>n+e,0);l=l.map(e=>e/n)}let x=t(),f=0;for(let n=0;n<i.length;n++)if(x<(f+=l[n]))return i[n];throw Error("among: unreachable")}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,r=t(),o=t(),a=Math.sqrt(-2*Math.log(r)),i=2*Math.PI*o;return[n+e*a*Math.cos(i),n+e*a*Math.sin(i)]}let u={seed:e,seedMax:function(){return r.Zu},reset:function(){return e(r.KP),u},next:function(){return n=(0,r.K2)(n),u},getState:function(){return n},setState:function(e){return n=e&r.Zu,u},random:t,between:l,around:function(){for(var n=arguments.length,e=Array(n),r=0;r<n;r++)e[r]=arguments[r];let[a=1,i=o]=e,l=2*t();return(l>1?1:-1)*i(l>1?l-1:l)*a},int:function(){for(var n=arguments.length,e=Array(n),r=0;r<n;r++)e[r]=arguments[r];let[o,a,l]=i(e);return o+Math.floor(l(t())*(a-o))},chance:function(n){return t()<n},shuffle:function(n){let{mutate:e=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=e&&Array.isArray(n)?n:[...n],o=r.length;for(let n=0;n<o;n++){let e=Math.floor(o*t()),a=r[n];r[n]=r[e],r[e]=a}return r},pick:s,createPicker:function(n){let e=n.map(n=>{let[e]=n;return e}),t=n.map(n=>{let[e,t]=n;return t}),r=t.reduce((n,e)=>n+e,0);for(let[n,e]of t.entries())t[n]=e/r;return()=>s(e,t,{weightsAreNormalized:!0})},vector:function(n,e){let[t=0,r=1]=Array.isArray(e)?e:[null==e?void 0:e.min,null==e?void 0:e.max];for(let e of Object.keys(n))n[e]=l(t,r);return n},unitVector2:function(n){let e=2*Math.PI*t();return n.x=Math.cos(e),n.y=Math.sin(e),n},unitVector3:function(n){let e=t(),r=t(),o=2*Math.PI*e,a=Math.acos(1-2*r);return n.x=Math.sin(a)*Math.cos(o),n.y=Math.sin(a)*Math.sin(o),n.z=Math.cos(a),n},normalVector:function(n){let e=Object.keys(n),t=e.length,r=Math.sqrt(t);for(let o=0;o<t;o+=2){let[a,i]=c();n[e[o]]=a/r,o+1<t&&(n[e[o+1]]=i/r)}return n},unitVector:function(n){let e=Object.keys(n),t=e.length,r=0;for(let o=0;o<t;o+=2){let[a,i]=c();n[e[o]]=a,r+=a*a,o+1<t&&(n[e[o+1]]=i,r+=i*i)}r=Math.sqrt(r);for(let o=0;o<t;o++)n[e[o]]/=r;return n},boxMuller:c,quaternion:function(n){let e=t(),r=t(),o=t(),a=Math.sqrt(1-e),i=Math.sqrt(e);return n.x=a*Math.sin(2*Math.PI*r),n.y=a*Math.cos(2*Math.PI*r),n.z=i*Math.sin(2*Math.PI*o),n.w=i*Math.cos(2*Math.PI*o),n},insideCircle:function(n,e){let r=2*t()*Math.PI,o=Math.sqrt(t())*n;return e.x=o*Math.cos(r),e.y=o*Math.sin(r),e}};return u}let l=class{constructor(n){Object.assign(this,i().seed(n))}};Object.assign(l,i())},21277:(n,e,t)=>{"use strict";t.d(e,{N:()=>a});var r=t(49797);let o=new r.WBB(1,4);class a extends r.eaF{constructor(n){super(o,new r.V9B({color:"#0c529d",...n,side:r.hsX,depthWrite:!1,depthTest:!1})),this.renderOrder=-1,this.frustumCulled=!1,this.matrixAutoUpdate=!1,this.onBeforeRender=(n,e,t)=>{let r=(t.near+t.far)/2;this.position.copy(t.position),this.scale.setScalar(r),this.updateMatrix(),this.updateMatrixWorld()}}}},22899:(n,e,t)=>{"use strict";t.d(e,{I:()=>a});var r=t(65927);let o=["linear"];for(let n=1;n<=10;n++)o.push("easeIn".concat(n)),o.push("easeOut".concat(n)),o.push("easeInOut".concat(n)),o.push("easeOutIn".concat(n));let a="\n#ifndef GLSL_EASING\n#define GLSL_EASING\n\n".concat(r.S,"\n\nfloat easePow1(float x) {\n  return x;\n}\n\nfloat easePow2(float x) {\n  return x * x;\n}\n\nfloat easePow3(float x) {\n  return x * x * x;\n}\n\nfloat easePow4(float x) {\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow5(float x) {\n  float x0 = x;\n  x *= x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow6(float x) {\n  x *= x * x;\n  return x *= x;\n}\n\nfloat easePow7(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow8(float x) {\n  x *= x;\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow9(float x) {\n  x *= x * x;\n  return x *= x * x;\n}\n\nfloat easePow10(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x * x;\n  return x0 * x;\n}\n\nfloat linear(float x) {\n  return clamp01(x);\n}\n\n").concat(Array.from({length:10},(n,e)=>{let t=e+1;return"\n\n  float easeIn".concat(t," (float x) {\n    return easePow").concat(t,"(clamp01(x));\n  }\n  float easeOut").concat(t," (float x) {\n    return 1.0 - easePow").concat(t,"(clamp01(1.0 - x));\n  }\n  float easeInOut").concat(t," (float x) {\n    return x < 0.5 \n      ? 0.5 * easePow").concat(t,"(2.0 * x) \n      : 1.0 - 0.5 * easePow").concat(t,"(2.0 * (1.0 - x));\n  }\n  float easeOutIn").concat(t," (float x) {\n    return x < 0.5\n      ? 0.5 * (1.0 - easePow").concat(t,"(1.0 - x * 2.0))\n      : 1.0 - 0.5 * (1.0 - easePow").concat(t,"(2.0 * x - 1.0));\n  }\n\n").trim()}).join("\n\n"),"\n\n\n// https://www.desmos.com/calculator/mqou4lf9zc?lang=fr\nfloat easeInOut(float x, float p, float i) {\n  return  x <= 0.0 ? 0.0 :\n          x >= 1.0 ? 1.0 :\n          x <= i ? 1.0 / pow(i, p - 1.0) * pow(x, p) :\n          1.0 - 1.0 / pow(1.0 - i, p - 1.0) * pow(1.0 - x, p);\n}\n\n// https://www.desmos.com/calculator/nrjlezusdv\nfloat easeInThenOut(float x, float p) {\n  return 1.0 - pow(abs(2.0 * x - 1.0), p);\n}\n\n#endif\n")},23200:(n,e,t)=>{"use strict";t.d(e,{Main:()=>A});var r=t(70691),o=t(31763),a=t(36508),i=t(33855),l=t(28737),s=t(63106),c=t(49797),u=t(21277),x=t(79911),f=t(72612),p=t(6726),d=t(3293);class m extends c.YJl{clear(){let{lines:n}=this.parts;return n.count=0,n.instanceMatrix.array=new Float32Array(0),n.instanceMatrix.needsUpdate=!0,this}moveTo(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];let[r,o]=1===e.length?[e[0].x,e[0].y]:e;return this.commands.push({type:"moveTo",x:r,y:o,z:0,w:1}),this}lineTo(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];let[r,o]=1===e.length?[e[0].x,e[0].y]:e;return this.commands.push({type:"lineTo",x:r,y:o,z:0,w:1}),this}draw(){let{lines:n}=this.parts,{thickness:e,commands:t}=this,r=new Float32Array(16*t.length),o=0;for(let[n,{type:a,x:i,y:l}]of t.entries())if("lineTo"===a){let a=t[n-1],s=i-a.x,c=l-a.y,u=a.x+s/2,x=a.y+c/2,f=Math.sqrt(s*s+c*c),p=Math.atan2(c,s);(0,d.w)({x:u,y:x,rotationZ:p,scaleX:f,scaleY:e}).toArray(r,16*o),o++}return n.count=o,n.instanceMatrix.array=r.slice(0,16*o),n.instanceMatrix.needsUpdate=!0,this}constructor(...n){super(...n),this.thickness=.01,this.parts=(()=>{let n=new c.bdM(1,1),e=new c.V9B;return{lines:(0,x.mj)(new c.ZLX(n,e,0),this)}})(),this.commands=[]}}var v=t(7147),h=t(22899),y=t(14203),w=t(8144);let g=new c.bdM(4,4);new c.WBB(1,12);class b extends c.YJl{constructor(...n){super(...n),this.parts=(()=>{let n=["#95c3fb","#fcff99","#0a1521"].map(n=>new c.Q1f(n)),e=new c.V9B,t={uTime:a.Rv.get("three").uTime,uTimeCycleOffset:{value:0},uColors:{value:n}};e.onBeforeCompile=n=>v.bI.with(n).uniforms(t).defines({USE_UV:""}).varying({vWorldPosition2:"vec3"}).vertex.mainAfterAll("\n        vWorldPosition2 = (modelMatrix * vec4(position, 1.0)).xyz;\n      ").fragment.top("\n\n  // Inigo Quilez\n  // https://iquilezles.org/articles/distfunctions2d/\n\n  // Circle - exact   (https://www.shadertoy.com/view/3ltSW2)\n  float sdCircle( vec2 p, float r )\n  {\n    return length(p) - r;\n  }\n\n  // Rounded Box - exact   (https://www.shadertoy.com/view/4llXD7 and https://www.youtube.com/watch?v=s5NGeUV2EyU)\n  float sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n  {\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n  }\n\n  // Box - exact   (https://www.youtube.com/watch?v=62-pRVZuS5c)\n  float sdBox( in vec2 p, in vec2 b )\n  {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n  }\n\n  // Segment - exact   (https://www.shadertoy.com/view/3tdSDj and https://www.youtube.com/watch?v=PMltMdi1Wzg)\n  float sdSegment( in vec2 p, in vec2 a, in vec2 b )\n  {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n  }\n\n  // Arc - exact   (https://www.shadertoy.com/view/wl23RK)\n  float sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n  {\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n  }\n\n  float sdRing( in vec2 p, in vec2 n, in float r, in float th )\n  {\n    p.x = abs(p.x);\n    p = mat2(n.x,n.y,-n.y,n.x)*p;\n    return max( abs(length(p)-r)-th*0.5,\n                length(vec2(p.x,max(0.0,abs(r-p.y)-th*0.5)))*sign(p.x) );\n  }\n\n  float opRound( in float d, in float r )\n  {\n    return d - r;\n  }\n\n  float opOnion( in float d, in float r )\n  {\n    return abs(d) - r;\n  }\n",y.O,w.H,h.I).fragment.top("\n        float globalNoise;\n        void computeGlobalNoise() {\n          globalNoise = fnoise(vec3(vWorldPosition2.xy * 0.5, uTime * 0.01), 8, 0.8);\n        }\n        float radius() {\n          return 0.75;\n        }\n        vec2 point() {\n          return (vUv - 0.5) * 2.0;\n        }\n        float time() {\n          return uTime * 0.05 + uTimeCycleOffset * 1.0;\n        }\n        float noisyBox() {\n          return sdBox(point(), vec2(radius())) + globalNoise * 0.1 * sin01(time());\n        }\n        float noisyCircle() {\n          return length(point()) - radius() + globalNoise * 0.3 * sin01(time());\n        }\n      ").fragment.mainBeforeAll("\n        computeGlobalNoise();\n      ").fragment.after("color_fragment","\n        float d = sdBox(point(), vec2(radius()));\n        float d2 = sin01(time());\n        d2 *= 0.1;\n        vec3 color = mix(uColors[0], uColors[1], smoothstep(0.001, 0.0, noisyBox()));\n\n        float nc = noisyCircle();\n        vec3 circleColor = mix(uColors[1], uColors[2], mix(0.25, 1.0, easeInOut2(inverseLerpUnclamped(-radius(), 0.0, nc))));\n        color = mix(color, circleColor, smoothstep(0.001, 0.0, nc));\n        diffuseColor.rgb = color;\n      ");let r=new c.eaF(g,e);return this.add(r),{plane:r,planeUniforms:t,colors:n}})()}}class z extends c.YJl{constructor(...n){super(...n),this.parts=(()=>{let n=(0,x.mj)(new m,this);n.position.z=1,n.thickness=.0125,n.parts.lines.material.color.set("#15093e"),n.parts.lines.material.color.set("#95c3fb");let e=new p.M_(0,0).applyPadding(4.1+.05,"grow"),t=new p.M_(0,0).applyPadding(6.25,"grow");for(let{t:r}of(0,f.loop)(60)){let o=(r+.5/60)*Math.PI*2,a=Math.cos(o),i=Math.sin(o),l=e.raycast(0,0,a,i).getPointMin(),s=t.raycast(0,0,a,i).getPointMin();n.moveTo(l).lineTo(s)}return n.draw(),{lines:n}})()}}function M(){return(0,i.dB)("four-circles",function*(n){(0,x.mj)(new u.N({color:"#e1dff1"}),n),(0,x.mj)(n,{rotationZ:"45deg"}),(0,x.mj)(new z,{parent:n}),(0,x.mj)(new b,{parent:n,position:[2.0175,2.0175,0]},n=>{n.parts.planeUniforms.uTimeCycleOffset.value=0,n.parts.colors[1].set("#fcff99"),n.parts.colors[2].set("#170551")}),(0,x.mj)(new b,{parent:n,position:[2.0175,-2.0175,0]},n=>{n.parts.planeUniforms.uTimeCycleOffset.value=.25,n.parts.colors[1].set("#18188c"),n.parts.colors[2].set("#72d9ab")}),(0,x.mj)(new b,{parent:n,position:[-2.0175,-2.0175,0]},n=>{n.parts.planeUniforms.uTimeCycleOffset.value=.5,n.parts.colors[1].set("#f3a3b3"),n.parts.colors[2].set("#15093e")}),(0,x.mj)(new b,{parent:n,position:[-2.0175,2.0175,0]},n=>{n.parts.planeUniforms.uTimeCycleOffset.value=.75,n.parts.colors[1].set("#3b3426"),n.parts.colors[2].set("#de2566")}),(0,x.mj)(new b,{parent:n,scaleScalar:4,position:[0,0,-1]},n=>{n.parts.planeUniforms.uTimeCycleOffset.value=.75,n.parts.colors[0].set("#e1dff1"),n.parts.colors[1].set("#95c3fb"),n.parts.colors[2].set("#170551")})},[]),null}function C(){return(0,i.yk)(function*(n){(0,l.O)({three:n});let e=new o.n({size:12.2,perspective:0});yield e.start(n.renderer.domElement),a.Rv.get("three").set({minActiveDuration:60}),yield(0,a.xy)("three",t=>{let{aspect:r,camera:o}=n;e.update(o,r,t.deltaTime)}),yield(0,s.a)([[{code:"Space",modifiers:"shift"},()=>{document.body.requestFullscreen()}]])},[]),null}function A(){return(0,r.jsx)("div",{children:(0,r.jsxs)(i.uB,{children:[(0,r.jsx)(C,{}),(0,r.jsx)(M,{})]})})}},28737:(n,e,t)=>{"use strict";t.d(e,{Leak:()=>x,O:()=>u});var r={};t.r(r),t.d(r,{distribute:()=>a.mn,every:()=>a.Si,findMaxBy:()=>a.vj,pairwise:()=>a.Ju,recordBy:()=>a.VY,some:()=>a.zN,split:()=>a.mn,uniqueBy:()=>a.pD});var o=t(30158),a=t(43107),i=t(38062),l=t(85795),s=t(17099),c=t(96122);function u(n){Object.assign(window,{...o,...l,...r,...n,PRNG:s.c,waveform:i.o,dedent:c.T})}function x(n){return u(n),null}},33855:(n,e,t)=>{"use strict";t.d(e,{dB:()=>p,q:()=>d,uB:()=>h,yk:()=>f});var r=t(70691),o=t(67203),a=t(49797),i=t(18479),l=t(31763),s=t(88575),c=t(36508),u=t(14277);let x=(0,o.createContext)(null);function f(n,e){let t=(0,o.useContext)(x);return(0,i.useEffects)(async function*(e,r){if(n){let e=n(t,r);if(e&&"function"==typeof e.next)do{let{value:n,done:t}=await e.next();if(t)break;yield n}while(r.mounted)}},null!=e?e:"always"),t}function p(n,e,t){let r=(0,o.useMemo)(()=>new a.YJl,[]);return r.name=n,f(async function*(n,t){if(n.scene.add(r),yield()=>{r.clear(),r.removeFromParent()},e){let o=e(r,n,t);if(o&&"function"==typeof o.next)do{let{value:n,done:e}=await o.next();if(e)break;yield n}while(t.mounted)}},t),r}function d(n){let{value:e}=n,t=(0,o.useMemo)(()=>"function"==typeof e?new e:e,[e]);return f(async function*(n){if(n.scene.add(t),"initialize"in t){let e=t.initialize(n);if(e&&"function"==typeof e.next)for(;;){let{value:n,done:t}=await e.next();if(t)break;yield n}}yield()=>{if(t.removeFromParent(),"destroy"in t){var n;null==(n=t.destroy)||n.call(t)}}},[t]),null}let m={className:"",assetsPath:"/",vertigoControls:!1};function v(n){let{children:e,className:t,assetsPath:a,vertigoControls:u}={...m,...n},f=(0,o.useMemo)(()=>new s.XW,[]);f.loader.setPath(a);let{ref:p}=(0,i.IZ)({debounce:!0},function*(n,e){yield f.initialize(n.firstElementChild),e.triggerRender(),Object.assign(window,{three:f})},[]);(0,i.useEffects)(function*(){if(u){let n=new l.n("object"==typeof u?u:{}).initialize(p.current).start();yield n.destroy,yield(0,c.xy)("three",e=>{n.update(f.camera,f.aspect,e.deltaTime)})}},[u]);let d={position:"absolute",inset:0};return(0,r.jsx)("div",{ref:p,className:t,style:d,children:(0,r.jsxs)(x.Provider,{value:f,children:[(0,r.jsx)("div",{style:d}),(0,r.jsx)("div",{style:d,className:"thru",children:f.initialized&&e})]})})}function h(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];return(0,u.D)()&&(0,r.jsx)(v,{...e[0]})}},38062:(n,e,t)=>{"use strict";t.d(e,{o:()=>r});let r={triangle:function(n){let{frequency:e=1,phase:t=0,f:r=e,p:o=t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=n*r+o,i=2*a-Math.floor(2*a);return a-Math.floor(a)<.5?i:1-i}}},43107:(n,e,t)=>{"use strict";function r(n,e){for(let t of n)if(e(t))return!0;return!1}function o(n,e){for(let t of n)if(!e(t))return!1;return!0}function a(n,e,t){let r=[];function o(n){let e=[];return r[n]=e,e}if(void 0!==t)for(let n=0;n<t;n++)o(n);for(let t of n){var a;let n=e(t);(null!=(a=r[n])?a:o(n)).push(t)}return r}function*i(n){let e;for(let t of n)void 0!==e&&(yield[e,t]),e=t}function l(n,e){let t,r=-1/0;for(let o of n){let n=e(o);n>r&&(r=n,t=o)}return t}function s(n){let e=new Set;return t=>{let r=n(t);return!e.has(r)&&(e.add(r),!0)}}function c(n){return(e,t)=>{if(null!==e&&"object"!=typeof e)throw Error("Accumulator must be an object");let r=null===e?{}:e,o=n(t);return r[o]||(r[o]=[]),r[o].push(t),r}}t.d(e,{Ju:()=>i,Si:()=>o,VY:()=>c,mn:()=>a,pD:()=>s,vj:()=>l,zN:()=>r})},63106:(n,e,t)=>{"use strict";function r(n,e){return"*"===e||("string"==typeof e?e===n:e instanceof RegExp?e.test(n):"function"==typeof e&&e(n))}t.d(e,{a:()=>l});let o={preventDefault:!1,strictTarget:void 0},a={key:"*",keyCaseInsensitive:!0,code:"*",noModifiers:!1,modifiers:"",phase:"down"},i=0;function l(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];let l=i++,[s,c,u]=1===e.length?[document.body,{},e[0]]:2===e.length?[e[0],{},e[1]]:e,{preventDefault:x}={...o,...c},f=null,p=n=>{var e;if((null!=(e=c.strictTarget)?!!e:s===document.body)&&n.target!==s)return;"keydown"===n.type&&(f=n);let{ctrlKey:t=!1,altKey:o=!1,shiftKey:i=!1,metaKey:p=!1}=null!=f?f:{},d={id:l,event:n,downEvent:f,modifiers:{ctrl:t,alt:o,shift:i,meta:p}};for(let e=0,l=u.length;e<l;e++){let[l,s]=u[e],{key:c,keyCaseInsensitive:m,code:v,noModifiers:h,modifiers:y,phase:w="down"}=function(n){let e="string"==typeof n?{...a,key:n}:{...a,...n};return e.keyCaseInsensitive&&"string"==typeof e.key&&(e.key=e.key.toLowerCase()),e}(l);switch(n.type){case"keydown":if("down"!==w)continue;break;case"keyup":if("up"!==w)continue}Object.values({key:r(m?n.key.toLowerCase():n.key,c),code:r(n.code,v),noModifiers:!h||!1===t&&!1===o&&!1===i&&!1===p,modifiers:function(n,e){let{ctrlKey:t,altKey:r,shiftKey:o,metaKey:a}=n;if("function"==typeof e)return e({ctrl:t,alt:r,shift:o,meta:a});let{ctrl:i=!1,alt:l=!1,shift:s=!1,meta:c=!1}=Object.fromEntries(e.split("-").map(n=>[n,!0]));return i===t&&l===r&&s===o&&c===a}(f,y)}).every(Boolean)&&(x&&n.preventDefault(),s(d))}};return s.addEventListener("keydown",p,{passive:!1}),s.addEventListener("keyup",p,{passive:!1}),{destroy:()=>{s.removeEventListener("keydown",p),s.removeEventListener("keyup",p)}}}},65927:(n,e,t)=>{"use strict";t.d(e,{S:()=>r});let r="\n#ifndef GLSL_BASIC\n#define GLSL_BASIC\n\nfloat clamp01(float x) {\n  return x < 0.0 ? 0.0 : x > 1.0 ? 1.0 : x;\n}\n\nvec2 clamp01(vec2 x) {\n  return vec2(clamp01(x.x), clamp01(x.y));\n}\n\nvec3 clamp01(vec3 x) {\n  return vec3(clamp01(x.x), clamp01(x.y), clamp01(x.z));\n}\n\nvec4 clamp01(vec4 x) {\n  return vec4(clamp01(x.x), clamp01(x.y), clamp01(x.z), clamp01(x.w));\n}\n\n#endif\n"},66620:(n,e,t)=>{"use strict";t.d(e,{_:()=>a});var r=t(89868),o=t(44138);function a(n,e){var t=(0,o._)(n,e,"update");return(0,r._)(n,t)}},72612:(n,e,t)=>{"use strict";function*r(n){let e=0,t={get i(){return e},get t(){return e/n},get p(){return e/(n-1)},get size(){return n},clone(){return{...this}}};for(e=0;e<n;e++)yield t}function o(n,e){let t=[];for(let o of r(n)){let n=o.clone();t.push(e?e(n):n)}return t}function*a(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];let r=0,o=0;2===e.length?(r=e[0],o=e[1]):Array.isArray(e[0])?(r=e[0][0],o=e[0][1]):(r=e[0].x,o=e[0].y);let a=0,i=0,l=0,s={get i(){return a},get x(){return i},get y(){return l},get tx(){return i/r},get ty(){return l/o},get px(){return i/(r-1)},get py(){return l/(o-1)},get sizeX(){return r},get sizeY(){return o},clone(){return{...this}}};for(l=0;l<o;l++)for(i=0;i<r;i++)yield s,a++}function i(){let n;for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];let o=0,i=0;"number"==typeof t[0]?(o=t[0],i=t[1],n=t[2]):(Array.isArray(t[0])?(o=t[0][0],i=t[0][1]):(o=t[0].x,i=t[0].y),n=t[1]);let l=[];for(let e of a(o,i)){let t=e.clone();l.push(n?n(t):t)}return l}function*l(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];let r=0,o=0,a=0;3===e.length?(r=e[0],o=e[1],a=e[2]):Array.isArray(e[0])?(r=e[0][0],o=e[0][1],a=e[0][2]):(r=e[0].x,o=e[0].y,a=e[0].z);let i=0,l=0,s=0,c=0,u={get i(){return i},get x(){return l},get y(){return s},get z(){return c},get tx(){return l/r},get ty(){return s/o},get tz(){return c/a},get px(){return l/(r-1)},get py(){return s/(o-1)},get pz(){return c/(a-1)},clone(){return{...this}}};for(c=0;c<a;c++)for(s=0;s<o;s++)for(l=0;l<r;l++)yield u,i++}function s(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];let r=[];for(let n of l(...e))r.push(n.clone());return r}t.r(e),t.d(e,{loop:()=>r,loop2:()=>a,loop2Array:()=>i,loop3:()=>l,loop3Array:()=>s,loopArray:()=>o})},79105:(n,e,t)=>{"use strict";t.d(e,{K2:()=>i,KP:()=>o,Tj:()=>l,Ts:()=>a,Zu:()=>r});let r=0x7fffffff,o=123456,a=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:o;if(Number.isNaN(n))throw Error("NaN is not a valid seed.");let e=n;if(10>Math.abs(e)&&(e*=1e6),e%=r,(e=e<0?e+r:e)>1)return e&r;if(0===e)return o;throw Error("Impossible. ".concat(e))},i=n=>n=Math.imul(n,48271)&r,l=n=>(n-1)/(r-1)},84896:(n,e,t)=>{Promise.resolve().then(t.bind(t,23200))},88575:(n,e,t)=>{"use strict";t.d(e,{O0:()=>r.O0,XW:()=>r.XW});var r=t(9215)},96122:(n,e,t)=>{"use strict";function r(n){let e=n.split("\n"),t=0;for(let n of e){let e=n.match(/^(\s*)\S/);if(e){t=e[1].length;break}}return e.map(n=>n.slice(Math.min(n.length,t))).join("\n")}t.d(e,{T:()=>r})}},n=>{var e=e=>n(n.s=e);n.O(0,[5611,7190,6564,7962,9635,8921,7953,4512,7775,7436,146,6726,3445,9332,3414,9717,1763,9215,1319,6852,7358],()=>e(84896)),_N_E=n.O()}]);