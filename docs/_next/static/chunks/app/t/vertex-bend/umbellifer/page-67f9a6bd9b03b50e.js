(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[190],{1029:(e,n,t)=>{"use strict";t.d(n,{N:()=>r});let i={vecX:["float","vec2","vec3","vec4"]},r=(e,n)=>{let t=[],r=Array.isArray(e)?e:[e].map(e=>e in i?i[e]:e).flat();if("function"==typeof n)for(let e of r)t.push(n(e).replaceAll(/\bT\b/g,e));else for(let e of r)t.push(n.replaceAll(/\bT\b/g,e));return t.join("\n")}},3009:(e,n,t)=>{"use strict";t.d(n,{Zt:()=>l,zf:()=>i,QS:()=>a});let i="\n#ifndef GLSL_BEND\n#define GLSL_BEND\n  vec4 applyBend(vec4 position, float factor, mat4 bendMatrix, mat4 bendMatrixInverse) {\n    float q = 1.0 / factor;\n    \n    if (abs(factor) < 0.0001)\n      return position;\n    \n    position = bendMatrixInverse * position;\n    vec2 center = vec2(0.0, q);\n    float a = position.x / q;\n    float r = center.y - position.y;\n    position.x = center.x + r * sin(a);\n    position.y = center.y + -r * cos(a);\n    position = bendMatrix * position;\n    return position;\n  }\n#endif\n";var r=t(49797),o=t(7147);function l(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"white";return{uBendFactor:{value:0},uBendMatrix:{value:e.clone()},uBendMatrixInverse:{value:e.clone().invert()},uMyColor:{value:new r.Q1f(n)}}}function a(e,n){o.bI.with(e).uniforms(n).vertex.top(i).vertex.replace("project_vertex","\n  vec4 mvPosition = vec4( transformed, 1.0 );\n  #ifdef USE_BATCHING\n    mvPosition = batchingMatrix * mvPosition;\n  #endif\n  #ifdef USE_INSTANCING\n    mvPosition = instanceMatrix * mvPosition;\n  #endif\n  mvPosition = modelMatrix * mvPosition;\n  mvPosition = applyBend(mvPosition, uBendFactor, uBendMatrix, uBendMatrixInverse);\n  mvPosition = viewMatrix * mvPosition;\n  gl_Position = projectionMatrix * mvPosition;\n")}},14203:(e,n,t)=>{"use strict";t.d(n,{O:()=>r});var i=t(1029);let r="\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; \n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat permute(float x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nfloat taylorInvSqrt(float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\n\n\n\n\n// 2D:\n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n		+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// 3D: \n\nfloat snoise(vec3 v)\n{ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\n\n// 4D:\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n						\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v) {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n  // First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n  // Other corners\n\n  // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n  //  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n  //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n  // Permutations\n  i = mod289(i); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n  // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n  // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n  // Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n  // Mix contributions from the five corners\n  vec3 m0 = max(0.57 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.57 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 60.1 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\n\n\n\n// addons:\n// Fractal noise, based on Stefan Gustavson's Simplex noise\n".concat((0,i.N)(["vec2","vec3","vec4"],"\n  float fnoise(T p, int octaves, float persistence) {\n    float total = 0.0;           // Final noise value\n    float amplitude = 1.0;       // Initial amplitude\n    float frequency = 1.0;       // Initial frequency\n    float maxValue = 0.0;        // Used for normalization\n\n    for (int i = 0; i < octaves; i++) {\n      total += snoise(p * frequency) * amplitude;\n\n      maxValue += amplitude;   // Keep track of max amplitude\n      amplitude *= persistence; // Reduce amplitude for next octave\n      frequency *= 2.0;        // Increase frequency for next octave\n    }\n\n    // Normalize the result to stay within the range [0, 1]\n    return total / maxValue;\n  }\n\n  float fnoise(T p, int octaves) {\n    return fnoise(p, octaves, 0.5);\n  }\n\n  float fnoise(T p) {\n    return fnoise(p, 4, 0.5);\n  }\n"),"\n\nfloat snoiseFast4D(vec4 p) {\n  const float SCALAR = 0.01;\n  float a = SCALAR * dot(p.xy * 0.3, vec2(-127.1, 311.7));\n  float b = SCALAR * dot(p.zw * 0.8, vec2(269.5, -183.3));\n  float c = SCALAR * dot(p.wx * 6.0, vec2(23.14069, 2.665157));\n  float d = SCALAR * dot(p.zy * 1.3, vec2(-12.9898, 78.233));\n  return (snoise(vec2(a, b)) + snoise(vec2(d, c))) * 0.5;\n}\n\nfloat fnoiseFast4D(vec4 p, int octaves, float persistence) {\n  float total = 0.0;           // Final noise value\n  float amplitude = 1.0;       // Initial amplitude\n  float frequency = 1.0;       // Initial frequency\n  float maxValue = 0.0;        // Used for normalization\n\n  for (int i = 0; i < octaves; i++) {\n    total += snoiseFast4D(p * frequency) * amplitude;\n\n    maxValue += amplitude;   // Keep track of max amplitude\n    amplitude *= persistence; // Reduce amplitude for next octave\n    frequency *= 2.0;        // Increase frequency for next octave\n  }\n\n  // Normalize the result to stay within the range [0, 1]\n  return total / maxValue;\n}\n")},15239:(e,n,t)=>{Promise.resolve().then(t.bind(t,99656))},43969:(e,n,t)=>{"use strict";t.d(n,{E:()=>u});var i=t(49797),r=t(7147),o=t(94065);let l=new i.kn4;function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=arguments.length>1?arguments[1]:void 0,t=e/2,r=[new i.Pq0(-t,0,0),new i.Pq0(+t,0,0)];for(let e of((0,o.vl)(null!=n?n:{},l),r))e.applyMatrix4(l);return r}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=arguments.length>1?arguments[1]:void 0,t=e/2,r=[new i.Pq0(-t,0,0),new i.Pq0(+t,0,0),new i.Pq0(0,-t,0),new i.Pq0(0,+t,0)];for(let e of((0,o.vl)(null!=n?n:{},l),r))e.applyMatrix4(l);return r}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=arguments.length>1?arguments[1]:void 0,t=e/2;return(0,o.vl)(null!=n?n:{},l),[new i.Pq0(-t,-t,0),new i.Pq0(+t,+t,0),new i.Pq0(+t,-t,0),new i.Pq0(-t,+t,0)].map(e=>e.applyMatrix4(l))}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=arguments.length>1?arguments[1]:void 0,t=e/2;return(0,o.vl)(null!=n?n:{},l),[new i.Pq0(-t,+t,0).applyMatrix4(l),new i.Pq0(0,0,0).applyMatrix4(l),new i.Pq0(0,0,0).applyMatrix4(l),new i.Pq0(+t,+t,0).applyMatrix4(l),new i.Pq0(0,0,0).applyMatrix4(l),new i.Pq0(0,-t,0).applyMatrix4(l)]}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=arguments.length>1?arguments[1]:void 0,t=e/2;return(0,o.vl)(null!=n?n:{},l),[new i.Pq0(-t,+t,0).applyMatrix4(l),new i.Pq0(+t,+t,0).applyMatrix4(l),new i.Pq0(+t,+t,0).applyMatrix4(l),new i.Pq0(-t,-t,0).applyMatrix4(l),new i.Pq0(-t,-t,0).applyMatrix4(l),new i.Pq0(+t,-t,0).applyMatrix4(l)]}class u extends i.DXC{constructor(e){let{divisions:n=10,interiorOpacity:t=.2,letters:u=!1}=null!=e?e:{},v=(e,n,t)=>Array.from({length:t},(r,o)=>[new i.Pq0().lerpVectors(e,n,o/t),new i.Pq0().lerpVectors(e,n,(o+1)/t)]).flat(),f=[...v(new i.Pq0(-1,-1,-1),new i.Pq0(1,-1,-1),n),...v(new i.Pq0(-1,1,-1),new i.Pq0(1,1,-1),n),...v(new i.Pq0(-1,1,1),new i.Pq0(1,1,1),n),...v(new i.Pq0(-1,-1,1),new i.Pq0(1,-1,1),n),...v(new i.Pq0(-1,-1,-1),new i.Pq0(-1,1,-1),n),...v(new i.Pq0(1,-1,-1),new i.Pq0(1,1,-1),n),...v(new i.Pq0(1,-1,1),new i.Pq0(1,1,1),n),...v(new i.Pq0(-1,-1,1),new i.Pq0(-1,1,1),n),...v(new i.Pq0(-1,-1,-1),new i.Pq0(-1,-1,1),n),...v(new i.Pq0(1,-1,-1),new i.Pq0(1,-1,1),n),...v(new i.Pq0(1,1,-1),new i.Pq0(1,1,1),n),...v(new i.Pq0(-1,1,-1),new i.Pq0(-1,1,1),n)],p=u?[...function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=arguments.length>1?arguments[1]:void 0,t=[...s(e/2,{x:-(.375*e)}),...c(e,{x:.375*e})];for(let e of((0,o.vl)(null!=n?n:{},l),t))e.applyMatrix4(l);return t}(.1,{x:1.1}),...function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=arguments.length>1?arguments[1]:void 0,t=[...s(e/2,{x:-(.375*e)}),...x(e,{x:.375*e})];for(let e of((0,o.vl)(null!=n?n:{},l),t))e.applyMatrix4(l);return t}(.1,{y:1.1}),...function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=arguments.length>1?arguments[1]:void 0,t=[...s(e/2,{x:-(.375*e)}),...d(e,{x:.375*e})];for(let e of((0,o.vl)(null!=n?n:{},l),t))e.applyMatrix4(l);return t}(.1,{z:1.1}),...function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=arguments.length>1?arguments[1]:void 0,t=[...a(e/2,{x:-(.375*e)}),...c(e,{x:.375*e})];for(let e of((0,o.vl)(null!=n?n:{},l),t))e.applyMatrix4(l);return t}(.1,{x:-1.1}),...function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=arguments.length>1?arguments[1]:void 0,t=[...a(e/2,{x:-(.375*e)}),...x(e,{x:.375*e})];for(let e of((0,o.vl)(null!=n?n:{},l),t))e.applyMatrix4(l);return t}(.1,{y:-1.1}),...function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=arguments.length>1?arguments[1]:void 0,t=[...a(e/2,{x:-(.375*e)}),...d(e,{x:.375*e})];for(let e of((0,o.vl)(null!=n?n:{},l),t))e.applyMatrix4(l);return t}(.1,{z:-1.1})]:[],h=[...v(new i.Pq0(-1,-1,0),new i.Pq0(1,-1,0),n),...v(new i.Pq0(-1,1,0),new i.Pq0(1,1,0),n),...v(new i.Pq0(-1,0,-1),new i.Pq0(1,0,-1),n),...v(new i.Pq0(-1,0,1),new i.Pq0(1,0,1),n),...v(new i.Pq0(0,-1,-1),new i.Pq0(0,1,-1),n),...v(new i.Pq0(0,-1,1),new i.Pq0(0,1,1),n),...v(new i.Pq0(-1,-1,0),new i.Pq0(-1,1,0),n),...v(new i.Pq0(1,-1,0),new i.Pq0(1,1,0),n),...v(new i.Pq0(-1,0,-1),new i.Pq0(-1,0,1),n),...v(new i.Pq0(1,0,-1),new i.Pq0(1,0,1),n),...v(new i.Pq0(0,-1,-1),new i.Pq0(0,-1,1),n),...v(new i.Pq0(0,1,-1),new i.Pq0(0,1,1),n)],m=new i.LoY().setFromPoints([...f,...p,...h]),y=new i.THS(new Float32Array(m.getAttribute("position").count),1),w=f.length+p.length;y.array.fill(1,0,w),y.array.fill(t,w),m.setAttribute("aOpacity",y);let g=new i.mrM({color:"#ff0",transparent:!0});g.onBeforeCompile=n=>{var t;r.bI.with(n).varying({vOpacity:"float"}).vertex.top("\n          attribute float aOpacity;\n        ").vertex.mainAfterAll("\n          vOpacity = aOpacity;\n        ").fragment.after("map_fragment","\n          diffuseColor.a *= vOpacity;\n        "),null==e||null==(t=e.onBeforeCompile)||t.call(e,n)},super(m,g)}}},45553:(e,n,t)=>{"use strict";t.d(n,{z:()=>s});var i=t(49797);let r=new i.Pq0,o=new i.Pq0,l=new i.Pq0,a=new i.Pq0;function s(e,n,t){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a;l.crossVectors(e,n),1e-6>l.lengthSq()&&(l.set(1,0,0).cross(e),1e-6>l.lengthSq()&&l.set(0,1,0).cross(e));let s=e.length(),c=n.length();r.copy(e).divideScalar(s),o.copy(n).divideScalar(c);let x=Math.acos(Math.min(Math.max(r.dot(o),-1),1));if(1e-6>Math.abs(x))i.lerpVectors(e,n,t);else{l.normalize();let e=x*t,n=Math.cos(e),a=Math.sin(e);i.copy(r).multiplyScalar(n).addScaledVector(o.copy(l).cross(r),a).multiplyScalar((1-t)*s+t*c)}return i}},66620:(e,n,t)=>{"use strict";t.d(n,{_:()=>o});var i=t(89868),r=t(44138);function o(e,n){var t=(0,r._)(e,n,"update");return(0,i._)(e,t)}},79105:(e,n,t)=>{"use strict";t.d(n,{K2:()=>l,KP:()=>r,Tj:()=>a,Ts:()=>o,Zu:()=>i});let i=0x7fffffff,r=123456,o=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r;if(Number.isNaN(e))throw Error("NaN is not a valid seed.");let n=e;if(10>Math.abs(n)&&(n*=1e6),n%=i,(n=n<0?n+i:n)>1)return n&i;if(0===n)return r;throw Error("Impossible. ".concat(n))},l=e=>e=Math.imul(e,48271)&i,a=e=>(e-1)/(i-1)},80446:(e,n,t)=>{"use strict";t.d(n,{n:()=>r});var i=t(79105);let r=function e(){let n=Math.random,t=()=>{};function r(e){let n=0;for(let t=0;t<e.length;t++)n=(n<<5)-n+e.charCodeAt(t)|0;return n}function o(){for(var e=arguments.length,t=Array(e),i=0;i<e;i++)t[i]=arguments[i];if(0===t.length)return n();if(1===t.length)return n()*t[0];if(2===t.length)return n()*(t[1]-t[0])+t[0];throw Error("Invalid arguments")}function l(){for(var e=arguments.length,t=Array(e),i=0;i<e;i++)t[i]=arguments[i];if(1===t.length)return Math.floor(n()*t[0]);if(2===t.length)return Math.floor(n()*(t[1]-t[0]))+t[0];throw Error("Invalid arguments")}function a(e){let{weightsAreNormalized:t=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(0===e.length)throw Error("Weights array is empty");if(!1===t){let t=e.reduce((e,n)=>e+n,0),i=n()*t,r=0;for(let n=0;n<e.length;n++)if(i<(r+=e[n]))return n;return e.length-1}{let t=n(),i=0;for(let n=0;n<e.length;n++)if(t<(i+=e[n]))return n;return e.length-1}}let s={new:function(){for(var n=arguments.length,t=Array(n),i=0;i<n;i++)t[i]=arguments[i];return e().setRandom(...t)},setRandom:function(){for(var e=arguments.length,o=Array(e),l=0;l<e;l++)o[l]=arguments[l];let[a,c=0]=o,x="string"==typeof c?r(c):c;if("parkmiller"===a){let e=i.Ts(x);n=()=>(e=i.K2(e),i.Tj(e)),t=n=>{e=i.Ts(n)}}else{if(void 0!==a&&"function"!=typeof a)throw Error("Invalid random function");n=null!=a?a:Math.random,t=()=>{}}return t(x),s},seed:function(e){return t("string"==typeof e?r(e):null!=e?e:0),s},get random(){return n},chance:function(e){return n()<e},number:o,float:o,f:o,sign:function(){return .5>n()?-1:1},int:l,i:l,hexColor:function(){let e=Math.floor(0xffffff*n());return"#".concat(e.toString(16).padStart(6,"0"))},pickIndex:a,pick:function(e,t){if(0===e.length)throw Error("Array is empty");if(t)return e[a(t)];let i=Math.floor(n()*e.length);return e[i]},createPicker:function(e){let n=e.map(e=>e[0]),t=e.map(e=>e[1]),i=n.reduce((e,n)=>e+n,0);for(let e=0;e<n.length;e++)n[e]/=i;return()=>t[a(n,{weightsAreNormalized:!0})]},direction2:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{x:0,y:0},t=n()*Math.PI*2;return e.x=Math.cos(t),e.y=Math.sin(t),e},direction3:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{x:0,y:0,z:0},t=n(),i=n(),r=2*Math.PI*t,o=Math.acos(1-2*i);return e.x=Math.sin(o)*Math.cos(r),e.y=Math.sin(o)*Math.sin(r),e.z=Math.cos(o),e},quaternion:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{x:0,y:0,z:0,w:1},t=n(),i=n(),r=n(),o=Math.sqrt(1-t),l=Math.sqrt(t);return e.x=o*Math.sin(2*Math.PI*i),e.y=o*Math.cos(2*Math.PI*i),e.z=l*Math.sin(2*Math.PI*r),e.w=l*Math.cos(2*Math.PI*r),e},shuffleIndexes:function*(e){if(e<=0)throw Error("N must be greater than 0");let t=0,i=Math.floor((2+2*n())*e);for(;1!==function(e,n){for(;0!==n;)[e,n]=[n,e%n];return e}(e,i);){if(++t>1e3)throw Error("Failed to find a suitable a value after 1000 attempts");i=e+Math.floor(n()*e)}let r=Math.floor(n()*e);for(let n=0;n<e;n++)yield(r+n*i)%e}};return s}()},99656:(e,n,t)=>{"use strict";t.d(n,{ClientPage:()=>b});var i=t(70691),r=t(33540),o=t(3009),l=t(43969),a=t(77794),s=t(79911),c=t(77674),x=t(49797),d=t(74740),u=t(30123),v=t(74842),f=t(44019),p=t(45553),h=t(7147),m=t(3293),y=t(44694),w=t(14203),g=t(80446);class P{get length(){return this.getLength()}set length(e){this.setLength(e)}*positions(){yield this.start.x,yield this.start.y,yield this.start.z,yield this.end.x,yield this.end.y,yield this.end.z}*colors(){yield this.startColor.r,yield this.startColor.g,yield this.startColor.b,yield this.endColor.r,yield this.endColor.g,yield this.endColor.b}getChild(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];let i=this;for(let e of n)i=i.children[e];return i}getLength(){return this.start.distanceTo(this.end)}setLength(e){let{_v:n}=(0,c._)(P,P,q),t=n.subVectors(this.end,this.start).normalize();return this.end.copy(this.start).addScaledVector(t,e),this}mulLength(e){let{_v:n}=(0,c._)(P,P,q);return n.subVectors(this.end,this.start).multiplyScalar(e),this.end.copy(this.start).add(n),this}isRoot(){return null===this.parent}isLeaf(){return 0===this.children.length}allDescendantsCount(){let e=1;for(let n of this.children)e+=n.allDescendantsCount();return e}*allDescendantsColors(){for(let e of this.allDescendants({includeSelf:!0}))yield*e.colors()}*allDescendantsPositions(){for(let e of this.allDescendants({includeSelf:!0}))yield*e.positions()}*allDescendants(){let{includeSelf:e=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};for(let n of(e&&(yield this),this.children))yield*n.allDescendants({includeSelf:!0})}*allLeaves(){let{includeSelf:e=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};for(let n of this.allDescendants({includeSelf:e}))n.isLeaf()&&(yield n)}split(e){let{angle:n="45deg",length:t=1,lengthVariationFactor:i=1,altDir:r,altDirWeight:o=0}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},l=new x.Pq0().subVectors(this.end,this.start),a=l.length();if(l.divideScalar(a),r){let e=(0,f.jj)(r).normalize();(0,p.z)(l,e,o,l)}let s=(0,y.ey)(n);for(let n=0;n<e;n++){let r=t*Math.pow(i,g.n.number(-1,1)),o=new P(this.end,new x.Pq0().addVectors(this.end,l.clone().applyAxisAngle(this.normal,s).applyAxisAngle(l,2*Math.PI*n/e).multiplyScalar(r)),this.normal);o.parent=this,this.children.push(o)}return this}constructor(e,n,t){this.start=e,this.end=n,this.normal=t,this.parent=null,this.children=[],this.startColor=new x.Q1f("white"),this.endColor=new x.Q1f("white")}}var q={writable:!0,value:{_v:new x.Pq0}};class M extends x.YJl{get noiseAmplitude(){return this.uNoiseAmplitude.value}set noiseAmplitude(e){this.uNoiseAmplitude.value=e}setPositionOnScene(e){return this.positionOnScene=e,this}enableBend(){let e={rotationZ:"90deg",rotationY:"20deg"},n=(0,o.Zt)((0,m.w)(e));return this.material.onBeforeCompile=e=>{h.bI.with(e).uniforms({...n,uTime:this.uTime,uNoiseAmplitude:this.uNoiseAmplitude}).vertex.top(o.zf,w.O);let t=e.vertexShader,i=e.vertexShader.indexOf("vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );"),r=e.vertexShader.indexOf("vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );");e.vertexShader=t.substring(0,i)+"\n          vec4 start = vec4( instanceStart, 1.0 );\n          vec4 end = vec4( instanceEnd, 1.0 );\n\n          start = modelMatrix * start;\n          end = modelMatrix * end;\n\n          start = applyBend(start, uBendFactor, uBendMatrix, uBendMatrixInverse);\n          end = applyBend(end, uBendFactor, uBendMatrix, uBendMatrixInverse);\n\n          float time = uTime * 0.15;\n          float noiseScale = 0.825;\n          float startNoise = snoise(vec4(start.xyz * noiseScale, time)) * instanceStart.y;\n          float endNoise = snoise(vec4(end.xyz * noiseScale, time)) * instanceEnd.y;\n\n          start.xz += vec2(1.0, -1.0) * startNoise * uNoiseAmplitude * 0.01;\n          end.xz += vec2(1.0, -1.0) * endNoise * uNoiseAmplitude * 0.01;\n\n          start = viewMatrix * start;\n          end = viewMatrix * end;\n        "+t.substring(r+54)},this.bendUniforms=n,this.bendTransform=e,this}updateBendTransform(e){return this.bendUniforms&&((0,m.w)(e,this.bendUniforms.uBendMatrix.value),this.bendUniforms.uBendMatrixInverse.value.copy(this.bendUniforms.uBendMatrix.value).invert()),this}update(e){if(this.uTime.value+=e,this.bendUniforms){let e=this.uTime.value;this.bendUniforms.uBendFactor.value=.33*this.bendAmplitude*(.1*Math.sin(1.5*e)+.03*Math.sin(3.34*e)+.01*Math.sin(4.732*e))}return this}constructor(e=256789,{splitIndices:n=[[2]]}={}){super(),this.uTime={value:0},this.uNoiseAmplitude={value:1},this.bendAmplitude=1,this.bendUniforms=null,this.bendTransform=null;let t=new P(new x.Pq0(0,0,0),new x.Pq0(0,1,0),new x.Pq0(1,0,0));for(let i of(g.n.setRandom("parkmiller",e),t.split(3,{angle:"15deg",lengthVariationFactor:1.8}),n))t.getChild(...i).mulLength(1.2).split(3,{angle:"20deg",lengthVariationFactor:1.4});for(let e of[...t.allLeaves()])e.split(6,{angle:"70deg",length:.28,altDir:[0,1,1],altDirWeight:.5}),e.split(1,{angle:"0deg",length:.17,altDir:[0,1,1],altDirWeight:.5});for(let e of[...t.allLeaves()])e.split(11,{angle:"70deg",length:.12,altDir:[0,1,0],altDirWeight:.5});for(let e of[...t.allLeaves()])e.split(13,{angle:"70deg",length:.04,altDir:[0,1,0],altDirWeight:.75});{let e=new x.Q1f("#ecde0d"),n=new x.Q1f("#fff"),i=0,r=new Set(t.allLeaves()),o=new Set,l=()=>{[r,o]=[o,r]},a=e=>Math.min(1,Math.max(0,e));for(;r.size>0;){for(let t of r)t.endColor.lerpColors(e,n,a(i/3)),t.startColor.lerpColors(e,n,a((i+1)/3)),t.parent&&o.add(t.parent);r.clear(),l(),i++}}let i=new d.n;i.setPositions([...t.allDescendantsPositions()]),i.setColors([...t.allDescendantsColors()]);let r=new u.G({color:"white",worldUnits:!0,linewidth:.0015,vertexColors:!0});(0,s.mj)(new v.b(i,r),this),this.scale.setScalar(.25),this.material=r}}function z(){let e=(0,r.Fw)();return(0,r.dB)("slerp-scene",function*(n){e.pipeline.basicPasses.fxaa.enabled=!1,(0,s.mj)(new a.u,n).regularGrid({size:4});let t=(0,s.mj)(new M,n);t.bendAmplitude=2,t.noiseAmplitude=2,t.enableBend(),yield e.ticker.onTick(e=>{t.update(e.deltaTime)}),(0,s.mj)(new l.E({letters:!0,onBeforeCompile:e=>{(0,o.QS)(e,t.bendUniforms)}}),{parent:n,...t.bendTransform})},"always"),null}function b(){return(0,i.jsxs)(r.uB,{vertigoControls:{perspective:.5,size:1.4,focus:[0,.6,0]},children:[(0,i.jsx)("div",{className:"layer thru p-16",children:(0,i.jsx)("h1",{className:"text-4xl font-bold",children:"Umbellifer"})}),(0,i.jsx)(z,{})]})}}},e=>{var n=n=>e(e.s=n);e.O(0,[5611,7190,6564,7962,9635,8921,7953,4512,7775,7436,4842,146,487,3445,9332,3414,9717,1763,2143,3540,1319,6852,7358],()=>n(15239)),_N_E=e.O()}]);