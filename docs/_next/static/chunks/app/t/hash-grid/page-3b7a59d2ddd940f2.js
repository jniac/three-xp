(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4749],{888:(t,e,r)=>{"use strict";function a(t,e){return e||(e=t.slice(0)),Object.freeze(Object.defineProperties(t,{raw:{value:Object.freeze(e)}}))}r.d(e,{_:()=>a})},6697:(t,e,r)=>{"use strict";r.d(e,{O0:()=>a.O0,XW:()=>a.XW});var a=r(17112)},9723:(t,e,r)=>{"use strict";r.d(e,{Y:()=>i});var a=r(49797),n=r(60041);let s={shadowColor:"#808080",luminosity:1,rampPower:1,onBeforeCompile:void 0};class i extends a.V9B{constructor(t){let{rampPower:e,shadowColor:r,luminosity:i,onBeforeCompile:o,...l}={...s,...t},p={uSunPosition:{value:new a.Pq0(.5,.7,.3)},uShadowColor:{value:new a.Q1f(r)},uRampPower:{value:e},uLuminosity:{value:i}};super(l),this.onBeforeCompile=t=>{n.b.with(t).uniforms(p).varying({vWorldNormal:"vec3"}).vertex.mainAfterAll("\n          vWorldNormal = mat3(modelMatrix) * normal;\n        ").fragment.after("map_fragment","\n          vec3 lightDirection = normalize(uSunPosition);\n          float light = dot(vWorldNormal, lightDirection) * 0.5 + 0.5;\n          light = pow(light, uRampPower);\n          diffuseColor.rgb *= mix(uShadowColor * uLuminosity, vec3(1.0), light);\n        "),null==o||o(t)},this.sunPosition=p.uSunPosition.value}}},50926:(t,e,r)=>{"use strict";r.d(e,{u:()=>_,w:()=>q});var a=r(49797),n=r(96273),s=r(67840);class i{ensureKeyEntry(t,e,r){let a=this.keyMap.get(t);if(a){if(a.count!==r)throw Error("A key entry already exists with a different count. This is not allowed. Once a key is set, it cannot be changed.");return a}{let a={index:e,count:r};return this.keyMap.set(t,a),a}}applyTransform(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];throw Error("Not implemented!")}clear(){return this.keyMap.clear(),this}constructor(){this.keyMap=new Map,this.transformMatrix=new a.kn4}}var o=r(66066),l=r(15940),p=r(17953),h=r(81074),c=r(6726),d=r(60041);let u=new a.Pq0,f=new a.Pq0,y=new a.Pq0,x=new a.Pq0,g=new a.Pq0,m=new a.Pq0,v=new a.Pq0,w=new a.Q1f,M=new a.kn4;class b{static box(t){let[e,r,a,s,i,o,l,p]=b.boxPoints;if("min"in t||"max"in t){let{min:a=b.boxMinMaxDefaults.min,max:s=b.boxMinMaxDefaults.max}=t;(0,n.jj)(a,e),(0,n.jj)(s,r)}else if("center"in t||"size"in t){let{center:i=b.boxCenterSizeDefaults.center,size:o=b.boxCenterSizeDefaults.size}=t;(0,n.jj)(i,a),(0,n.jj)(o,s).multiplyScalar(.5),e.copy(a).sub(s),r.copy(a).add(s)}else e.copy(b.boxMinMaxDefaults.min),r.copy(b.boxMinMaxDefaults.max);t.inset&&(e.addScalar(t.inset),r.addScalar(-t.inset));let{x:h,y:c,z:d}=e,{x:u,y:f,z:y}=r;return r.set(u,c,d),a.set(u,c,y),s.set(h,c,y),i.set(h,f,d),o.set(u,f,d),l.set(u,f,y),p.set(h,f,y),t.transform&&((0,n.vl)(t.transform,M),e.applyMatrix4(M),r.applyMatrix4(M),a.applyMatrix4(M),s.applyMatrix4(M),i.applyMatrix4(M),o.applyMatrix4(M),l.applyMatrix4(M),p.applyMatrix4(M)),b}}b.boxPoints=[new a.Pq0,new a.Pq0,new a.Pq0,new a.Pq0,new a.Pq0,new a.Pq0,new a.Pq0,new a.Pq0],b.boxDefaults={inset:0,transform:void 0},b.boxMinMaxDefaults={min:new a.Pq0(-.5,-.5,-.5),max:new a.Pq0(.5,.5,.5)},b.boxCenterSizeDefaults={center:new a.Pq0(0,0,0),size:new a.Pq0(1,1,1)};let z={size:.1,proportionalSize:!1,position:"middle",skip:void 0,type:"single",scale:1},A={key:void 0,color:void 0,opacity:1,arrow:!1};var P=new WeakSet;class S extends i{static createParts(){let{nodeMaterial:t=!1,lineCount:e=2e4,defaultColor:r="white",defaultOpacity:n=1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},s=new a.LoY,i={position:new a.THS(new Float32Array(3*e*2),3),color:new a.THS(new Float32Array(3*e*2),3),aOpacity:new a.THS(new Float32Array(2*e),1)};for(let[t,e]of Object.entries(i))s.setAttribute(t,e);let o=t?(()=>{let t=new h.e9u({vertexColors:!0,transparent:!0,depthWrite:!1}),e=(0,p.xIr)(i.aOpacity,"float",1,0);return t.opacityNode=(0,p.PCg)(e),t})():(()=>{let t=new a.mrM({vertexColors:!0,transparent:!0,depthWrite:!1});return t.onBeforeCompile=t=>d.b.with(t).varying({vOpacity:"float"}).vertex.top("\n          attribute float aOpacity;\n        ").vertex.mainAfterAll("\n          vOpacity = aOpacity;\n        ").fragment.after("color_fragment","\n          diffuseColor.a *= vOpacity;\n        "),t})(),l=new a.DXC(s,o);return l.frustumCulled=!1,{count:e,defaults:{color:r,opacity:n},geometry:s,attributes:i,lines:l}}applyTransform(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];this.parts.geometry.applyMatrix4((0,n.GD)(e))}clear(){return super.clear(),this.state.index=0,this.parts.geometry.setDrawRange(0,0),this}onTop(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1e3,{lines:e}=this.parts;return 0!==t?(e.renderOrder=t,e.material.depthTest=!1,e.material.depthWrite=!1):(e.renderOrder=0,e.material.depthTest=!0,e.material.depthWrite=!0),this}segmentsArray(t,e){let{position:r,color:a,aOpacity:n}=this.parts.attributes,{key:s,color:i,opacity:l}={...A,...this.parts.defaults,...e},{r:p,g:h,b:c}=w.set(i),d=t.length/3,M=function(t,e){var r,a;if(!1===e||void 0===e)return new Float32Array;let n=Array.isArray(e)?e:[!0===e?{}:e],s=0;for(let t of n){let e=null!=(r=null==t?void 0:t.type)?r:z.type,n=null!=(a=null==t?void 0:t.position)?a:z.position;s+=(Array.isArray(n)?n.length:1)*("triple"===e?3:"double"===e?2:1)}let i=t.length/3/2,o=new Float32Array(i*s*12),l=0;for(let e=0;e<i;e++){let r=6*e;u.set(t[r+0],t[r+1],t[r+2]),f.set(t[r+3],t[r+4],t[r+5]),y.subVectors(f,u);let a=y.lengthSq();for(let t of n){let{size:e=z.size,proportionalSize:r=z.proportionalSize,position:n=z.position,skip:s=z.skip,type:i=z.type,scale:p=z.scale}=null!=t?t:{};if(void 0!==s){if(!0===s||"less-than-size"===s){if(a<e*e)continue}else if("number"==typeof s&&a<s*s)continue}let h=Math.sqrt(a),c=(r?h:1)*e*p;x.copy(y).divideScalar(h);let d=Math.abs(x.x),w=Math.abs(x.y),M=Math.abs(x.z);for(let t of(d>=M&&w>=M?g.set(x.y,-x.x,0).normalize():w>=d?g.set(x.z,0,-x.x).normalize():g.set(0,x.z,-x.y).normalize(),Array.isArray(n)?n:[n])){let r="triple"===i?3:"double"===i?2:1;for(let a=0;a<r;a++){let n=function(t){if("number"==typeof t)return t;switch(t){case"end":return 1;case"start":return 0;case"middle":return .5;default:throw Error("Invalid arrow position: ".concat(t))}}(t);r>1&&(n+=(a/(r-1)-n)*e/h*.8),m.lerpVectors(u,f,n),m.toArray(o,(4*l+0)*3),v.copy(m).addScaledVector(x,-c).addScaledVector(g,-c).toArray(o,(4*l+1)*3),m.toArray(o,(4*l+2)*3),v.copy(m).addScaledVector(x,-c).addScaledVector(g,c).toArray(o,(4*l+3)*3),l++}}}}return o}(t,null==e?void 0:e.arrow),b=M.length/3,S=d+b,{index:C}=void 0!==s?this.ensureKeyEntry(s,this.state.index,d):this.state;if(C+S>this.parts.count)throw console.log("Overflow Handling Not implemented",C+S,this.parts.count),Error("Overflow Handling Not implemented");this.state.index=Math.max(this.state.index,C+S);{let{transformMatrix:e}=this;for(let s=0;s<d;s++)u.fromArray(t,3*s).applyMatrix4(e).toArray(r.array,(C+s)*3),a.setXYZ(C+s,p,h,c),n.setX(C+s,l)}{let t=C+d;for(let e=0;e<b;e++)u.fromArray(M,3*e).applyMatrix4(this.transformMatrix).toArray(r.array,(t+e)*3),a.setXYZ(t+e,p,h,c),n.setX(t+e,l)}return(0,o._)(this,P,T).call(this),this}segments(t,e){let r=t.length,a=new Float32Array(3*r);for(let e=0;e<r;e++){let{x:r,y:s,z:i}=(0,n.jj)(t[e],u),o=3*e;a[o+0]=r,a[o+1]=s,a[o+2]=i}return this.segmentsArray(a,e)}line(t,e,r){return this.segments([t,e],r)}polyline(t,e){if(t.length<2)return this;let r=Array((t.length-1)*2);for(let e=1;e<t.length;e++)r[2*e-2]=t[e-1],r[2*e-1]=t[e];return this.segments(r,e)}polygon(t,e){return t.length<2||(this.polyline(t,e),this.line(t[t.length-1],t[0],e)),this}box(t,e){let[r,a,n,s,i,o,l,p]=b.box(t).boxPoints;return this.segmentsArray(new Float32Array([r.x,r.y,r.z,a.x,a.y,a.z,a.x,a.y,a.z,n.x,n.y,n.z,n.x,n.y,n.z,s.x,s.y,s.z,s.x,s.y,s.z,r.x,r.y,r.z,i.x,i.y,i.z,o.x,o.y,o.z,o.x,o.y,o.z,l.x,l.y,l.z,l.x,l.y,l.z,p.x,p.y,p.z,p.x,p.y,p.z,i.x,i.y,i.z,r.x,r.y,r.z,i.x,i.y,i.z,a.x,a.y,a.z,o.x,o.y,o.z,n.x,n.y,n.z,l.x,l.y,l.z,s.x,s.y,s.z,p.x,p.y,p.z]),e)}rect(t,e){let{minX:r,minY:a,maxX:n,maxY:s}=c.M_.from(t),{inset:i}={...S.rectDefaultOptions,...e};return r+=i,a+=i,n-=i,s-=i,this.segments([{x:r,y:a,z:0},{x:n,y:a,z:0},{x:n,y:a,z:0},{x:n,y:s,z:0},{x:n,y:s,z:0},{x:r,y:s,z:0},{x:r,y:s,z:0},{x:r,y:a,z:0}],e)}circle(){let{center:t=0,axis:e="z",radius:r=1,quality:a="medium",segments:s}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=arguments.length>1?arguments[1]:void 0;null!=s||(s=S.circleQualityPresets[a]);let{x:o,y:l,z:p}=(0,n.jj)(t,u);(0,n.jj)(e,u).normalize(),f.set(u.y,u.z,u.x).cross(u).normalize(),y.crossVectors(u,f);let h=new Float32Array(3*s*2);for(let t=0;t<s;t++){let e=t/s*Math.PI*2,a=(t+1)/s*Math.PI*2,n=Math.cos(e)*r,i=Math.sin(e)*r,c=Math.cos(a)*r,d=Math.sin(a)*r,u=6*t;h[u+0]=o+n*f.x+i*y.x,h[u+1]=l+n*f.y+i*y.y,h[u+2]=p+n*f.z+i*y.z,h[u+3]=o+c*f.x+d*y.x,h[u+4]=l+c*f.y+d*y.y,h[u+5]=p+c*f.z+d*y.z}return this.segmentsArray(h,i),this}regularGrid(t){let{color:e,opacity:r,plane:a,size:n,subdivisions:s}={...S.regularGridDefaults,...t},i=s.length,l=s.map((t,e)=>s.slice(e).reduce((t,e)=>t*e,1)),p=l[0],h=new Float32Array((p+1)*12),c=new Float32Array((p+1)*12).fill(1),d=new Float32Array((p+1)*4).fill(1),u=Array.isArray(e)?e:[e],f=s.map((t,e)=>{let{r,g:a,b:n}=w.set(u[Math.min(e,u.length-1)]);return[r,a,n]}),y=Array.isArray(r)?r:[r],x=s.map((t,e)=>y[Math.min(e,y.length-1)]);for(let t=0;t<=p;t++){let e=i-1;for(;t%l[e]==0&&!(--e<=0););let[r,a,s]=f[e],o=x[e],u=t/p*n,y=12*t;h[y+0]=-n/2,h[y+1]=-n/2+u,h[y+2]=0,h[y+3]=n/2,h[y+4]=-n/2+u,h[y+5]=0,h[y+6]=-n/2+u,h[y+7]=-n/2,h[y+8]=0,h[y+9]=-n/2+u,h[y+10]=n/2,h[y+11]=0,c[y+0]=r,c[y+1]=a,c[y+2]=s,c[y+3]=r,c[y+4]=a,c[y+5]=s,c[y+6]=r,c[y+7]=a,c[y+8]=s,c[y+9]=r,c[y+10]=a,c[y+11]=s;let g=4*t;d[g+0]=o,d[g+1]=o,d[g+2]=o,d[g+3]=o}if("xz"===a)for(let t=0;t<h.length;t+=3)h[t+2]=h[t+1],h[t+1]=0;else if("yz"===a)for(let t=0;t<h.length;t+=3)h[t+2]=h[t+1],h[t+1]=h[t+0],h[t+0]=0;let{index:g}=this.state;return this.parts.attributes.position.array.set(h,3*g),this.parts.attributes.color.array.set(c,3*g),this.parts.attributes.aOpacity.array.set(d,g),this.state.index+=(p+1)*4,(0,o._)(this,P,T).call(this),this}constructor(t){super(),(0,l._)(this,P),this.state={index:0},this.parts=S.createParts(t)}}function T(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];for(let t of(this.parts.geometry.setDrawRange(0,this.state.index),Object.values(this.parts.attributes)))t.needsUpdate=!0;if(this.state.index>2*this.parts.count)throw Error("Not implemented!");if(t)for(let t of Object.values(this.parts.attributes))t.array.some(t=>isNaN(t))&&console.log(t.array.findIndex(t=>isNaN(t)))}S.rectDefaultOptions={inset:0},S.circleQualityPresets={low:18,medium:36,high:64,ultra:256},S.regularGridDefaults={plane:"xy",size:100,subdivisions:[10,2,5],opacity:[.2,.05,.01],color:"white"};class C extends i{static createParts(){let{pointCount:t=1e4}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=new a.LoY,r={position:new a.THS(new Float32Array(3*t),3),color:new a.THS(new Float32Array(3*t),3),aScale:new a.THS(new Float32Array(t),1),aShape:new a.THS(new Float32Array(t),1)};for(let[t,a]of Object.entries(r))e.setAttribute(t,a);let n=new a.BH$({vertexColors:!0});n.onBeforeCompile=t=>d.b.with(t).varying({vShape:"float"}).vertex.top("\n        attribute float aScale;\n        attribute float aShape;\n      ").vertex.mainAfterAll("\n        gl_PointSize *= aScale;\n        vShape = aShape;\n      ").fragment.top("\n        float sdBox(in vec2 p, in vec2 b) {\n          vec2 d = abs(p) - b;\n          return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n        }\n      ").fragment.after("color_fragment","\n        float regular = .2;\n        float thin = .1;\n        float ultraThin = .033;\n\n        if (vShape == ".concat(C.shapes.circle,".0) {\n          float d = distance(gl_PointCoord * 2.0, vec2(1.0));\n          if (d > 1.0) discard;\n        }\n\n        if (vShape == ").concat(C.shapes.ring,".0) {\n          float d = distance(gl_PointCoord * 2.0, vec2(1.0));\n          if (d < 0.8 || d > 1.0) discard;\n        }\n\n        if (vShape == ").concat(C.shapes["ring-thin"],".0) {\n          float d = distance(gl_PointCoord * 2.0, vec2(1.0));\n          if (d < 0.9 || d > 1.0) discard;\n        }\n\n        else if (vShape == ").concat(C.shapes.plus,".0) {\n          float d0 = sdBox(gl_PointCoord * 2.0 - 1.0, vec2(1.0, regular));\n          float d1 = sdBox(gl_PointCoord * 2.0 - 1.0, vec2(regular, 1.0));\n          if (d0 > 0.0 && d1 > 0.0) discard;\n        }\n\n        else if (vShape == ").concat(C.shapes["plus-thin"],".0) {\n          float d0 = sdBox(gl_PointCoord * 2.0 - 1.0, vec2(1.0, thin));\n          float d1 = sdBox(gl_PointCoord * 2.0 - 1.0, vec2(thin, 1.0));\n          if (d0 > 0.0 && d1 > 0.0) discard;\n        }\n\n        else if (vShape == ").concat(C.shapes["plus-ultra-thin"],".0) {\n          float d0 = sdBox(gl_PointCoord * 2.0 - 1.0, vec2(1.0, ultraThin));\n          float d1 = sdBox(gl_PointCoord * 2.0 - 1.0, vec2(ultraThin, 1.0));\n          if (d0 > 0.0 && d1 > 0.0) discard;\n        }\n\n        else if (vShape == ").concat(C.shapes.x,".0) {\n          vec2 p = gl_PointCoord * 2.0 - 1.0;\n          float c = 0.70710678;\n          p = mat2(c, -c, c, c) * p;\n          float d0 = sdBox(p, vec2(1.0, regular));\n          float d1 = sdBox(p, vec2(regular, 1.0));\n          if (d0 > 0.0 && d1 > 0.0) discard;\n        }\n\n        else if (vShape == ").concat(C.shapes["x-thin"],".0) {\n          vec2 p = gl_PointCoord * 2.0 - 1.0;\n          float c = 0.70710678;\n          p = mat2(c, -c, c, c) * p;\n          float d0 = sdBox(p, vec2(1.0, thin));\n          float d1 = sdBox(p, vec2(thin, 1.0));\n          if (d0 > 0.0 && d1 > 0.0) discard;\n        }\n\n        else if (vShape == ").concat(C.shapes["x-ultra-thin"],".0) {\n          vec2 p = gl_PointCoord * 2.0 - 1.0;\n          float c = 0.70710678;\n          p = mat2(c, -c, c, c) * p;\n          float d0 = sdBox(p, vec2(1.0, ultraThin));\n          float d1 = sdBox(p, vec2(ultraThin, 1.0));\n          if (d0 > 0.0 && d1 > 0.0) discard;\n        }\n\n        // diffuseColor.rgb *= vec3(gl_PointCoord, 1.0);\n      "));let s=new a.ONl(e,n);return s.frustumCulled=!1,{count:t,geometry:e,attributes:r,points:s}}applyTransform(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];this.parts.geometry.applyMatrix4((0,n.GD)(e))}clear(){return super.clear(),this.state.index=0,this.parts.geometry.setDrawRange(0,0),this}onTop(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1e3,{points:e}=this.parts;return 0!==t?(e.renderOrder=t,e.material.depthTest=!1,e.material.depthWrite=!1,e.material.transparent=!0):(e.renderOrder=0,e.material.depthTest=!0,e.material.depthWrite=!0,e.material.transparent=!1),this}points(t){let{key:e,size:r=.1,scale:a=1,color:s="white",shape:i="square"}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{transformMatrix:o}=this,l=void 0!==e,p=t.length,{index:h}=l?this.ensureKeyEntry(e,this.state.index,p):this.state,{position:c,color:d,aScale:f,aShape:y}=this.parts.attributes,{r:x,g,b:m}=w.set(s),v=a*r,M=C.shapes[i];for(let e=0;e<p;e++){let{x:r,y:a,z:s}=(0,n.jj)(t[e],u).applyMatrix4(o),i=h+e;c.setXYZ(i,r,a,s),d.setXYZ(i,x,g,m),f.setX(i,v),y.setX(i,M)}for(let t of(this.state.index=l?Math.max(this.state.index,h+p):h+p,this.parts.geometry.setDrawRange(0,this.state.index),Object.values(this.parts.attributes)))t.needsUpdate=!0;if(this.state.index>this.parts.count)throw Error("Overflow Handling Not implemented");return this}box(t,e){let{boxPoints:r}=b.box(t);return this.points(r,e)}point(t,e){return this.points([t],e)}constructor(t){super(),this.state={index:0},this.parts=C.createParts(t)}}C.shapes=(()=>{let t=0;return{square:t++,circle:t++,ring:t++,"ring-thin":t++,plus:t++,"plus-thin":t++,"plus-ultra-thin":t++,x:t++,"x-thin":t++,"x-ultra-thin":t++}})();class O extends i{static createParts(t){let e=new s.w({textCount:2e3,...t});return{count:e.count,textHelper:e}}applyTransform(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];this.parts.textHelper.applyTransform(...e)}clear(){return this.state.index=0,this.parts.textHelper.clearAllText(),this}onTop(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1e3;return this.parts.textHelper.onTop(t),this}texts(t,e){let r=this.state.index,{texts:a,...s}={...O.textDefaults,...e},i="function"==typeof a?a:t=>a[t%a.length],o=0;for(let e of t){let{x:t,y:a,z:l}=(0,n.jj)(e,u);this.parts.textHelper.setTextAt(r,i(o),{...s,x:t,y:a,z:l}),r++,o++}return this.state.index=r,this}text(t,e,r){return this.texts([t],{...r,texts:[e]})}textAt(t,e,r){return this.parts.textHelper.setTextAt(t,e,{...r}),this}constructor(t){super(),this.state={index:0},this.parts=O.createParts(t)}}O.textDefaults={texts:t=>t.toString()};let j={color:void 0,size:.1,shape:"square",scale:1};class _ extends a.YJl{static createParts(t,e){let{nodeMaterial:r}=null!=e?e:{},a=new C(null==e?void 0:e.points);t.add(a.parts.points);let n=new S({nodeMaterial:r,...null==e?void 0:e.lines});t.add(n.parts.lines);let s=new O({nodeMaterial:r,...null==e?void 0:e.texts});return t.add(s.parts.textHelper),{pointsManager:a,linesManager:n,textsManager:s}}points(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];return this.parts.pointsManager.points(...e),this}point(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];return this.parts.pointsManager.point(...e),this}segments(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];return this.parts.linesManager.segments(...e),this}line(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];return this.parts.linesManager.line(...e),this}polyline(t,e){return this.parts.linesManager.polyline(t,e),(null==e?void 0:e.points)&&this.points(t,{...j,color:e.color,...!0===e.points?{}:e.points}),this}polylines(t,e){for(let r of t)this.polyline(r,e);return this}polygon(t,e){return this.parts.linesManager.polygon(t,e),(null==e?void 0:e.points)&&this.points(t,{...j,color:e.color,...!0===e.points?{}:e.points}),this}polygons(t,e){for(let r of t)this.polygon(r,e);return this}box(t,e){return this.parts.linesManager.box(t,e),(null==e?void 0:e.points)&&this.parts.pointsManager.box(t,{...j,color:e.color,...!0===e.points?{}:e.points}),this}circle(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];return this.parts.linesManager.circle(...e),this}rect(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];return this.parts.linesManager.rect(...e),this}regularGrid(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];return this.parts.linesManager.regularGrid(...e),this}texts(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];return this.parts.textsManager.texts(...e),this}text(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];return this.parts.textsManager.text(...e),this}textAt(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];return this.parts.textsManager.textAt(...e),this}applyTransform(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];return this.parts.pointsManager.applyTransform(...e),this.parts.linesManager.applyTransform(...e),this.parts.textsManager.applyTransform(...e),this}clear(){return this.parts.pointsManager.clear(),this.parts.linesManager.clear(),this.parts.textsManager.clear(),this}onTop(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1e3;return this.renderOrder=t,this.parts.pointsManager.onTop(t),this.parts.linesManager.onTop(t),this.parts.textsManager.onTop(t),this}globalExpose(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"debugHelper";return Object.assign(globalThis,{[t]:this}),this}addTo(t){return t?t.add(this):this.removeFromParent(),this}constructor(t){super(),this.userData={helper:!0},this.parts=_.createParts(this,t)}}let q=new _},55166:(t,e,r)=>{Promise.resolve().then(r.bind(r,28301))},79105:(t,e,r)=>{"use strict";r.d(e,{K2:()=>i,KP:()=>n,Tj:()=>o,Ts:()=>s,Zu:()=>a});let a=0x7fffffff,n=123456,s=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n;if(Number.isNaN(t))throw Error("NaN is not a valid seed.");let e=t;if(10>Math.abs(e)&&(e*=1e6),e%=a,(e=e<0?e+a:e)>1)return e&a;if(0===e)return n;throw Error("Impossible. ".concat(e))},i=t=>t=Math.imul(t,48271)&a,o=t=>(t-1)/(a-1)}},t=>{var e=e=>t(t.s=e);t.O(0,[5012,5611,7190,6564,7223,9635,8921,4957,7775,6814,7953,4638,6726,2598,1213,9673,8083,7112,41,7840,8301,1319,6852,7358],()=>e(55166)),_N_E=t.O()}]);