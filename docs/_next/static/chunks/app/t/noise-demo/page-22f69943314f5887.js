(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3328],{888:(e,t,n)=>{"use strict";function r(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}n.d(t,{_:()=>r})},1029:(e,t,n)=>{"use strict";n.d(t,{N:()=>i});let r={vecX:["float","vec2","vec3","vec4"]},i=(e,t)=>{let n=[],i=Array.isArray(e)?e:[e].map(e=>e in r?r[e]:e).flat();if("function"==typeof t)for(let e of i)n.push(t(e).replaceAll(/\bT\b/g,e));else for(let e of i)n.push(t.replaceAll(/\bT\b/g,e));return n.join("\n")}},14203:(e,t,n)=>{"use strict";n.d(t,{O:()=>i});var r=n(1029);let i="\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; \n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat permute(float x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nfloat taylorInvSqrt(float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\n\n\n\n\n// 2D:\n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n		+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// 3D: \n\nfloat snoise(vec3 v)\n{ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\n\n// 4D:\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n						\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v) {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n  // First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n  // Other corners\n\n  // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n  //  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n  //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n  // Permutations\n  i = mod289(i); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n  // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n  // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n  // Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n  // Mix contributions from the five corners\n  vec3 m0 = max(0.57 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.57 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 60.1 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\n\n\n\n// addons:\n// Fractal noise, based on Stefan Gustavson's Simplex noise\n".concat((0,r.N)(["vec2","vec3","vec4"],"\n  float fnoise(T p, int octaves, float persistence) {\n    float total = 0.0;           // Final noise value\n    float amplitude = 1.0;       // Initial amplitude\n    float frequency = 1.0;       // Initial frequency\n    float maxValue = 0.0;        // Used for normalization\n\n    for (int i = 0; i < octaves; i++) {\n      total += snoise(p * frequency) * amplitude;\n\n      maxValue += amplitude;   // Keep track of max amplitude\n      amplitude *= persistence; // Reduce amplitude for next octave\n      frequency *= 2.0;        // Increase frequency for next octave\n    }\n\n    // Normalize the result to stay within the range [0, 1]\n    return total / maxValue;\n  }\n"),"\n\nfloat snoiseFast4D(vec4 p) {\n  const float SCALAR = 0.01;\n  float a = SCALAR * dot(p.xy * 0.3, vec2(-127.1, 311.7));\n  float b = SCALAR * dot(p.zw * 0.8, vec2(269.5, -183.3));\n  float c = SCALAR * dot(p.wx * 6.0, vec2(23.14069, 2.665157));\n  float d = SCALAR * dot(p.zy * 1.3, vec2(-12.9898, 78.233));\n  return (snoise(vec2(a, b)) + snoise(vec2(d, c))) * 0.5;\n}\n\nfloat fnoiseFast4D(vec4 p, int octaves, float persistence) {\n  float total = 0.0;           // Final noise value\n  float amplitude = 1.0;       // Initial amplitude\n  float frequency = 1.0;       // Initial frequency\n  float maxValue = 0.0;        // Used for normalization\n\n  for (int i = 0; i < octaves; i++) {\n    total += snoiseFast4D(p * frequency) * amplitude;\n\n    maxValue += amplitude;   // Keep track of max amplitude\n    amplitude *= persistence; // Reduce amplitude for next octave\n    frequency *= 2.0;        // Increase frequency for next octave\n  }\n\n  // Normalize the result to stay within the range [0, 1]\n  return total / maxValue;\n}\n")},22899:(e,t,n)=>{"use strict";n.d(t,{I:()=>a});var r=n(65927);let i=["linear"];for(let e=1;e<=10;e++)i.push("easeIn".concat(e)),i.push("easeOut".concat(e)),i.push("easeInOut".concat(e)),i.push("easeOutIn".concat(e));let a="\n#ifndef GLSL_EASING\n#define GLSL_EASING\n\n".concat(r.S,"\n\nfloat easePow1(float x) {\n  return x;\n}\n\nfloat easePow2(float x) {\n  return x * x;\n}\n\nfloat easePow3(float x) {\n  return x * x * x;\n}\n\nfloat easePow4(float x) {\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow5(float x) {\n  float x0 = x;\n  x *= x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow6(float x) {\n  x *= x * x;\n  return x *= x;\n}\n\nfloat easePow7(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow8(float x) {\n  x *= x;\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow9(float x) {\n  x *= x * x;\n  return x *= x * x;\n}\n\nfloat easePow10(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x * x;\n  return x0 * x;\n}\n\nfloat linear(float x) {\n  return clamp01(x);\n}\n\n").concat(Array.from({length:10},(e,t)=>{let n=t+1;return"\n\nfloat easeIn".concat(n," (float x) {\n  return easePow").concat(n,"(clamp01(x));\n}\nfloat easeOut").concat(n," (float x) {\n  return 1.0 - easePow").concat(n,"(clamp01(1.0 - x));\n}\nfloat easeInOut").concat(n," (float x) {\n  return x < 0.5 \n    ? 0.5 * easePow").concat(n,"(2.0 * x) \n    : 1.0 - 0.5 * easePow").concat(n,"(2.0 * (1.0 - x));\n}\nfloat easeOutIn").concat(n," (float x) {\n  return x < 0.5\n    ? 0.5 * (1.0 - easePow").concat(n,"(1.0 - x * 2.0))\n    : 1.0 - 0.5 * (1.0 - easePow").concat(n,"(2.0 * x - 1.0));\n}\n\n").trim()}).join("\n\n"),"\n\n\n// https://www.desmos.com/calculator/mqou4lf9zc?lang=fr\nfloat easeInOut(float x, float p, float i) {\n  return  x <= 0.0 ? 0.0 :\n          x >= 1.0 ? 1.0 :\n          x <= i ? 1.0 / pow(i, p - 1.0) * pow(x, p) :\n          1.0 - 1.0 / pow(1.0 - i, p - 1.0) * pow(1.0 - x, p);\n}\n\n// https://www.desmos.com/calculator/nrjlezusdv\nfloat easeInThenOut(float x, float p) {\n  return 1.0 - pow(abs(2.0 * x - 1.0), p);\n}\n\n#endif\n")},35484:(e,t,n)=>{"use strict";n.d(t,{Client:()=>A});var r=n(70691),i=n(49797),a=n(53097),o=n(66066),s=n(15940),l=n(72598),c=n(50926),x=n(87381),p=n(22899),u=n(14203),d=new WeakSet,v=new WeakSet,h=new WeakSet,f=new WeakSet;class y extends i.YJl{*onInitialize(){yield(0,l.s)(document.body,{onDown:e=>{this.pointerState.down=!0,this.pointerState.shift=e.event.shiftKey},onUp:()=>{this.pointerState.down=!1}})}onTick(e){let{down:t,shift:n}=this.pointerState;this.uTime.value+=e.deltaTime*(t?n?.1:10:1),this.uTime2.value+=!t*e.deltaTime}constructor(){super(),(0,s._)(this,d),(0,s._)(this,v),(0,s._)(this,h),(0,s._)(this,f),this.debugHelper=(0,x.mj)(new c.u,this),this.uTime={value:0},this.uTime2={value:0},this.pointerState={down:!1,shift:!1},(0,o._)(this,v,g).call(this),(0,o._)(this,h,w).call(this),(0,o._)(this,f,z).call(this),(0,x.mj)(this,{position:[0,4,0]})}}function m(e,t){this.debugHelper.text(e,t,{size:.25,textColor:"white",backgroundColor:"black"})}function g(){let e=new i.BKk({uniforms:{uTime:this.uTime,uTime2:this.uTime2},vertexShader:"\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:"\n        ".concat(u.O,"\n        varying vec2 vUv;\n        uniform float uTime, uTime2;\n        void main() {\n          vec3 p = vec3(vUv * 10.0, uTime * 0.1) * 0.5;\n          vec3 warp = vec3(\n            fnoise(p * 0.1, 2, 0.5), \n            fnoise(p * 0.1 + 100.0, 2, 0.5), \n            fnoise(p * 0.1 - 230.1, 2, 0.5));\n          p += warp * 5.2;\n          p *= 0.5;\n          float noise = fnoise(p, 4, 0.5);\n          vec3 color = \n            mod(uTime2 * 0.5, 2.0) < 1.0\n              ? vec3(0.5 + 0.5 * noise)\n              : vec3(mod((0.5 + 0.5 * noise) * 5.0, 1.0));\n          gl_FragColor = vec4(color, 1.0);\n        }\n      ")});(0,x.mj)(new i.eaF(new i.bdM(2,2),e),{parent:this,position:[0,0,0]}),(0,o._)(this,d,m).call(this,[0,0,.666],"warp in noise3D")}function w(){let e=new i.BKk({uniforms:{uTime:this.uTime,uTime2:this.uTime2},vertexShader:"\n        varying vec2 vUv;\n        varying vec3 vWorldPosition;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n        }\n      ",fragmentShader:"\n        ".concat(u.O,"\n        ").concat(p.I,"\n\n        varying vec2 vUv;\n        varying vec3 vWorldPosition;\n        uniform float uTime, uTime2;\n\n        float remap1101(in float x) {\n          return (x + 1.0) * 0.5;\n        }\n\n        float noiseA() {\n          vec4 p = vec4(vWorldPosition * 0.5, uTime * 0.1);\n          return easeInOut(remap1101(fnoise(p, 8, 0.5)), 4.0, 0.666);\n        }\n\n        float noiseB() {\n          vec4 p = vec4(vWorldPosition * 0.5 + 100.0, uTime * 0.01);\n          return mod(remap1101(fnoise(p, 8, 0.5)) * 10.0, 1.0);\n        }\n\n        void main() {\n          float noise = mod(uTime2 * 0.5, 2.0) < 1.0\n            ? noiseA()\n            : noiseB();\n          vec3 color = vec3(noise);\n          gl_FragColor = vec4(color, 1.0);\n        }\n      ")});(0,x.mj)(new i.eaF(new i.UPV(.5,.3,256,64),e),{parent:this,position:[0,2,0]}),(0,o._)(this,d,m).call(this,[0,2,.666],"noise4D")}function z(){let e=new i.BKk({uniforms:{uTime:this.uTime,uTime2:this.uTime2},vertexShader:"\n        varying vec2 vUv;\n        varying vec3 vWorldPosition;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n        }\n      ",fragmentShader:"\n        ".concat(u.O,"\n        ").concat(p.I,"\n\n        varying vec2 vUv;\n        varying vec3 vWorldPosition;\n        uniform float uTime, uTime2;\n\n        float remap1101(in float x) {\n          return (x + 1.0) * 0.5;\n        }\n\n        float noiseA() {\n          vec4 p = vec4(vWorldPosition * 0.5, uTime * 0.1);\n          return easeInOut(remap1101(fnoiseFast4D(p, 8, 0.5)), 4.0, 0.666);\n        }\n\n        float noiseB() {\n          vec4 p = vec4(vWorldPosition * 0.5 + 100.0, uTime * 0.01);\n          return mod(remap1101(fnoiseFast4D(p, 8, 0.5)) * 10.0, 1.0);\n        }\n\n        void main() {\n          float noise = mod(uTime2 * 0.5, 2.0) < 1.0\n            ? noiseA()\n            : noiseB();\n          vec3 color = vec3(noise);\n          gl_FragColor = vec4(color, 1.0);\n        }\n      ")});(0,x.mj)(new i.eaF(new i.UPV(.5,.3,256,64),e),{parent:this,position:[2,0,0]}),(0,o._)(this,d,m).call(this,[2,0,.666],"snoiseFast4D\n(hash. 4D into noise2D)")}class b extends i.YJl{*onInitialize(e){e.scene.background=new i.Q1f("#555")}}function A(){return(0,r.jsx)("div",{className:"layer thru",children:(0,r.jsxs)(a.uB,{vertigoControls:{size:7,focus:[0,0,0]},children:[(0,r.jsx)(a.q,{value:b}),(0,r.jsx)(a.q,{value:y})]})})}},50926:(e,t,n)=>{"use strict";n.d(t,{u:()=>D,w:()=>O});var r=n(49797),i=n(96273),a=n(67840);class o{ensureKeyEntry(e,t,n){let r=this.keyMap.get(e);if(r){if(r.count!==n)throw Error("A key entry already exists with a different count. This is not allowed. Once a key is set, it cannot be changed.");return r}{let r={index:t,count:n};return this.keyMap.set(e,r),r}}applyTransform(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];throw Error("Not implemented!")}clear(){return this.keyMap.clear(),this}constructor(){this.keyMap=new Map,this.transformMatrix=new r.kn4}}var s=n(66066),l=n(15940),c=n(17953),x=n(81074),p=n(6726),u=n(60041);let d=new r.Pq0,v=new r.Pq0,h=new r.Pq0,f=new r.Pq0,y=new r.Pq0,m=new r.Pq0,g=new r.Pq0,w=new r.Q1f,z=new r.kn4;class b{static box(e){let[t,n,r,a,o,s,l,c]=b.boxPoints;if("min"in e||"max"in e){let{min:r=b.boxMinMaxDefaults.min,max:a=b.boxMinMaxDefaults.max}=e;(0,i.jj)(r,t),(0,i.jj)(a,n)}else if("center"in e||"size"in e){let{center:o=b.boxCenterSizeDefaults.center,size:s=b.boxCenterSizeDefaults.size}=e;(0,i.jj)(o,r),(0,i.jj)(s,a).multiplyScalar(.5),t.copy(r).sub(a),n.copy(r).add(a)}else t.copy(b.boxMinMaxDefaults.min),n.copy(b.boxMinMaxDefaults.max);e.inset&&(t.addScalar(e.inset),n.addScalar(-e.inset));let{x:x,y:p,z:u}=t,{x:d,y:v,z:h}=n;return n.set(d,p,u),r.set(d,p,h),a.set(x,p,h),o.set(x,v,u),s.set(d,v,u),l.set(d,v,h),c.set(x,v,h),e.transform&&((0,i.vl)(e.transform,z),t.applyMatrix4(z),n.applyMatrix4(z),r.applyMatrix4(z),a.applyMatrix4(z),o.applyMatrix4(z),s.applyMatrix4(z),l.applyMatrix4(z),c.applyMatrix4(z)),b}}b.boxPoints=[new r.Pq0,new r.Pq0,new r.Pq0,new r.Pq0,new r.Pq0,new r.Pq0,new r.Pq0,new r.Pq0],b.boxDefaults={inset:0,transform:void 0},b.boxMinMaxDefaults={min:new r.Pq0(-.5,-.5,-.5),max:new r.Pq0(.5,.5,.5)},b.boxCenterSizeDefaults={center:new r.Pq0(0,0,0),size:new r.Pq0(1,1,1)};let A={size:.1,proportionalSize:!1,position:"middle",skip:void 0,type:"single",scale:1},P={key:void 0,color:void 0,opacity:1,arrow:!1};var C=new WeakSet;class M extends o{static createParts(){let{nodeMaterial:e=!1,lineCount:t=2e4,defaultColor:n="white",defaultOpacity:i=1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},a=new r.LoY,o={position:new r.THS(new Float32Array(3*t*2),3),color:new r.THS(new Float32Array(3*t*2),3),aOpacity:new r.THS(new Float32Array(2*t),1)};for(let[e,t]of Object.entries(o))a.setAttribute(e,t);let s=e?(()=>{let e=new x.e9u({vertexColors:!0,transparent:!0,depthWrite:!1}),t=(0,c.xIr)(o.aOpacity,"float",1,0);return e.opacityNode=(0,c.PCg)(t),e})():(()=>{let e=new r.mrM({vertexColors:!0,transparent:!0,depthWrite:!1});return e.onBeforeCompile=e=>u.b.with(e).varying({vOpacity:"float"}).vertex.top("\n          attribute float aOpacity;\n        ").vertex.mainAfterAll("\n          vOpacity = aOpacity;\n        ").fragment.after("color_fragment","\n          diffuseColor.a *= vOpacity;\n        "),e})(),l=new r.DXC(a,s);return l.frustumCulled=!1,{count:t,defaults:{color:n,opacity:i},geometry:a,attributes:o,lines:l}}applyTransform(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];this.parts.geometry.applyMatrix4((0,i.GD)(t))}clear(){return super.clear(),this.state.index=0,this.parts.geometry.setDrawRange(0,0),this}onTop(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1e3,{lines:t}=this.parts;return 0!==e?(t.renderOrder=e,t.material.depthTest=!1,t.material.depthWrite=!1):(t.renderOrder=0,t.material.depthTest=!0,t.material.depthWrite=!0),this}segmentsArray(e,t){let{position:n,color:r,aOpacity:i}=this.parts.attributes,{key:a,color:o,opacity:l}={...P,...this.parts.defaults,...t},{r:c,g:x,b:p}=w.set(o),u=e.length/3,z=function(e,t){var n,r;if(!1===t||void 0===t)return new Float32Array;let i=Array.isArray(t)?t:[!0===t?{}:t],a=0;for(let e of i){let t=null!=(n=null==e?void 0:e.type)?n:A.type,i=null!=(r=null==e?void 0:e.position)?r:A.position;a+=(Array.isArray(i)?i.length:1)*("triple"===t?3:"double"===t?2:1)}let o=e.length/3/2,s=new Float32Array(o*a*12),l=0;for(let t=0;t<o;t++){let n=6*t;d.set(e[n+0],e[n+1],e[n+2]),v.set(e[n+3],e[n+4],e[n+5]),h.subVectors(v,d);let r=h.lengthSq();for(let e of i){let{size:t=A.size,proportionalSize:n=A.proportionalSize,position:i=A.position,skip:a=A.skip,type:o=A.type,scale:c=A.scale}=null!=e?e:{};if(void 0!==a){if(!0===a||"less-than-size"===a){if(r<t*t)continue}else if("number"==typeof a&&r<a*a)continue}let x=Math.sqrt(r),p=(n?x:1)*t*c;f.copy(h).divideScalar(x);let u=Math.abs(f.x),w=Math.abs(f.y),z=Math.abs(f.z);for(let e of(u>=z&&w>=z?y.set(f.y,-f.x,0).normalize():w>=u?y.set(f.z,0,-f.x).normalize():y.set(0,f.z,-f.y).normalize(),Array.isArray(i)?i:[i])){let n="triple"===o?3:"double"===o?2:1;for(let r=0;r<n;r++){let i=function(e){if("number"==typeof e)return e;switch(e){case"end":return 1;case"start":return 0;case"middle":return .5;default:throw Error("Invalid arrow position: ".concat(e))}}(e);n>1&&(i+=(r/(n-1)-i)*t/x*.8),m.lerpVectors(d,v,i),m.toArray(s,(4*l+0)*3),g.copy(m).addScaledVector(f,-p).addScaledVector(y,-p).toArray(s,(4*l+1)*3),m.toArray(s,(4*l+2)*3),g.copy(m).addScaledVector(f,-p).addScaledVector(y,p).toArray(s,(4*l+3)*3),l++}}}}return s}(e,null==t?void 0:t.arrow),b=z.length/3,M=u+b,{index:S}=void 0!==a?this.ensureKeyEntry(a,this.state.index,u):this.state;if(S+M>this.parts.count)throw console.log("Overflow Handling Not implemented",S+M,this.parts.count),Error("Overflow Handling Not implemented");this.state.index=Math.max(this.state.index,S+M);{let{transformMatrix:t}=this;for(let a=0;a<u;a++)d.fromArray(e,3*a).applyMatrix4(t).toArray(n.array,(S+a)*3),r.setXYZ(S+a,c,x,p),i.setX(S+a,l)}{let e=S+u;for(let t=0;t<b;t++)d.fromArray(z,3*t).applyMatrix4(this.transformMatrix).toArray(n.array,(e+t)*3),r.setXYZ(e+t,c,x,p),i.setX(e+t,l)}return(0,s._)(this,C,T).call(this),this}segments(e,t){let n=e.length,r=new Float32Array(3*n);for(let t=0;t<n;t++){let{x:n,y:a,z:o}=(0,i.jj)(e[t],d),s=3*t;r[s+0]=n,r[s+1]=a,r[s+2]=o}return this.segmentsArray(r,t)}line(e,t,n){return this.segments([e,t],n)}polyline(e,t){if(e.length<2)return this;let n=Array((e.length-1)*2);for(let t=1;t<e.length;t++)n[2*t-2]=e[t-1],n[2*t-1]=e[t];return this.segments(n,t)}polygon(e,t){return e.length<2||(this.polyline(e,t),this.line(e[e.length-1],e[0],t)),this}box(e,t){let[n,r,i,a,o,s,l,c]=b.box(e).boxPoints;return this.segmentsArray(new Float32Array([n.x,n.y,n.z,r.x,r.y,r.z,r.x,r.y,r.z,i.x,i.y,i.z,i.x,i.y,i.z,a.x,a.y,a.z,a.x,a.y,a.z,n.x,n.y,n.z,o.x,o.y,o.z,s.x,s.y,s.z,s.x,s.y,s.z,l.x,l.y,l.z,l.x,l.y,l.z,c.x,c.y,c.z,c.x,c.y,c.z,o.x,o.y,o.z,n.x,n.y,n.z,o.x,o.y,o.z,r.x,r.y,r.z,s.x,s.y,s.z,i.x,i.y,i.z,l.x,l.y,l.z,a.x,a.y,a.z,c.x,c.y,c.z]),t)}rect(e,t){let{minX:n,minY:r,maxX:i,maxY:a}=p.M_.from(e),{inset:o}={...M.rectDefaultOptions,...t};return n+=o,r+=o,i-=o,a-=o,this.segments([{x:n,y:r,z:0},{x:i,y:r,z:0},{x:i,y:r,z:0},{x:i,y:a,z:0},{x:i,y:a,z:0},{x:n,y:a,z:0},{x:n,y:a,z:0},{x:n,y:r,z:0}],t)}circle(){let{center:e=0,axis:t="z",radius:n=1,quality:r="medium",segments:a}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},o=arguments.length>1?arguments[1]:void 0;null!=a||(a=M.circleQualityPresets[r]);let{x:s,y:l,z:c}=(0,i.jj)(e,d);(0,i.jj)(t,d).normalize(),v.set(d.y,d.z,d.x).cross(d).normalize(),h.crossVectors(d,v);let x=new Float32Array(3*a*2);for(let e=0;e<a;e++){let t=e/a*Math.PI*2,r=(e+1)/a*Math.PI*2,i=Math.cos(t)*n,o=Math.sin(t)*n,p=Math.cos(r)*n,u=Math.sin(r)*n,d=6*e;x[d+0]=s+i*v.x+o*h.x,x[d+1]=l+i*v.y+o*h.y,x[d+2]=c+i*v.z+o*h.z,x[d+3]=s+p*v.x+u*h.x,x[d+4]=l+p*v.y+u*h.y,x[d+5]=c+p*v.z+u*h.z}return this.segmentsArray(x,o),this}regularGrid(e){let{color:t,opacity:n,plane:r,size:i,subdivisions:a}={...M.regularGridDefaults,...e},o=a.length,l=a.map((e,t)=>a.slice(t).reduce((e,t)=>e*t,1)),c=l[0],x=new Float32Array((c+1)*12),p=new Float32Array((c+1)*12).fill(1),u=new Float32Array((c+1)*4).fill(1),d=Array.isArray(t)?t:[t],v=a.map((e,t)=>{let{r:n,g:r,b:i}=w.set(d[Math.min(t,d.length-1)]);return[n,r,i]}),h=Array.isArray(n)?n:[n],f=a.map((e,t)=>h[Math.min(t,h.length-1)]);for(let e=0;e<=c;e++){let t=o-1;for(;e%l[t]==0&&!(--t<=0););let[n,r,a]=v[t],s=f[t],d=e/c*i,h=12*e;x[h+0]=-i/2,x[h+1]=-i/2+d,x[h+2]=0,x[h+3]=i/2,x[h+4]=-i/2+d,x[h+5]=0,x[h+6]=-i/2+d,x[h+7]=-i/2,x[h+8]=0,x[h+9]=-i/2+d,x[h+10]=i/2,x[h+11]=0,p[h+0]=n,p[h+1]=r,p[h+2]=a,p[h+3]=n,p[h+4]=r,p[h+5]=a,p[h+6]=n,p[h+7]=r,p[h+8]=a,p[h+9]=n,p[h+10]=r,p[h+11]=a;let y=4*e;u[y+0]=s,u[y+1]=s,u[y+2]=s,u[y+3]=s}if("xz"===r)for(let e=0;e<x.length;e+=3)x[e+2]=x[e+1],x[e+1]=0;else if("yz"===r)for(let e=0;e<x.length;e+=3)x[e+2]=x[e+1],x[e+1]=x[e+0],x[e+0]=0;let{index:y}=this.state;return this.parts.attributes.position.array.set(x,3*y),this.parts.attributes.color.array.set(p,3*y),this.parts.attributes.aOpacity.array.set(u,y),this.state.index+=(c+1)*4,(0,s._)(this,C,T).call(this),this}constructor(e){super(),(0,l._)(this,C),this.state={index:0},this.parts=M.createParts(e)}}function T(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];for(let e of(this.parts.geometry.setDrawRange(0,this.state.index),Object.values(this.parts.attributes)))e.needsUpdate=!0;if(this.state.index>2*this.parts.count)throw Error("Not implemented!");if(e)for(let e of Object.values(this.parts.attributes))e.array.some(e=>isNaN(e))&&console.log(e.array.findIndex(e=>isNaN(e)))}M.rectDefaultOptions={inset:0},M.circleQualityPresets={low:18,medium:36,high:64,ultra:256},M.regularGridDefaults={plane:"xy",size:100,subdivisions:[10,2,5],opacity:[.2,.05,.01],color:"white"};class S extends o{static createParts(){let{pointCount:e=1e4}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=new r.LoY,n={position:new r.THS(new Float32Array(3*e),3),color:new r.THS(new Float32Array(3*e),3),aScale:new r.THS(new Float32Array(e),1),aShape:new r.THS(new Float32Array(e),1)};for(let[e,r]of Object.entries(n))t.setAttribute(e,r);let i=new r.BH$({vertexColors:!0});i.onBeforeCompile=e=>u.b.with(e).varying({vShape:"float"}).vertex.top("\n        attribute float aScale;\n        attribute float aShape;\n      ").vertex.mainAfterAll("\n        gl_PointSize *= aScale;\n        vShape = aShape;\n      ").fragment.top("\n        float sdBox(in vec2 p, in vec2 b) {\n          vec2 d = abs(p) - b;\n          return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n        }\n      ").fragment.after("color_fragment","\n        float regular = .2;\n        float thin = .1;\n        float ultraThin = .033;\n\n        if (vShape == ".concat(S.shapes.circle,".0) {\n          float d = distance(gl_PointCoord * 2.0, vec2(1.0));\n          if (d > 1.0) discard;\n        }\n\n        if (vShape == ").concat(S.shapes.ring,".0) {\n          float d = distance(gl_PointCoord * 2.0, vec2(1.0));\n          if (d < 0.8 || d > 1.0) discard;\n        }\n\n        if (vShape == ").concat(S.shapes["ring-thin"],".0) {\n          float d = distance(gl_PointCoord * 2.0, vec2(1.0));\n          if (d < 0.9 || d > 1.0) discard;\n        }\n\n        else if (vShape == ").concat(S.shapes.plus,".0) {\n          float d0 = sdBox(gl_PointCoord * 2.0 - 1.0, vec2(1.0, regular));\n          float d1 = sdBox(gl_PointCoord * 2.0 - 1.0, vec2(regular, 1.0));\n          if (d0 > 0.0 && d1 > 0.0) discard;\n        }\n\n        else if (vShape == ").concat(S.shapes["plus-thin"],".0) {\n          float d0 = sdBox(gl_PointCoord * 2.0 - 1.0, vec2(1.0, thin));\n          float d1 = sdBox(gl_PointCoord * 2.0 - 1.0, vec2(thin, 1.0));\n          if (d0 > 0.0 && d1 > 0.0) discard;\n        }\n\n        else if (vShape == ").concat(S.shapes["plus-ultra-thin"],".0) {\n          float d0 = sdBox(gl_PointCoord * 2.0 - 1.0, vec2(1.0, ultraThin));\n          float d1 = sdBox(gl_PointCoord * 2.0 - 1.0, vec2(ultraThin, 1.0));\n          if (d0 > 0.0 && d1 > 0.0) discard;\n        }\n\n        else if (vShape == ").concat(S.shapes.x,".0) {\n          vec2 p = gl_PointCoord * 2.0 - 1.0;\n          float c = 0.70710678;\n          p = mat2(c, -c, c, c) * p;\n          float d0 = sdBox(p, vec2(1.0, regular));\n          float d1 = sdBox(p, vec2(regular, 1.0));\n          if (d0 > 0.0 && d1 > 0.0) discard;\n        }\n\n        else if (vShape == ").concat(S.shapes["x-thin"],".0) {\n          vec2 p = gl_PointCoord * 2.0 - 1.0;\n          float c = 0.70710678;\n          p = mat2(c, -c, c, c) * p;\n          float d0 = sdBox(p, vec2(1.0, thin));\n          float d1 = sdBox(p, vec2(thin, 1.0));\n          if (d0 > 0.0 && d1 > 0.0) discard;\n        }\n\n        else if (vShape == ").concat(S.shapes["x-ultra-thin"],".0) {\n          vec2 p = gl_PointCoord * 2.0 - 1.0;\n          float c = 0.70710678;\n          p = mat2(c, -c, c, c) * p;\n          float d0 = sdBox(p, vec2(1.0, ultraThin));\n          float d1 = sdBox(p, vec2(ultraThin, 1.0));\n          if (d0 > 0.0 && d1 > 0.0) discard;\n        }\n\n        // diffuseColor.rgb *= vec3(gl_PointCoord, 1.0);\n      "));let a=new r.ONl(t,i);return a.frustumCulled=!1,{count:e,geometry:t,attributes:n,points:a}}applyTransform(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];this.parts.geometry.applyMatrix4((0,i.GD)(t))}clear(){return super.clear(),this.state.index=0,this.parts.geometry.setDrawRange(0,0),this}onTop(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1e3,{points:t}=this.parts;return 0!==e?(t.renderOrder=e,t.material.depthTest=!1,t.material.depthWrite=!1,t.material.transparent=!0):(t.renderOrder=0,t.material.depthTest=!0,t.material.depthWrite=!0,t.material.transparent=!1),this}points(e){let{key:t,size:n=.1,scale:r=1,color:a="white",shape:o="square"}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{transformMatrix:s}=this,l=void 0!==t,c=e.length,{index:x}=l?this.ensureKeyEntry(t,this.state.index,c):this.state,{position:p,color:u,aScale:v,aShape:h}=this.parts.attributes,{r:f,g:y,b:m}=w.set(a),g=r*n,z=S.shapes[o];for(let t=0;t<c;t++){let{x:n,y:r,z:a}=(0,i.jj)(e[t],d).applyMatrix4(s),o=x+t;p.setXYZ(o,n,r,a),u.setXYZ(o,f,y,m),v.setX(o,g),h.setX(o,z)}for(let e of(this.state.index=l?Math.max(this.state.index,x+c):x+c,this.parts.geometry.setDrawRange(0,this.state.index),Object.values(this.parts.attributes)))e.needsUpdate=!0;if(this.state.index>this.parts.count)throw Error("Overflow Handling Not implemented");return this}box(e,t){let{boxPoints:n}=b.box(e);return this.points(n,t)}point(e,t){return this.points([e],t)}constructor(e){super(),this.state={index:0},this.parts=S.createParts(e)}}S.shapes=(()=>{let e=0;return{square:e++,circle:e++,ring:e++,"ring-thin":e++,plus:e++,"plus-thin":e++,"plus-ultra-thin":e++,x:e++,"x-thin":e++,"x-ultra-thin":e++}})();class j extends o{static createParts(e){let t=new a.w({textCount:2e3,...e});return{count:t.count,textHelper:t}}applyTransform(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];this.parts.textHelper.applyTransform(...t)}clear(){return this.state.index=0,this.parts.textHelper.clearAllText(),this}onTop(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1e3;return this.parts.textHelper.onTop(e),this}texts(e,t){let n=this.state.index,{texts:r,...a}={...j.textDefaults,...t},o="function"==typeof r?r:e=>r[e%r.length],s=0;for(let t of e){let{x:e,y:r,z:l}=(0,i.jj)(t,d);this.parts.textHelper.setTextAt(n,o(s),{...a,x:e,y:r,z:l}),n++,s++}return this.state.index=n,this}text(e,t,n){return this.texts([e],{...n,texts:[t]})}textAt(e,t,n){return this.parts.textHelper.setTextAt(e,t,{...n}),this}constructor(e){super(),this.state={index:0},this.parts=j.createParts(e)}}j.textDefaults={texts:e=>e.toString()};let _={color:void 0,size:.1,shape:"square",scale:1};class D extends r.YJl{static createParts(e,t){let{nodeMaterial:n}=null!=t?t:{},r=new S(null==t?void 0:t.points);e.add(r.parts.points);let i=new M({nodeMaterial:n,...null==t?void 0:t.lines});e.add(i.parts.lines);let a=new j({nodeMaterial:n,...null==t?void 0:t.texts});return e.add(a.parts.textHelper),{pointsManager:r,linesManager:i,textsManager:a}}points(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.parts.pointsManager.points(...t),this}point(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.parts.pointsManager.point(...t),this}segments(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.parts.linesManager.segments(...t),this}line(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.parts.linesManager.line(...t),this}polyline(e,t){return this.parts.linesManager.polyline(e,t),(null==t?void 0:t.points)&&this.points(e,{..._,color:t.color,...!0===t.points?{}:t.points}),this}polylines(e,t){for(let n of e)this.polyline(n,t);return this}polygon(e,t){return this.parts.linesManager.polygon(e,t),(null==t?void 0:t.points)&&this.points(e,{..._,color:t.color,...!0===t.points?{}:t.points}),this}polygons(e,t){for(let n of e)this.polygon(n,t);return this}box(e,t){return this.parts.linesManager.box(e,t),(null==t?void 0:t.points)&&this.parts.pointsManager.box(e,{..._,color:t.color,...!0===t.points?{}:t.points}),this}circle(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.parts.linesManager.circle(...t),this}rect(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.parts.linesManager.rect(...t),this}regularGrid(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.parts.linesManager.regularGrid(...t),this}texts(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.parts.textsManager.texts(...t),this}text(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.parts.textsManager.text(...t),this}textAt(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.parts.textsManager.textAt(...t),this}applyTransform(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.parts.pointsManager.applyTransform(...t),this.parts.linesManager.applyTransform(...t),this.parts.textsManager.applyTransform(...t),this}clear(){return this.parts.pointsManager.clear(),this.parts.linesManager.clear(),this.parts.textsManager.clear(),this}onTop(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1e3;return this.renderOrder=e,this.parts.pointsManager.onTop(e),this.parts.linesManager.onTop(e),this.parts.textsManager.onTop(e),this}globalExpose(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"debugHelper";return Object.assign(globalThis,{[e]:this}),this}addTo(e){return e?e.add(this):this.removeFromParent(),this}constructor(e){super(),this.userData={helper:!0},this.parts=D.createParts(this,e)}}let O=new D},65927:(e,t,n)=>{"use strict";n.d(t,{S:()=>r});let r="\n#ifndef GLSL_BASIC\n#define GLSL_BASIC\n\nfloat clamp01(float x) {\n  return x < 0.0 ? 0.0 : x > 1.0 ? 1.0 : x;\n}\n\n#endif\n"},77565:(e,t,n)=>{Promise.resolve().then(n.bind(n,35484))},95736:(e,t,n)=>{"use strict";function r(e,t){return"*"===t||("string"==typeof t?t===e:t instanceof RegExp?t.test(e):"function"==typeof t&&t(e))}n.d(t,{a:()=>s});let i={preventDefault:!1,strictTarget:void 0},a={key:"*",keyCaseInsensitive:!0,code:"*",noModifiers:!1,modifiers:"",phase:"down"},o=0;function s(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];let s=o++,[l,c,x]=1===t.length?[document.body,{},t[0]]:2===t.length?[t[0],{},t[1]]:t,{preventDefault:p}={...i,...c},u=null,d=e=>{var t;if((null!=(t=c.strictTarget)?!!t:l===document.body)&&e.target!==l)return;"keydown"===e.type&&(u=e);let{ctrlKey:n=!1,altKey:i=!1,shiftKey:o=!1,metaKey:d=!1}=null!=u?u:{},v={id:s,event:e,downEvent:u,modifiers:{ctrl:n,alt:i,shift:o,meta:d}};for(let t=0,s=x.length;t<s;t++){let[s,l]=x[t],{key:c,keyCaseInsensitive:h,code:f,noModifiers:y,modifiers:m,phase:g="down"}=function(e){let t="string"==typeof e?{...a,key:e}:{...a,...e};return t.keyCaseInsensitive&&"string"==typeof t.key&&(t.key=t.key.toLowerCase()),t}(s);switch(e.type){case"keydown":if("down"!==g)continue;break;case"keyup":if("up"!==g)continue}Object.values({key:r(h?e.key.toLowerCase():e.key,c),code:r(e.code,f),noModifiers:!y||!1===n&&!1===i&&!1===o&&!1===d,modifiers:function(e,t){let{ctrlKey:n,altKey:r,shiftKey:i,metaKey:a}=e;if("function"==typeof t)return t({ctrl:n,alt:r,shift:i,meta:a});let{ctrl:o=!1,alt:s=!1,shift:l=!1,meta:c=!1}=Object.fromEntries(t.split("-").map(e=>[e,!0]));return o===n&&s===r&&l===i&&c===a}(u,m)}).every(Boolean)&&(p&&e.preventDefault(),l(v))}};return l.addEventListener("keydown",d,{passive:!1}),l.addEventListener("keyup",d,{passive:!1}),{destroy:()=>{l.removeEventListener("keydown",d),l.removeEventListener("keyup",d)}}}}},e=>{var t=t=>e(e.s=t);e.O(0,[5611,7190,6564,7223,9635,8921,4957,7775,6814,7953,4638,6726,2598,1213,9673,8083,7112,41,7840,3097,1319,6852,7358],()=>t(77565)),_N_E=e.O()}]);