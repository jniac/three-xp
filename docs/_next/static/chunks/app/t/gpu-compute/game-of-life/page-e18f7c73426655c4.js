(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7396],{1029:(e,n,t)=>{"use strict";t.d(n,{N:()=>r});let a={vecX:["float","vec2","vec3","vec4"]},r=(e,n)=>{let t=[],r=Array.isArray(e)?e:[e].map(e=>e in a?a[e]:e).flat();if("function"==typeof n)for(let e of r)t.push(n(e).replaceAll(/\bT\b/g,e));else for(let e of r)t.push(n.replaceAll(/\bT\b/g,e));return t.join("\n")}},8144:(e,n,t)=>{"use strict";t.d(n,{H:()=>u});var a=t(65927),r=t(1029);let u="\n".concat(a.S,"\n\n#ifndef GLSL_UTILS\n#define GLSL_UTILS\n\nfloat sin01(float x) {\n  return 0.5 + 0.5 * sin(x * 6.283185307179586);\n}\n\nvec2 scaleAround(vec2 p, vec2 c, float s) {\n  return c + (p - c) / s;\n}\n\n// Same as mix, but clamped.\n").concat((0,r.N)("vecX","\n  T lerp(in T a, in T b, in float x) {\n    return mix(a, b, clamp01(x));\n  }\n"),"\n\nfloat inverseLerpUnclamped(in float a, in float b, float x) {\n  return (x - a) / (b - a);\n}\n\nfloat inverseLerp(in float a, in float b, float x) {\n  return clamp01((x - a) / (b - a));\n}\n\nfloat remap(in float x, in float a, in float b, in float c, in float d) {\n  return c + (d - c) * inverseLerp(a, b, x);\n}\n\n// Remap from [-1, 1] to [0, 1]\nfloat remap1101(in float x) {\n  return clamp01(0.5 + 0.5 * x);\n}\n\n").concat((0,r.N)("vecX","\n  T oneMinus(in T x) {\n    return 1.0 - x;\n  }\n"),"\n\n// Returns x^p, but handles negative x values correctly.\nfloat spow(in float x, in float p) {\n  return x >= 0.0 ? pow(x, p) : -pow(-x, p);\n}\n\nfloat threshold(in float x, in float thresholdValue) {\n  return x < thresholdValue ? 0. : 1.;\n}\n\nfloat threshold(in float x, in float thresholdValue, in float width) {\n  return width < 1e-9 \n    ? (x < thresholdValue ? 0. : 1.)\n    : clamp01((x - thresholdValue + width * .5) / width);\n}\n\nmat3 extractRotation(mat4 matrix) {\n  return mat3(matrix[0].xyz, matrix[1].xyz, matrix[2].xyz);\n}\n\nvec2 rotate(vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  float x = c * p.x + s * p.y;\n  float y = -s * p.x + c * p.y;\n  return vec2(x, y);\n}\n\nvec2 rotateAround(vec2 p, float a, vec2 c) {\n  return c + rotate(p - c, a);\n}\n\nvec2 rotateScaleAround(vec2 p, float a, float s, vec2 c) {\n  return c + rotate((p - c) / s, a);\n}\n\nfloat positiveModulo(float x) {\n  x = mod(x, 1.0);\n  return x < 0.0 ? x + 1.0 : x;\n}\n\n// Modulo that keeps the result in the range [0, modulo]\nfloat positiveModulo(float x, float modulo) {\n  x = mod(x, modulo);\n  return x < 0.0 ? x + modulo : x;\n}\n\n// Modulo that keeps the result in the range [-m/2, m/2]\nfloat middleModulo(float x, float modulo) {\n  x = mod(x, modulo);\n  return x < -modulo / 2.0 ? x + modulo : x > modulo / 2.0 ? x - modulo : x;\n}\n\n// Limit a value to a maximum that the function tends to reach when x -> âˆž\n// https://www.desmos.com/calculator/0vewkbnscu\nfloat limited(float x, float maxValue) {\n  return x <= 0.0 ? x : maxValue * x / (maxValue + x);\n}\n\n// https://www.desmos.com/calculator/0vewkbnscu\nfloat limited(float x, float minValue, float maxValue) {\n  float d = maxValue - minValue;\n  float xd = x - minValue;\n  return x <= minValue ? x : minValue + d * xd / (d + xd);\n}\n\nfloat sqLength(in vec2 p) {\n  return p.x * p.x + p.y * p.y;\n}\n\nfloat sqLength(in vec3 p) {\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\nfloat pcurve(float x, float a, float b) {\n  float k = pow(a + b, a + b) / (pow(a, a) * pow(b, b));\n  return k * pow(x, a) * pow(1.0 - x, b);\n}\n\nfloat hash(float p) {\n  return fract(sin(p * 12.9898) * 43758.5453);\n}\n\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat hash(vec3 p) {\n  return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n}\n\nfloat hash(vec4 p) {\n  return fract(sin(dot(p, vec4(12.9898, 78.233, 45.164, 94.673))) * 43758.5453);\n}\n\nvec2 hash2(float p) {\n  return vec2(hash(p), hash(p + 1.0));\n}\n\nvec2 hash2(vec2 p) {\n  return vec2(hash(p.x), hash(p.y));\n}\n\nvec2 hash2(vec3 p) {\n  return vec2(hash(p.xy), hash(p.yz));\n}\n\nvec2 hash2(vec4 p) {\n  return vec2(hash(p.xyz), hash(p.yzw));\n}\n\nvec3 hash3(float p) {\n  return vec3(hash2(p),  hash(p + 2.0));\n}\n\nvec3 hash3(vec2 p) {\n  return vec3(hash2(p), hash(p));\n}\n\nvec3 hash3(vec3 p) {\n  return vec3(hash(p.x), hash(p.y), hash(p.z));\n}\n\nvec3 hash3(vec4 p) {\n  return vec3(hash(p.xy), hash(p.yz), hash(p.zw));\n}\n\nfloat hash_alt(float p) {\n  return fract(sin(p * 127.1) * 311.7);\n}\n\nfloat hash_alt(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 269.5);\n}\n\nfloat hash_alt(vec3 p) {\n  return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 269.5);\n}\n\nfloat hash_alt(vec4 p) {\n  return fract(sin(dot(p, vec4(127.1, 311.7, 74.7, 113.5))) * 269.5);\n}\n\n").concat((0,r.N)("vecX","\n  T min3(in T a, in T b, in T c) {\n    return min(min(a, b), c);\n  }\n"),"\n\n").concat((0,r.N)("vecX","\n  T min4(in T a, in T b, in T c, in T d) {\n    return min(min(a, b), min(c, d));\n  }\n"),"\n\n#endif // GLSL_UTILS\n")},26604:(e,n,t)=>{"use strict";t.d(n,{W:()=>r});var a=t(64089);class r extends a.q{constructor(e){super(e),this.shaders({initial:{fragmentColor:"\n          vec2 uv = vUv;\n          float r = step(0.6, hash(uv));\n          float g = step(0.6, hash(uv + vec2(1.0, 0.0)));\n          float b = step(0.6, hash(uv + vec2(0.0, 1.0)));\n          gl_FragColor = vec4(r, g, b, 1.0);\n        "},update:{fragmentTop:"\n          // Conway's Game of Life rules\n          float gameOfLife(float current, float sum) {\n            if (current > 0.5) {\n              if (sum < 1.5 || sum > 3.5) {\n                return 0.0; // Cell dies\n              } else {\n                return 1.0; // Cell lives\n              }\n            } else {\n              if (sum == 3.0) {\n                return 1.0; // Cell becomes alive\n              }\n            }\n            return current;\n          }\n          ",fragmentColor:'\n          vec2 uv = vUv;\n          vec2 uv0 = uv + vec2(0.0, 1.0) / uTextureSize;\n          vec2 uv1 = uv + vec2(1.0, 1.0) / uTextureSize;\n          vec2 uv2 = uv + vec2(1.0, 0.0) / uTextureSize;\n          vec2 uv3 = uv + vec2(1.0, -1.0) / uTextureSize;\n          vec2 uv4 = uv + vec2(0.0, -1.0) / uTextureSize;\n          vec2 uv5 = uv + vec2(-1.0, -1.0) / uTextureSize;\n          vec2 uv6 = uv + vec2(-1.0, 0.0) / uTextureSize;\n          vec2 uv7 = uv + vec2(-1.0, 1.0) / uTextureSize;\n          vec3 sum =\n            texture2D(uTexture, uv0).rgb +\n            texture2D(uTexture, uv1).rgb +\n            texture2D(uTexture, uv2).rgb +\n            texture2D(uTexture, uv3).rgb +\n            texture2D(uTexture, uv4).rgb +\n            texture2D(uTexture, uv5).rgb +\n            texture2D(uTexture, uv6).rgb +\n            texture2D(uTexture, uv7).rgb;\n    \n          vec3 current = texture2D(uTexture, uv).rgb;\n          vec3 next = vec3(\n            gameOfLife(current.r, sum.r),\n            gameOfLife(current.g, sum.g),\n            gameOfLife(current.b, sum.b));\n          \n          // Add some random "glitches" based on time and position\n          vec3 uvt = vec3(uv, uTime);\n          vec3 extra = vec3(\n            step(0.995, hash(uvt.xyz)), \n            step(0.995, hash(uvt.yzx)), \n            step(0.995, hash(uvt.zxy)));\n    \n          gl_FragColor.rgb = max(next, extra);\n        '}})}}},44229:(e,n,t)=>{"use strict";t.d(n,{PageClient:()=>f});var a=t(70691),r=t(49797),u=t(99332),o=t(53097),l=t(26604),i=t(79911),c=t(36508);function s(){let e=(0,o.Fw)();return(0,o.dB)("my-scene",function*(n){let t=(0,i.mj)(new r.eaF(new r.bdM,new r.V9B),n);t.scale.setScalar(10);let a=new l.W({size:256}).initialize(e.renderer),o=!0;yield(0,c.xy)("three",e=>{t.material.map=a.currentTexture(),o&&a.update(e.deltaTime)}),yield(0,u.s)(document.body,{onTap:()=>{o=!o}})},[]),null}function f(){return(0,a.jsxs)(o.uB,{vertigoControls:{size:10,eventTarget:"canvas"},children:[(0,a.jsx)("div",{className:"layer thru flex flex-col p-12",children:(0,a.jsx)("h1",{className:"text-4xl font-bold",children:"GPU Compute - Game of Life"})}),(0,a.jsx)(s,{})]})}},55289:(e,n,t)=>{Promise.resolve().then(t.bind(t,44229))},64089:(e,n,t)=>{"use strict";t.d(n,{q:()=>m});var a=t(28535),r=t(76999),u=t(57368),o=t(49797),l=t(93432),i=t(8144),c=t(96122);let s=[3,5,7,9,11].map(e=>(function(e,n){let t=function(e,n){if(e%2==0)throw Error("Kernel size must be odd");let t=Math.floor(e/2);null!=n||(n=e/3);let a=2*n*n,r=[],u=0;for(let e=-t;e<=t;e++)for(let n=-t;n<=t;n++){let t=Math.exp(-(n*n+e*e)/a);r.push(t),u+=t}for(let e=0;e<r.length;e++)r[e]/=u;return r}(e,void 0),a=[];for(let n=0;n<e;n++){let r=t.slice(n*e,(n+1)*e).map(e=>"  ".concat(e.toFixed(5))).join(", ");a.push(r)}let r="kernel".concat(e,"x").concat(e),u="const float[".concat(e*e,"] ").concat(r," = float[").concat(e*e,"](\n").concat(a.join(",\n"),");"),o=Math.floor(e/2);return u+"\n\n"+(0,c.T)("\n    vec4 gaussianBlur".concat(e,"x").concat(e,"(vec2 uv) {\n      vec2 texelSize = 1.0 / uTextureSize;\n      vec4 color = vec4(0.0);\n      for (int x = -").concat(o,"; x <= ").concat(o,"; x++) {\n        for (int y = -").concat(o,"; y <= ").concat(o,"; y++) {\n          vec2 offset = vec2(float(x), float(y)) * texelSize;\n          color += texture2D(uTexture, uv + offset) * ").concat(r,"[x + ").concat(o," + (y + ").concat(o,") * ").concat(e,"];\n        }\n      }\n      return color;\n    }\n  "))})(e)).join("\n\n"),f={fragmentTop:"",fragmentColor:"\n    gl_FragColor = vec4(vUv, 1., 1.);\n  ",texture:null,uniforms:{}};class v extends o.BKk{constructor(e){let n={...f,...e},t={...{uTexture:{value:null},uTextureSize:{value:new o.I9Y},uTime:{value:0},uDeltaTime:{value:0}},...n.uniforms};t.uTexture.value=n.texture,super({uniforms:t,vertexShader:"\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = vec4(position, 1.);\n        }\n      ",fragmentShader:"\n        ".concat(i.H,"\n        varying vec2 vUv;\n        uniform sampler2D uTexture;\n        uniform vec2 uTextureSize;\n        uniform float uTime;\n        uniform float uDeltaTime;\n        ").concat(Object.entries(n.uniforms).map(e=>{let[n,{value:t}]=e,a=function(e){if("number"==typeof e)return"float";if(e instanceof o.I9Y)return"vec2";if(e instanceof o.Pq0)return"vec3";if(e instanceof o.IUQ)return"vec4";if(e instanceof o.Q1f)return"vec3";if(e instanceof o.gPd)return"sampler2D";throw Error("GpuCompute: cannot infer uniform type for value: ".concat(e))}(t);return"uniform ".concat(a," ").concat(n,";")}).join("\n"),"\n        ").concat(n.fragmentTop,"\n        ").concat(s,"\n        void main() {\n          ").concat(n.fragmentColor,"\n        }\n      ")}),this.uniforms=t}}let h={size:1024,type:o.ix0};var x=new WeakMap;class m{get initialized(){return!!(0,a._)(this,x)}get uniforms(){if(!this.state.updateMaterial)throw Error("GpuCompute: shaders not set");return this.state.updateMaterial.uniforms}shaders(e){return this.state.initialMaterial=new v(e.initial),this.state.updateMaterial=new v(e.update),this}initialize(e){let{orthoCamera:n,plane:t}=this.parts,{rta:a}=this.state;(0,u._)(this,x,{renderer:e});let{initialMaterial:r}=this.state;return r&&(r.uniforms.uTextureSize.value.copy(this.state.size),r.uniforms.uTexture.value=null,r.uniforms.uTime.value=0,r.uniforms.uDeltaTime.value=0,t.material=r),e.setRenderTarget(a),e.render(t,n),e.setRenderTarget(null),this.state.frame=0,this}update(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;if(!(0,a._)(this,x))throw Error("GpuCompute: not initialized");let{renderer:n}=(0,a._)(this,x),{orthoCamera:t,plane:r}=this.parts,{rta:u,rtb:o,time:l,frame:i,updateMaterial:c}=this.state;return this.state.time+=e,c&&(c.uniforms.uTextureSize.value.copy(this.state.size),c.uniforms.uTexture.value=i%2==0?u.texture:o.texture,c.uniforms.uTime.value=l,c.uniforms.uDeltaTime.value=e,r.material=c),n.setRenderTarget(i%2==0?o:u),n.render(r,t),n.setRenderTarget(null),this.state.frame+=1,this}currentTexture(){return this.state.frame%2==0?this.state.rta.texture:this.state.rtb.texture}constructor(e){(0,r._)(this,x,{writable:!0,value:void 0}),this.parts={orthoCamera:new o.qUd(-1,1,1,-1,0,1),plane:new o.eaF(new o.bdM(2,2),void 0)};let n={...h,...e};this.params=n;let{type:t}=n,a=(0,l.wX)(n.size),u=new o.nWS(a.width,a.height,{minFilter:o.hxR,magFilter:o.hxR,format:o.GWd,type:t}),i=new o.nWS(a.width,a.height,{minFilter:o.hxR,magFilter:o.hxR,format:o.GWd,type:t});this.state={size:a,rta:u,rtb:i,time:0,frame:0}}}},65927:(e,n,t)=>{"use strict";t.d(n,{S:()=>a});let a="\n#ifndef GLSL_BASIC\n#define GLSL_BASIC\n\nfloat clamp01(float x) {\n  return x < 0.0 ? 0.0 : x > 1.0 ? 1.0 : x;\n}\n\n#endif\n"},66620:(e,n,t)=>{"use strict";t.d(n,{_:()=>u});var a=t(89868),r=t(44138);function u(e,n){var t=(0,r._)(e,n,"update");return(0,a._)(e,t)}},96122:(e,n,t)=>{"use strict";function a(e){let n=e.split("\n"),t=0;for(let e of n){let n=e.match(/^(\s*)\S/);if(n){t=n[1].length;break}}return n.map(e=>e.slice(Math.min(e.length,t))).join("\n")}t.d(n,{T:()=>a})}},e=>{var n=n=>e(e.s=n);e.O(0,[5611,7190,6564,7962,9635,8921,7953,4512,7775,7436,146,6726,3445,9332,3414,9717,1763,2143,3097,1319,6852,7358],()=>n(55289)),_N_E=e.O()}]);