"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4722],{1029:(n,t,e)=>{e.d(t,{N:()=>r});let a={vecX:["float","vec2","vec3","vec4"]},r=(n,t)=>{let e=[],r=Array.isArray(n)?n:[n].map(n=>n in a?a[n]:n).flat();if("function"==typeof t)for(let n of r)e.push(t(n).replaceAll(/\bT\b/g,n));else for(let n of r)e.push(t.replaceAll(/\bT\b/g,n));return e.join("\n")}},8144:(n,t,e)=>{e.d(t,{H:()=>o});var a=e(65927),r=e(1029);let o="\n".concat(a.S,"\n\n#ifndef GLSL_UTILS\n#define GLSL_UTILS\n\nfloat sin01(float x) {\n  return 0.5 + 0.5 * sin(x * 6.283185307179586);\n}\n\nvec2 scaleAround(vec2 p, vec2 c, float s) {\n  return c + (p - c) / s;\n}\n\n// Same as mix, but clamped.\n").concat((0,r.N)("vecX","\n  T lerp(in T a, in T b, in float x) {\n    return mix(a, b, clamp01(x));\n  }\n"),"\n\nfloat inverseLerpUnclamped(in float a, in float b, float x) {\n  return (x - a) / (b - a);\n}\n\nfloat inverseLerp(in float a, in float b, float x) {\n  return clamp01((x - a) / (b - a));\n}\n\nfloat remap(in float x, in float a, in float b, in float c, in float d) {\n  return c + (d - c) * inverseLerp(a, b, x);\n}\n\n// Remap from [-1, 1] to [0, 1]\nfloat remap1101(in float x) {\n  return clamp01(0.5 + 0.5 * x);\n}\n\n").concat((0,r.N)("vecX","\n  T oneMinus(in T x) {\n    return 1.0 - x;\n  }\n"),"\n\n// Returns x^p, but handles negative x values correctly.\nfloat spow(in float x, in float p) {\n  return x >= 0.0 ? pow(x, p) : -pow(-x, p);\n}\n\nfloat threshold(in float x, in float thresholdValue) {\n  return x < thresholdValue ? 0. : 1.;\n}\n\nfloat threshold(in float x, in float thresholdValue, in float width) {\n  return width < 1e-9 \n    ? (x < thresholdValue ? 0. : 1.)\n    : clamp01((x - thresholdValue + width * .5) / width);\n}\n\nmat3 extractRotation(mat4 matrix) {\n  return mat3(matrix[0].xyz, matrix[1].xyz, matrix[2].xyz);\n}\n\nvec2 rotate(vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  float x = c * p.x + s * p.y;\n  float y = -s * p.x + c * p.y;\n  return vec2(x, y);\n}\n\nvec2 rotateAround(vec2 p, float a, vec2 c) {\n  return c + rotate(p - c, a);\n}\n\nvec2 rotateScaleAround(vec2 p, float a, float s, vec2 c) {\n  return c + rotate((p - c) / s, a);\n}\n\nfloat positiveModulo(float x) {\n  x = mod(x, 1.0);\n  return x < 0.0 ? x + 1.0 : x;\n}\n\n// Modulo that keeps the result in the range [0, modulo]\nfloat positiveModulo(float x, float modulo) {\n  x = mod(x, modulo);\n  return x < 0.0 ? x + modulo : x;\n}\n\n// Modulo that keeps the result in the range [-m/2, m/2]\nfloat middleModulo(float x, float modulo) {\n  x = mod(x, modulo);\n  return x < -modulo / 2.0 ? x + modulo : x > modulo / 2.0 ? x - modulo : x;\n}\n\n// Limit a value to a maximum that the function tends to reach when x -> âˆž\n// https://www.desmos.com/calculator/0vewkbnscu\nfloat limited(float x, float maxValue) {\n  return x <= 0.0 ? x : maxValue * x / (maxValue + x);\n}\n\n// https://www.desmos.com/calculator/0vewkbnscu\nfloat limited(float x, float minValue, float maxValue) {\n  float d = maxValue - minValue;\n  float xd = x - minValue;\n  return x <= minValue ? x : minValue + d * xd / (d + xd);\n}\n\nfloat sqLength(in vec2 p) {\n  return p.x * p.x + p.y * p.y;\n}\n\nfloat sqLength(in vec3 p) {\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\nfloat pcurve(float x, float a, float b) {\n  float k = pow(a + b, a + b) / (pow(a, a) * pow(b, b));\n  return k * pow(x, a) * pow(1.0 - x, b);\n}\n\nfloat hash(float p) {\n  return fract(sin(p * 12.9898) * 43758.5453);\n}\n\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat hash(vec3 p) {\n  return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n}\n\nfloat hash(vec4 p) {\n  return fract(sin(dot(p, vec4(12.9898, 78.233, 45.164, 94.673))) * 43758.5453);\n}\n\nvec2 hash2(float p) {\n  return vec2(hash(p), hash(p + 1.0));\n}\n\nvec2 hash2(vec2 p) {\n  return vec2(hash(p.x), hash(p.y));\n}\n\nvec2 hash2(vec3 p) {\n  return vec2(hash(p.xy), hash(p.yz));\n}\n\nvec2 hash2(vec4 p) {\n  return vec2(hash(p.xyz), hash(p.yzw));\n}\n\nvec3 hash3(float p) {\n  return vec3(hash2(p),  hash(p + 2.0));\n}\n\nvec3 hash3(vec2 p) {\n  return vec3(hash2(p), hash(p));\n}\n\nvec3 hash3(vec3 p) {\n  return vec3(hash(p.x), hash(p.y), hash(p.z));\n}\n\nvec3 hash3(vec4 p) {\n  return vec3(hash(p.xy), hash(p.yz), hash(p.zw));\n}\n\nfloat hash_alt(float p) {\n  return fract(sin(p * 127.1) * 311.7);\n}\n\nfloat hash_alt(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 269.5);\n}\n\nfloat hash_alt(vec3 p) {\n  return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 269.5);\n}\n\nfloat hash_alt(vec4 p) {\n  return fract(sin(dot(p, vec4(127.1, 311.7, 74.7, 113.5))) * 269.5);\n}\n\n").concat((0,r.N)("vecX","\n  T min3(in T a, in T b, in T c) {\n    return min(min(a, b), c);\n  }\n"),"\n\n").concat((0,r.N)("vecX","\n  T min4(in T a, in T b, in T c, in T d) {\n    return min(min(a, b), min(c, d));\n  }\n"),"\n\n#endif // GLSL_UTILS\n")},13565:(n,t,e)=>{e.d(t,{q:()=>d});var a=e(28535),r=e(76999),o=e(57368),l=e(49797),c=e(93432),i=e(8144),u=e(96122);let s=[3,5,7,9,11].map(n=>(function(n,t){let e=function(n,t){if(n%2==0)throw Error("Kernel size must be odd");let e=Math.floor(n/2);null!=t||(t=n/3);let a=2*t*t,r=[],o=0;for(let n=-e;n<=e;n++)for(let t=-e;t<=e;t++){let e=Math.exp(-(t*t+n*n)/a);r.push(e),o+=e}for(let n=0;n<r.length;n++)r[n]/=o;return r}(n,void 0),a=[];for(let t=0;t<n;t++){let r=e.slice(t*n,(t+1)*n).map(n=>"  ".concat(n.toFixed(5))).join(", ");a.push(r)}let r="kernel".concat(n,"x").concat(n),o="const float[".concat(n*n,"] ").concat(r," = float[").concat(n*n,"](\n").concat(a.join(",\n"),");"),l=Math.floor(n/2);return o+"\n\n"+(0,u.T)("\n    vec4 gaussianBlur".concat(n,"x").concat(n,"(vec2 uv, float scale) {\n      vec2 texelSize = scale / uTextureSize;\n      vec4 color = vec4(0.0);\n      for (int x = -").concat(l,"; x <= ").concat(l,"; x++) {\n        for (int y = -").concat(l,"; y <= ").concat(l,"; y++) {\n          vec2 offset = vec2(float(x), float(y)) * texelSize;\n          color += texture2D(uTexture, uv + offset) * ").concat(r,"[x + ").concat(l," + (y + ").concat(l,") * ").concat(n,"];\n        }\n      }\n      return color;\n    }\n\n    vec4 gaussianBlur").concat(n,"x").concat(n,"(vec2 uv) {\n      return gaussianBlur").concat(n,"x").concat(n,"(uv, 1.0);\n    }\n  "))})(n)).join("\n\n"),f={glsl_utils:i.H,glsl_sdf_2d:"\n  // 2D SDF functions\n  float sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n  }\n\n  float sdRoundedSegment(in vec2 p, in vec2 a, in vec2 b, float r) {\n    return sdSegment(p, a, b) - r;\n  }\n",glsl_blur_3_11:s},x={fragmentTop:"",fragmentColor:"\n    gl_FragColor = vec4(vUv, 1., 1.);\n  ",texture:null,uniforms:{}};class p extends l.BKk{constructor(n,t){let e={...x,...t},a={...{uTexture:{value:null},uTextureSize:{value:new l.I9Y},uTime:{value:0},uDeltaTime:{value:0}},...e.uniforms},r=Array.from(n).map(n=>f[n]).filter(n=>!!n).join("\n\n");a.uTexture.value=e.texture,super({uniforms:a,vertexShader:"\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = vec4(position, 1.);\n        }\n      ",fragmentShader:"\n        varying vec2 vUv;\n        uniform sampler2D uTexture;\n        uniform vec2 uTextureSize;\n        uniform float uTime;\n        uniform float uDeltaTime;\n\n        ".concat(r,"\n\n        ").concat(Object.entries(e.uniforms).map(n=>{let[t,{value:e}]=n,a=function n(t){if(Array.isArray(t)){if(0===t.length)throw Error("GpuCompute: cannot infer uniform type for empty array");let e=n(t[0]);for(let a=1;a<t.length;a++)if(n(t[a])!==e)throw Error("GpuCompute: cannot infer uniform type for array with mixed types");return"".concat(e,"[").concat(t.length,"]")}if("number"==typeof t)return"float";if(t instanceof l.I9Y)return"vec2";if(t instanceof l.Pq0)return"vec3";if(t instanceof l.IUQ)return"vec4";if(t instanceof l.Q1f)return"vec3";if(t instanceof l.gPd)return"sampler2D";throw Error("GpuCompute: cannot infer uniform type for value: ".concat(t))}(e);return"uniform ".concat(a," ").concat(t,";")}).join("\n"),"\n\n        ").concat(e.fragmentTop,"\n\n        void main() {\n          ").concat(e.fragmentColor,"\n        }\n      ")}),this.uniforms=a}}let h={size:1024,type:l.ix0};var m=new WeakMap,v=new WeakMap;class d{get initialized(){return!!(0,a._)(this,m)}get renderer(){var n;return null==(n=(0,a._)(this,m))?void 0:n.renderer}get updateUniforms(){if(!this.state.updateMaterial)throw Error("GpuCompute: shaders not set");return this.state.updateMaterial.uniforms}enableGlslLib(){for(var n=arguments.length,t=Array(n),e=0;e<n;e++)t[e]=arguments[e];for(let n of t)f[n]?(0,a._)(this,v).add(n):console.warn("GpuCompute: unknown glsl lib: ".concat(n));return this}shaders(n){return this.state.initialMaterial=new p((0,a._)(this,v),n.initial),this.state.updateMaterial=new p((0,a._)(this,v),n.update),this}initialize(n){let{orthoCamera:t,plane:e}=this.parts,{rtA:a}=this.state;(0,o._)(this,m,{renderer:n});let{initialMaterial:r}=this.state;return r&&(r.uniforms.uTextureSize.value.copy(this.state.size),r.uniforms.uTexture.value=null,r.uniforms.uTime.value=0,r.uniforms.uDeltaTime.value=0,e.material=r),n.setRenderTarget(a),n.render(e,t),n.setRenderTarget(null),this.state.frame=0,this}update(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;if(!(0,a._)(this,m))throw Error("GpuCompute: not initialized");let{renderer:t}=(0,a._)(this,m),{orthoCamera:e,plane:r}=this.parts,{rtA:o,rtB:l,time:c,frame:i,updateMaterial:u}=this.state;return this.state.time+=n,u&&(u.uniforms.uTextureSize.value.copy(this.state.size),u.uniforms.uTexture.value=i%2==0?o.texture:l.texture,u.uniforms.uTime.value=c,u.uniforms.uDeltaTime.value=n,u.needsUpdate=!0,r.material=u),t.setRenderTarget(i%2==0?l:o),t.render(r,e),t.setRenderTarget(null),this.state.frame+=1,this}currentTexture(){return this.state.frame%2==0?this.state.rtA.texture:this.state.rtB.texture}constructor(n){(0,r._)(this,m,{writable:!0,value:void 0}),(0,r._)(this,v,{writable:!0,value:void 0}),this.parts={orthoCamera:new l.qUd(-1,1,1,-1,0,1),plane:new l.eaF(new l.bdM(2,2),void 0)},(0,o._)(this,v,new Set);let t={...this.constructor.defaultParams,...n};this.params=t;let{type:e}=t,a=(0,c.wX)(t.size),i=new l.nWS(a.width,a.height,{minFilter:l.hxR,magFilter:l.hxR,format:l.GWd,type:e}),u=new l.nWS(a.width,a.height,{minFilter:l.hxR,magFilter:l.hxR,format:l.GWd,type:e});i.texture.name="GpuCompute.rtA",u.texture.name="GpuCompute.rtB",this.state={size:a,rtA:i,rtB:u,time:0,frame:0}}}d.defaultParams=h},22899:(n,t,e)=>{e.d(t,{I:()=>o});var a=e(65927);let r=["linear"];for(let n=1;n<=10;n++)r.push("easeIn".concat(n)),r.push("easeOut".concat(n)),r.push("easeInOut".concat(n)),r.push("easeOutIn".concat(n));let o="\n#ifndef GLSL_EASING\n#define GLSL_EASING\n\n".concat(a.S,"\n\nfloat easePow1(float x) {\n  return x;\n}\n\nfloat easePow2(float x) {\n  return x * x;\n}\n\nfloat easePow3(float x) {\n  return x * x * x;\n}\n\nfloat easePow4(float x) {\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow5(float x) {\n  float x0 = x;\n  x *= x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow6(float x) {\n  x *= x * x;\n  return x *= x;\n}\n\nfloat easePow7(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow8(float x) {\n  x *= x;\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow9(float x) {\n  x *= x * x;\n  return x *= x * x;\n}\n\nfloat easePow10(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x * x;\n  return x0 * x;\n}\n\nfloat linear(float x) {\n  return clamp01(x);\n}\n\n").concat(Array.from({length:10},(n,t)=>{let e=t+1;return"\n\n  float easeIn".concat(e," (float x) {\n    return easePow").concat(e,"(clamp01(x));\n  }\n  float easeOut").concat(e," (float x) {\n    return 1.0 - easePow").concat(e,"(clamp01(1.0 - x));\n  }\n  float easeInOut").concat(e," (float x) {\n    return x < 0.5 \n      ? 0.5 * easePow").concat(e,"(2.0 * x) \n      : 1.0 - 0.5 * easePow").concat(e,"(2.0 * (1.0 - x));\n  }\n  float easeOutIn").concat(e," (float x) {\n    return x < 0.5\n      ? 0.5 * (1.0 - easePow").concat(e,"(1.0 - x * 2.0))\n      : 1.0 - 0.5 * (1.0 - easePow").concat(e,"(2.0 * x - 1.0));\n  }\n\n").trim()}).join("\n\n"),"\n\n\n// https://www.desmos.com/calculator/mqou4lf9zc?lang=fr\nfloat easeInOut(float x, float p, float i) {\n  return  x <= 0.0 ? 0.0 :\n          x >= 1.0 ? 1.0 :\n          x <= i ? 1.0 / pow(i, p - 1.0) * pow(x, p) :\n          1.0 - 1.0 / pow(1.0 - i, p - 1.0) * pow(1.0 - x, p);\n}\n\n// https://www.desmos.com/calculator/nrjlezusdv\nfloat easeInThenOut(float x, float p) {\n  return 1.0 - pow(abs(2.0 * x - 1.0), p);\n}\n\n#endif\n")},28737:(n,t,e)=>{e.d(t,{Leak:()=>f,O:()=>s});var a={};e.r(a),e.d(a,{distribute:()=>o.mn,every:()=>o.Si,findMaxBy:()=>o.vj,pairwise:()=>o.Ju,recordBy:()=>o.VY,some:()=>o.zN,split:()=>o.mn,uniqueBy:()=>o.pD});var r=e(30158),o=e(43107),l=e(38062),c=e(85795),i=e(17099),u=e(96122);function s(n){Object.assign(window,{...r,...c,...a,...n,PRNG:i.c,waveform:l.o,dedent:u.T})}function f(n){return s(n),null}},31423:(n,t,e)=>{e.d(t,{l:()=>c});var a=e(70691),r=e(18479),o=e(36508);let l={frequency:3,tickerName:"three",precision:1};function c(n){let{frequency:t,tickerName:e,precision:c,...i}={...l,...n},{ref:u}=(0,r.C7)(function*(){let n=o.Rv.get("three");yield n.onTick({timeInterval:1/3},()=>{u.current.innerText="".concat(n.averageFps.toFixed(c)," fps")})},[t,e,c]);return(0,a.jsx)("div",{ref:u,...i,children:"-- fps"})}},38062:(n,t,e)=>{e.d(t,{o:()=>a});let a={triangle:function(n){let{frequency:t=1,phase:e=0,f:a=t,p:r=e}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=n*a+r,l=2*o-Math.floor(2*o);return o-Math.floor(o)<.5?l:1-l}}},55227:(n,t,e)=>{e.d(t,{M:()=>l});var a=e(22899),r=e(1029);let o="\n\nstruct FloatRamp {\n  float a;\n  float b;\n  float t;\n};\n\nstruct Vec2Ramp {\n  vec2 a;\n  vec2 b;\n  float t;\n};\n\nstruct Vec3Ramp {\n  vec3 a;\n  vec3 b;\n  float t;\n};\n\nstruct Vec4Ramp {\n  vec4 a;\n  vec4 b;\n  float t;\n};\n\n".concat((0,r.N)("vecX",n=>{let t=n[0].toUpperCase()+n.slice(1)+"Ramp";return"\n\n".concat(t," ramp(float t, T a, T b) {\n  return ").concat(t,"(a, b, t);\n}\n\n").concat(t," ramp(float t, T a, T b, T c) {\n  if (t < .5) {\n    return ").concat(t,"(a, b, t * 2.0);\n  } else {\n    return ").concat(t,"(b, c, (t - 0.5) * 2.0);\n  }\n}\n\n").concat(t," ramp(float t, T a, T b, T c, T d) {\n  if (t < .33) {\n    return ").concat(t,"(a, b, t * 3.0);\n  } else if (t < .66) {\n    return ").concat(t,"(b, c, (t - 0.33) * 3.0);\n  } else {\n    return ").concat(t,"(c, d, (t - 0.66) * 3.0);\n  }\n}\n\n").slice(1,-1)})),l="\n#ifndef GLSL_RAMP\n#define GLSL_RAMP\n".concat(a.I,"\n").concat(o,"\n#endif\n")},65927:(n,t,e)=>{e.d(t,{S:()=>a});let a="\n#ifndef GLSL_BASIC\n#define GLSL_BASIC\n\nfloat clamp01(float x) {\n  return x < 0.0 ? 0.0 : x > 1.0 ? 1.0 : x;\n}\n\n#endif\n"},88352:(n,t,e)=>{e.d(t,{A:()=>o});var a=e(70691),r=e(53097);function o(){let n=(0,r.yk)();return(0,a.jsx)("button",{className:"absolute top-12 right-12 z-10 border border-white/50 hover:bg-black/10 hover:border-white text-white px-2 py-1 rounded transition",onClick:()=>n.setFullscreen("canvas"),children:"Fullscreen"})}},96122:(n,t,e)=>{e.d(t,{T:()=>a});function a(n){let t=n.split("\n"),e=0;for(let n of t){let t=n.match(/^(\s*)\S/);if(t){e=t[1].length;break}}return t.map(n=>n.slice(Math.min(n.length,e))).join("\n")}}}]);