"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6257],{47174:function(n,e,t){t.d(e,{b:function(){return d},R:function(){return w}});var a=t(32717),r=t(52471);let o=["common","uv_pars_vertex","displacementmap_pars_vertex","color_pars_vertex","fog_pars_vertex","normal_pars_vertex","morphtarget_pars_vertex","skinning_pars_vertex","shadowmap_pars_vertex","logdepthbuf_pars_vertex","clipping_planes_pars_vertex","uv_vertex","color_vertex","morphcolor_vertex","beginnormal_vertex","morphnormal_vertex","skinbase_vertex","skinnormal_vertex","defaultnormal_vertex","normal_vertex","begin_vertex","morphtarget_vertex","skinning_vertex","displacementmap_vertex","project_vertex","logdepthbuf_vertex","clipping_planes_vertex","worldpos_vertex","shadowmap_vertex","fog_vertex","common","packing","dithering_pars_fragment","color_pars_fragment","uv_pars_fragment","map_pars_fragment","alphamap_pars_fragment","alphatest_pars_fragment","alphahash_pars_fragment","aomap_pars_fragment","lightmap_pars_fragment","emissivemap_pars_fragment","iridescence_fragment","cube_uv_reflection_fragment","envmap_common_pars_fragment","envmap_physical_pars_fragment","fog_pars_fragment","lights_pars_begin","normal_pars_fragment","lights_physical_pars_fragment","transmission_pars_fragment","shadowmap_pars_fragment","bumpmap_pars_fragment","normalmap_pars_fragment","clearcoat_pars_fragment","iridescence_pars_fragment","roughnessmap_pars_fragment","metalnessmap_pars_fragment","logdepthbuf_pars_fragment","clipping_planes_pars_fragment","clipping_planes_fragment","logdepthbuf_fragment","map_fragment","color_fragment","alphamap_fragment","alphatest_fragment","alphahash_fragment","roughnessmap_fragment","metalnessmap_fragment","normal_fragment_begin","normal_fragment_maps","clearcoat_normal_fragment_begin","clearcoat_normal_fragment_maps","emissivemap_fragment","lights_physical_fragment","lights_fragment_begin","lights_fragment_maps","lights_fragment_end","aomap_fragment","transmission_fragment","opaque_fragment","tonemapping_fragment","colorspace_fragment","fog_fragment","premultiplied_alpha_fragment","dithering_fragment"];var l=t(79509);class c{static from(n,e){if(e instanceof l.Observable){if("number"==typeof e.value)return new c(n,e);throw Error("Observable value must be a number")}let t=typeof e;return"object"===t&&(e.constructor===Object||e instanceof r.Uniform)&&"value"in e?new c(n,e):"string"===t?new c(n,{value:new r.Color(e)}):new c(n,{value:e})}get value(){return this.target.value}computeDeclaration(){let n=this.name,e=this.target.value,t="";if(e instanceof Float32Array)return"uniform float ".concat(n,"[").concat(e.length,"];");if(Array.isArray(e)&&(t="[".concat(e.length,"]"),e=e[0]),"number"==typeof e)return"uniform float ".concat(n).concat(t,";");if(e.isVector2)return"uniform vec2 ".concat(n).concat(t,";");if(e.isVector3||e.isColor)return"uniform vec3 ".concat(n).concat(t,";");if(e.isVector4||e.isQuaternion)return"uniform vec4 ".concat(n).concat(t,";");if(e.isMatrix3)return"uniform mat3 ".concat(n).concat(t,";");if(e.isMatrix4)return"uniform mat4 ".concat(n).concat(t,";");if(e.isTexture)return e.isCubeTexture?"uniform samplerCube ".concat(n).concat(t,";"):"uniform sampler2D ".concat(n).concat(t,";");throw console.log("unhandled value:",e),Error('unhandled value: "'.concat(null==e?void 0:e.constructor.name,'"'))}constructor(n,e){this.name=n,this.target=e}}function i(){let n=(0,a._)(["","s*",""],["","\\s*",""]);return i=function(){return n},n}let f=null,s=n=>(f=n,d),u="// ShaderForge (injected code) ->",p="// <- ShaderForge",m=n=>"".concat(u,"\n").concat(n.trim(),"\n").concat(p),x=n=>{let e=n=>n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),t=RegExp(String.raw(i(),e(p),e(u)),"g");return n.replaceAll(t,"")};class _{getPattern(n){let{throwError:e=!0}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t="#include <".concat(n,">"),a=this.type;if(e&&!1===f[a].includes(t))throw Error('"'.concat(t,'" is not present in the shader template program.'));return{pattern:t,type:a}}replace(n,e){if(n instanceof RegExp){let{type:t}=this;f[t].match(n),f[t]=f[t].replace(n,m(e))}else{let{type:t,pattern:a}=this.getPattern(n),r=m(e);f[t]=f[t].replace(a,r)}return d}inject(n,e,t){let{type:a,pattern:r}=this.getPattern(e),o="after"===n?"".concat(r,"\n").concat(m(t)):"".concat(m(t),"\n").concat(r);return f[a]=f[a].replace(r,o),d}injectTokenComments(){for(let n of o){let{type:e,pattern:t}=this.getPattern(n,{throwError:!1});f[e]=f[e].replace(t,"\n        ".concat(t,"\n        // ShaderForge TOKEN: ").concat(n,"\n      "))}return d}header(n){let e=this.type;return f[e]="".concat(n,"\n").concat(f[e]),d}before(n,e){return this.inject("before",n,e)}after(n,e){return this.inject("after",n,e)}top(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];return f[this.type]=f[this.type].replace("void main() {","\n      ".concat(m(e.join("\n\n")),"\n      void main() {\n    ")),d}mainBeforeAll(n){return f[this.type]=f[this.type].replace("void main() {","void main() {\n        ".concat(m(n))),d}mainAfterAll(n){return f[this.type]=f[this.type].replace(/}\s*$/,"\n      ".concat(m(n),"\n    }")),d}uniforms(n){if("string"==typeof n)this.top(n);else{let e=[];for(let[t,a]of Object.entries(n)){let n=c.from(t,a);e.push(n.computeDeclaration())}this.top(e.join("\n")),function(n){for(let[e,t]of Object.entries(n)){let n=c.from(e,t);if(e in f.uniforms){if(n.value!==f.uniforms[e].value)throw Error("Shader redefinition! (Uniform values are not equal)")}else f.uniforms[e]=n}}(n)}return d}clean(){return f[this.type]=x(f[this.type]),d}printFinalCode(){return console.log(f[this.type].replace(/#include <(.*)>/g,(n,e)=>{let t=r.ShaderChunk[e];if(!t)throw Error('Shader chunk "'.concat(e,'" not found'));return t})),d}constructor(n){this.type=n}}let h=new _("fragmentShader"),g=new _("vertexShader"),d=Object.assign(function(n){return n&&s(n),d},{shaderName:function(n){return f.shaderName="".concat(n," (ShaderForge)"),d},defines:function(n){return f.defines?Object.assign(f.defines,n):f.defines=n,d},uniforms:function(n){return g.uniforms(n),h.uniforms(n),d},varying:function(n){let e="";if("string"==typeof n)e=n;else{let t=[];for(let[e,a]of Object.entries(n))t.push("varying ".concat(a," ").concat(e,";"));e=t.join("\n")}return g.top(e),h.top(e),d},vertex:g,fragment:h,header:function(n){return h.header(n),g.header(n),d},clean:function(){return h.clean(),g.clean(),d},with:s,wrap:(n,e)=>(n.onBeforeCompile=n=>{f=n},n)}),v=new r.Color;function w(n){let{r:e,g:t,b:a}=v.set(n);return"vec3(".concat(e.toFixed(3),", ").concat(t.toFixed(3),", ").concat(a.toFixed(3),")")}},26917:function(n,e,t){t.d(e,{l:function(){return a}});let a="\n#ifndef GLSL_BASIC\n#define GLSL_BASIC\n\nfloat clamp01(float x) {\n  return x < 0.0 ? 0.0 : x > 1.0 ? 1.0 : x;\n}\n\n#endif\n"},1060:function(n,e,t){t.d(e,{i:function(){return o}});var a=t(26917);let r=["linear"];for(let n=1;n<=10;n++)r.push("easeIn".concat(n)),r.push("easeOut".concat(n)),r.push("easeInOut".concat(n)),r.push("easeOutIn".concat(n));let o="\n#ifndef GLSL_EASING\n#define GLSL_EASING\n\n".concat(a.l,"\n\nfloat easePow1(float x) {\n  return x;\n}\n\nfloat easePow2(float x) {\n  return x * x;\n}\n\nfloat easePow3(float x) {\n  return x * x * x;\n}\n\nfloat easePow4(float x) {\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow5(float x) {\n  float x0 = x;\n  x *= x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow6(float x) {\n  x *= x * x;\n  return x *= x;\n}\n\nfloat easePow7(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow8(float x) {\n  x *= x;\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow9(float x) {\n  x *= x * x;\n  return x *= x * x;\n}\n\nfloat easePow10(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x * x;\n  return x0 * x;\n}\n\nfloat linear(float x) {\n  return clamp01(x);\n}\n\n").concat(Array.from({length:10},(n,e)=>{let t=e+1;return"\n\nfloat easeIn".concat(t," (float x) {\n  return easePow").concat(t,"(clamp01(x));\n}\nfloat easeOut").concat(t," (float x) {\n  return 1.0 - easePow").concat(t,"(clamp01(1.0 - x));\n}\nfloat easeInOut").concat(t," (float x) {\n  return x < 0.5 \n    ? 0.5 * easePow").concat(t,"(2.0 * x) \n    : 1.0 - 0.5 * easePow").concat(t,"(2.0 * (1.0 - x));\n}\nfloat easeOutIn").concat(t," (float x) {\n  return x < 0.5\n    ? 0.5 * (1.0 - easePow").concat(t,"(1.0 - x * 2.0))\n    : 1.0 - 0.5 * (1.0 - easePow").concat(t,"(2.0 * x - 1.0));\n}\n\n").trim()}).join("\n\n"),"\n\n\n// https://www.desmos.com/calculator/mqou4lf9zc?lang=fr\nfloat easeInOut(float x, float p, float i) {\n  return  x <= 0.0 ? 0.0 :\n          x >= 1.0 ? 1.0 :\n          x <= i ? 1.0 / pow(i, p - 1.0) * pow(x, p) :\n          1.0 - 1.0 / pow(1.0 - i, p - 1.0) * pow(1.0 - x, p);\n}\n\n// https://www.desmos.com/calculator/nrjlezusdv\nfloat easeInThenOut(float x, float p) {\n  return 1.0 - pow(abs(2.0 * x - 1.0), p);\n}\n\n#endif\n")},70155:function(n,e,t){t.d(e,{C:function(){return r}});let a={vecX:["float","vec2","vec3","vec4"]},r=(n,e)=>{let t=[],r=Array.isArray(n)?n:[n].map(n=>n in a?a[n]:n).flat();if("function"==typeof e)for(let n of r)t.push(e(n).replaceAll(/\bT\b/g,n));else for(let n of r)t.push(e.replaceAll(/\bT\b/g,n));return t.join("\n")}},98828:function(n,e,t){t.d(e,{U:function(){return o}});var a=t(26917),r=t(70155);let o="\n  ".concat(a.l,"\n\n  float sin01(float x) {\n    return 0.5 + 0.5 * sin(x * 6.283185307179586);\n  }\n\n  vec2 scaleAround(vec2 p, vec2 c, float s) {\n    return c + (p - c) / s;\n  }\n\n  // Same as mix, but clamped.\n  ").concat((0,r.C)("vecX","\n    T lerp(in T a, in T b, in float x) {\n      return mix(a, b, clamp01(x));\n    }\n  "),"\n\n  float inverseLerpUnclamped(in float a, in float b, float x) {\n    return (x - a) / (b - a);\n  }\n\n  float inverseLerp(in float a, in float b, float x) {\n    return clamp01((x - a) / (b - a));\n  }\n\n  float threshold(in float x, in float thresholdValue) {\n    return x < thresholdValue ? 0. : 1.;\n  }\n\n  float threshold(in float x, in float thresholdValue, in float width) {\n    return width < 1e-9 \n      ? (x < thresholdValue ? 0. : 1.)\n      : clamp01((x - thresholdValue + width * .5) / width);\n  }\n\n  mat3 extractRotation(mat4 matrix) {\n    return mat3(matrix[0].xyz, matrix[1].xyz, matrix[2].xyz);\n  }\n\n  vec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    float x = c * p.x + s * p.y;\n    float y = -s * p.x + c * p.y;\n    return vec2(x, y);\n  }\n\n  vec2 rotateAround(vec2 p, float a, vec2 c) {\n    return c + rotate(p - c, a);\n  }\n\n  vec2 rotateScaleAround(vec2 p, float a, float s, vec2 c) {\n    return c + rotate((p - c) / s, a);\n  }\n  \n  float positiveModulo(float x) {\n    x = mod(x, 1.0);\n    return x < 0.0 ? x + 1.0 : x;\n  }\n\n  float positiveModulo(float x, float modulo) {\n    x = mod(x, modulo);\n    return x < 0.0 ? x + modulo : x;\n  }\n\n  // Limit a value to a maximum that the function tends to reach when x -> ∞\n  // https://www.desmos.com/calculator/0vewkbnscu\n  float limited(float x, float maxValue) {\n    return x <= 0.0 ? x : maxValue * x / (maxValue + x);\n  }\n\n  // https://www.desmos.com/calculator/0vewkbnscu\n  float limited(float x, float minValue, float maxValue) {\n    float d = maxValue - minValue;\n    float xd = x - minValue;\n    return x <= minValue ? x : minValue + d * xd / (d + xd);\n  }\n\n  float sqLength(in vec2 p) {\n    return p.x * p.x + p.y * p.y;\n  }\n\n  float sqLength(in vec3 p) {\n    return p.x * p.x + p.y * p.y + p.z * p.z;\n  }\n\n  float pcurve(float x, float a, float b) {\n    float k = pow(a + b, a + b) / (pow(a, a) * pow(b, b));\n    return k * pow(x, a) * pow(1.0 - x, b);\n  }\n\n  float hash(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n  }\n\n  ").concat((0,r.C)("vecX","\n    T min3(in T a, in T b, in T c) {\n      return min(min(a, b), c);\n    }\n  "),"\n\n  ").concat((0,r.C)("vecX","\n    T min4(in T a, in T b, in T c, in T d) {\n      return min(min(a, b), min(c, d));\n    }\n  "),"\n")}}]);