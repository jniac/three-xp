(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3822],{1029:(n,e,t)=>{"use strict";t.d(e,{N:()=>a});let o={vecX:["float","vec2","vec3","vec4"]},a=(n,e)=>{let t=[],a=Array.isArray(n)?n:[n].map(n=>n in o?o[n]:n).flat();if("function"==typeof e)for(let n of a)t.push(e(n).replaceAll(/\bT\b/g,n));else for(let n of a)t.push(e.replaceAll(/\bT\b/g,n));return t.join("\n")}},8144:(n,e,t)=>{"use strict";t.d(e,{H:()=>r});var o=t(65927),a=t(1029);let r="\n".concat(o.S,"\n\n#ifndef GLSL_UTILS\n#define GLSL_UTILS\n\nfloat sin01(float x) {\n  return 0.5 + 0.5 * sin(x * 6.283185307179586);\n}\n\nvec2 scaleAround(vec2 p, vec2 c, float s) {\n  return c + (p - c) / s;\n}\n\n// Same as mix, but clamped.\n").concat((0,a.N)("vecX","\n  T lerp(in T a, in T b, in float x) {\n    return mix(a, b, clamp01(x));\n  }\n"),"\n\nfloat inverseLerpUnclamped(in float a, in float b, float x) {\n  return (x - a) / (b - a);\n}\n\nfloat inverseLerp(in float a, in float b, float x) {\n  return clamp01((x - a) / (b - a));\n}\n\nfloat remap(in float x, in float a, in float b, in float c, in float d) {\n  return c + (d - c) * inverseLerp(a, b, x);\n}\n\n// Remap from [-1, 1] to [0, 1]\nfloat remap1101(in float x) {\n  return clamp01(0.5 + 0.5 * x);\n}\n\n").concat((0,a.N)("vecX","\n  T oneMinus(in T x) {\n    return 1.0 - x;\n  }\n"),"\n\n// Returns x^p, but handles negative x values correctly.\nfloat spow(in float x, in float p) {\n  return x >= 0.0 ? pow(x, p) : -pow(-x, p);\n}\n\nfloat threshold(in float x, in float thresholdValue) {\n  return x < thresholdValue ? 0. : 1.;\n}\n\nfloat threshold(in float x, in float thresholdValue, in float width) {\n  return width < 1e-9 \n    ? (x < thresholdValue ? 0. : 1.)\n    : clamp01((x - thresholdValue + width * .5) / width);\n}\n\nmat3 extractRotation(mat4 matrix) {\n  return mat3(matrix[0].xyz, matrix[1].xyz, matrix[2].xyz);\n}\n\nvec2 rotate(vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  float x = c * p.x + s * p.y;\n  float y = -s * p.x + c * p.y;\n  return vec2(x, y);\n}\n\nvec2 rotateAround(vec2 p, float a, vec2 c) {\n  return c + rotate(p - c, a);\n}\n\nvec2 rotateScaleAround(vec2 p, float a, float s, vec2 c) {\n  return c + rotate((p - c) / s, a);\n}\n\nfloat positiveModulo(float x) {\n  x = mod(x, 1.0);\n  return x < 0.0 ? x + 1.0 : x;\n}\n\n// Modulo that keeps the result in the range [0, modulo]\nfloat positiveModulo(float x, float modulo) {\n  x = mod(x, modulo);\n  return x < 0.0 ? x + modulo : x;\n}\n\n// Modulo that keeps the result in the range [-m/2, m/2]\nfloat middleModulo(float x, float modulo) {\n  x = mod(x, modulo);\n  return x < -modulo / 2.0 ? x + modulo : x > modulo / 2.0 ? x - modulo : x;\n}\n\n// Limit a value to a maximum that the function tends to reach when x -> âˆž\n// https://www.desmos.com/calculator/0vewkbnscu\nfloat limited(float x, float maxValue) {\n  return x <= 0.0 ? x : maxValue * x / (maxValue + x);\n}\n\n// https://www.desmos.com/calculator/0vewkbnscu\nfloat limited(float x, float minValue, float maxValue) {\n  float d = maxValue - minValue;\n  float xd = x - minValue;\n  return x <= minValue ? x : minValue + d * xd / (d + xd);\n}\n\nfloat sqLength(in vec2 p) {\n  return p.x * p.x + p.y * p.y;\n}\n\nfloat sqLength(in vec3 p) {\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\nfloat pcurve(float x, float a, float b) {\n  float k = pow(a + b, a + b) / (pow(a, a) * pow(b, b));\n  return k * pow(x, a) * pow(1.0 - x, b);\n}\n\nfloat hash(float p) {\n  return fract(sin(p * 12.9898) * 43758.5453);\n}\n\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat hash(vec3 p) {\n  return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n}\n\nfloat hash(vec4 p) {\n  return fract(sin(dot(p, vec4(12.9898, 78.233, 45.164, 94.673))) * 43758.5453);\n}\n\nvec2 hash2(float p) {\n  return vec2(hash(p), hash(p + 1.0));\n}\n\nvec2 hash2(vec2 p) {\n  return vec2(hash(p.x), hash(p.y));\n}\n\nvec2 hash2(vec3 p) {\n  return vec2(hash(p.xy), hash(p.yz));\n}\n\nvec2 hash2(vec4 p) {\n  return vec2(hash(p.xyz), hash(p.yzw));\n}\n\nvec3 hash3(float p) {\n  return vec3(hash2(p),  hash(p + 2.0));\n}\n\nvec3 hash3(vec2 p) {\n  return vec3(hash2(p), hash(p));\n}\n\nvec3 hash3(vec3 p) {\n  return vec3(hash(p.x), hash(p.y), hash(p.z));\n}\n\nvec3 hash3(vec4 p) {\n  return vec3(hash(p.xy), hash(p.yz), hash(p.zw));\n}\n\nfloat hash_alt(float p) {\n  return fract(sin(p * 127.1) * 311.7);\n}\n\nfloat hash_alt(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 269.5);\n}\n\nfloat hash_alt(vec3 p) {\n  return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 269.5);\n}\n\nfloat hash_alt(vec4 p) {\n  return fract(sin(dot(p, vec4(127.1, 311.7, 74.7, 113.5))) * 269.5);\n}\n\n").concat((0,a.N)("vecX","\n  T min3(in T a, in T b, in T c) {\n    return min(min(a, b), c);\n  }\n"),"\n\n").concat((0,a.N)("vecX","\n  T min4(in T a, in T b, in T c, in T d) {\n    return min(min(a, b), min(c, d));\n  }\n"),"\n\n#endif // GLSL_UTILS\n")},14203:(n,e,t)=>{"use strict";t.d(e,{O:()=>a});var o=t(1029);let a="\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; \n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat permute(float x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nfloat taylorInvSqrt(float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\n\n\n\n\n// 2D:\n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n		+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// 3D: \n\nfloat snoise(vec3 v)\n{ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\n\n// 4D:\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n						\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v) {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n  // First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n  // Other corners\n\n  // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n  //  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n  //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n  // Permutations\n  i = mod289(i); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n  // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n  // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n  // Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n  // Mix contributions from the five corners\n  vec3 m0 = max(0.57 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.57 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 60.1 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\n\n\n\n// addons:\n// Fractal noise, based on Stefan Gustavson's Simplex noise\n".concat((0,o.N)(["vec2","vec3","vec4"],"\n  float fnoise(T p, int octaves, float persistence) {\n    float total = 0.0;           // Final noise value\n    float amplitude = 1.0;       // Initial amplitude\n    float frequency = 1.0;       // Initial frequency\n    float maxValue = 0.0;        // Used for normalization\n\n    for (int i = 0; i < octaves; i++) {\n      total += snoise(p * frequency) * amplitude;\n\n      maxValue += amplitude;   // Keep track of max amplitude\n      amplitude *= persistence; // Reduce amplitude for next octave\n      frequency *= 2.0;        // Increase frequency for next octave\n    }\n\n    // Normalize the result to stay within the range [0, 1]\n    return total / maxValue;\n  }\n\n  float fnoise(T p, int octaves) {\n    return fnoise(p, octaves, 0.5);\n  }\n\n  float fnoise(T p) {\n    return fnoise(p, 4, 0.5);\n  }\n"),"\n\nfloat snoiseFast4D(vec4 p) {\n  const float SCALAR = 0.01;\n  float a = SCALAR * dot(p.xy * 0.3, vec2(-127.1, 311.7));\n  float b = SCALAR * dot(p.zw * 0.8, vec2(269.5, -183.3));\n  float c = SCALAR * dot(p.wx * 6.0, vec2(23.14069, 2.665157));\n  float d = SCALAR * dot(p.zy * 1.3, vec2(-12.9898, 78.233));\n  return (snoise(vec2(a, b)) + snoise(vec2(d, c))) * 0.5;\n}\n\nfloat fnoiseFast4D(vec4 p, int octaves, float persistence) {\n  float total = 0.0;           // Final noise value\n  float amplitude = 1.0;       // Initial amplitude\n  float frequency = 1.0;       // Initial frequency\n  float maxValue = 0.0;        // Used for normalization\n\n  for (int i = 0; i < octaves; i++) {\n    total += snoiseFast4D(p * frequency) * amplitude;\n\n    maxValue += amplitude;   // Keep track of max amplitude\n    amplitude *= persistence; // Reduce amplitude for next octave\n    frequency *= 2.0;        // Increase frequency for next octave\n  }\n\n  // Normalize the result to stay within the range [0, 1]\n  return total / maxValue;\n}\n")},22899:(n,e,t)=>{"use strict";t.d(e,{I:()=>r});var o=t(65927);let a=["linear"];for(let n=1;n<=10;n++)a.push("easeIn".concat(n)),a.push("easeOut".concat(n)),a.push("easeInOut".concat(n)),a.push("easeOutIn".concat(n));let r="\n#ifndef GLSL_EASING\n#define GLSL_EASING\n\n".concat(o.S,"\n\nfloat easePow1(float x) {\n  return x;\n}\n\nfloat easePow2(float x) {\n  return x * x;\n}\n\nfloat easePow3(float x) {\n  return x * x * x;\n}\n\nfloat easePow4(float x) {\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow5(float x) {\n  float x0 = x;\n  x *= x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow6(float x) {\n  x *= x * x;\n  return x *= x;\n}\n\nfloat easePow7(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow8(float x) {\n  x *= x;\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow9(float x) {\n  x *= x * x;\n  return x *= x * x;\n}\n\nfloat easePow10(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x * x;\n  return x0 * x;\n}\n\nfloat linear(float x) {\n  return clamp01(x);\n}\n\n").concat(Array.from({length:10},(n,e)=>{let t=e+1;return"\n\n  float easeIn".concat(t," (float x) {\n    return easePow").concat(t,"(clamp01(x));\n  }\n  float easeOut").concat(t," (float x) {\n    return 1.0 - easePow").concat(t,"(clamp01(1.0 - x));\n  }\n  float easeInOut").concat(t," (float x) {\n    return x < 0.5 \n      ? 0.5 * easePow").concat(t,"(2.0 * x) \n      : 1.0 - 0.5 * easePow").concat(t,"(2.0 * (1.0 - x));\n  }\n  float easeOutIn").concat(t," (float x) {\n    return x < 0.5\n      ? 0.5 * (1.0 - easePow").concat(t,"(1.0 - x * 2.0))\n      : 1.0 - 0.5 * (1.0 - easePow").concat(t,"(2.0 * x - 1.0));\n  }\n\n").trim()}).join("\n\n"),"\n\n\n// https://www.desmos.com/calculator/mqou4lf9zc?lang=fr\nfloat easeInOut(float x, float p, float i) {\n  return  x <= 0.0 ? 0.0 :\n          x >= 1.0 ? 1.0 :\n          x <= i ? 1.0 / pow(i, p - 1.0) * pow(x, p) :\n          1.0 - 1.0 / pow(1.0 - i, p - 1.0) * pow(1.0 - x, p);\n}\n\n// https://www.desmos.com/calculator/nrjlezusdv\nfloat easeInThenOut(float x, float p) {\n  return 1.0 - pow(abs(2.0 * x - 1.0), p);\n}\n\n#endif\n")},32137:(n,e,t)=>{"use strict";t.d(e,{Q:()=>p});var o=t(70691),a=t(67203),r=t(63106),l=t(21667),i=t(18479),c=t(43865),s=t.n(c);let x=[s().frame,s().full];function p(n){let[e,t]=(0,a.useState)(0),{ref:c}=(0,i.IZ)(function*(n){yield(0,l.G)(n,{onSize:e=>{let{x:t,y:o}=e.size;n.classList.toggle(s().landscape,t>o)}});let e=!1;yield(0,r.a)(document.documentElement,[[{key:"f",noModifiers:!0},o=>{o.event.preventDefault(),document.fullscreenElement!==n?(n.requestFullscreen(),e=!1):!1===e?(e=!0,t(1)):(document.exitFullscreen(),t(0))}]])},[]),{children:p,className:d}=n;return(0,o.jsx)("div",{ref:c,className:[s().Billboard,s().landscape,x[e],null!=d?d:""].join(" "),children:p})}},35375:(n,e,t)=>{"use strict";t.d(e,{$:()=>a});let o="/three-xp/assets/",a={development:!1,assetsPath:o,assets:function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return"".concat(o).concat(n)}}},43865:n=>{n.exports={Billboard:"billboard_Billboard__1od0V",landscape:"billboard_landscape__OR09y",frame:"billboard_frame__m5PEh",full:"billboard_full__0I_hQ"}},55227:(n,e,t)=>{"use strict";t.d(e,{M:()=>l});var o=t(22899),a=t(1029);let r="\n\nstruct FloatRamp {\n  float a;\n  float b;\n  float t;\n};\n\nstruct Vec2Ramp {\n  vec2 a;\n  vec2 b;\n  float t;\n};\n\nstruct Vec3Ramp {\n  vec3 a;\n  vec3 b;\n  float t;\n};\n\nstruct Vec4Ramp {\n  vec4 a;\n  vec4 b;\n  float t;\n};\n\n".concat((0,a.N)("vecX",n=>{let e=n[0].toUpperCase()+n.slice(1)+"Ramp";return"\n\n".concat(e," ramp(float t, T a, T b) {\n  return ").concat(e,"(a, b, t);\n}\n\n").concat(e," ramp(float t, T a, T b, T c) {\n  if (t < .5) {\n    return ").concat(e,"(a, b, t * 2.0);\n  } else {\n    return ").concat(e,"(b, c, (t - 0.5) * 2.0);\n  }\n}\n\n").concat(e," ramp(float t, T a, T b, T c, T d) {\n  if (t < .33) {\n    return ").concat(e,"(a, b, t * 3.0);\n  } else if (t < .66) {\n    return ").concat(e,"(b, c, (t - 0.33) * 3.0);\n  } else {\n    return ").concat(e,"(c, d, (t - 0.66) * 3.0);\n  }\n}\n\n").slice(1,-1)})),l="\n#ifndef GLSL_RAMP\n#define GLSL_RAMP\n".concat(o.I,"\n").concat(r,"\n#endif\n")},63106:(n,e,t)=>{"use strict";function o(n,e){return"*"===e||("string"==typeof e?e===n:e instanceof RegExp?e.test(n):"function"==typeof e&&e(n))}t.d(e,{a:()=>i});let a={preventDefault:!1,strictTarget:void 0},r={key:"*",keyCaseInsensitive:!0,code:"*",noModifiers:!1,modifiers:"",phase:"down"},l=0;function i(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];let i=l++,[c,s,x]=1===e.length?[document.body,{},e[0]]:2===e.length?[e[0],{},e[1]]:e,{preventDefault:p}={...a,...s},d=null,u=n=>{var e;if((null!=(e=s.strictTarget)?!!e:c===document.body)&&n.target!==c)return;"keydown"===n.type&&(d=n);let{ctrlKey:t=!1,altKey:a=!1,shiftKey:l=!1,metaKey:u=!1}=null!=d?d:{},f={id:i,event:n,downEvent:d,modifiers:{ctrl:t,alt:a,shift:l,meta:u}};for(let e=0,i=x.length;e<i;e++){let[i,c]=x[e],{key:s,keyCaseInsensitive:m,code:v,noModifiers:h,modifiers:w,phase:y="down"}=function(n){let e="string"==typeof n?{...r,key:n}:{...r,...n};return e.keyCaseInsensitive&&"string"==typeof e.key&&(e.key=e.key.toLowerCase()),e}(i);switch(n.type){case"keydown":if("down"!==y)continue;break;case"keyup":if("up"!==y)continue}Object.values({key:o(m?n.key.toLowerCase():n.key,s),code:o(n.code,v),noModifiers:!h||!1===t&&!1===a&&!1===l&&!1===u,modifiers:function(n,e){let{ctrlKey:t,altKey:o,shiftKey:a,metaKey:r}=n;if("function"==typeof e)return e({ctrl:t,alt:o,shift:a,meta:r});let{ctrl:l=!1,alt:i=!1,shift:c=!1,meta:s=!1}=Object.fromEntries(e.split("-").map(n=>[n,!0]));return l===t&&i===o&&c===a&&s===r}(d,w)}).every(Boolean)&&(p&&n.preventDefault(),c(f))}};return c.addEventListener("keydown",u,{passive:!1}),c.addEventListener("keyup",u,{passive:!1}),{destroy:()=>{c.removeEventListener("keydown",u),c.removeEventListener("keyup",u)}}}},63822:(n,e,t)=>{"use strict";t.d(e,{Main:()=>j});var o=t(70691),a=t(32137),r=t(63357),l=t(49797),i=t(30158),c=t(7147),s=t(61249),x=t(22899),p=t(79285),d=t(17099),u=t(35375),f=t(9954);let m=new(t(5832)).Y;function v(n){return new Promise(e=>{m.load(n,n=>{e(n)})})}let h=new f.H;var w=t(55227);let y={white:new l.Q1f("#ffffff"),grey10:new l.Q1f("#f0f0f0"),grey20:new l.Q1f("#e0e0e0"),notSoWhite:new l.Q1f("#f8f8e8"),yellow:new l.Q1f("#fff700"),black:new l.Q1f("#110111"),red:new l.Q1f("#dd1a41"),brightSkin:new l.Q1f("#ebd8c6"),petrol:new l.Q1f("#005e6b"),brightGreen:new l.Q1f("#22c891"),darkGreen:new l.Q1f("#002f1c"),sand:new l.Q1f("#e6db9f")};class g extends l.eaF{static createMaterial(n){let{color:e,shaded:t,emissiveIntensity:o,side:a}={...g.defaultProps,...n};return t?new l.uSd({color:e,emissiveIntensity:o,emissive:o>0?e:void 0,side:a}):new l.V9B({color:e})}}g.defaultProps={color:y.black,radius:1.3,align:.5,thickness:.3,innerRadiusRatio:null,shaded:!0,emissiveIntensity:.333};class b extends g{constructor(n){let{radius:e,thickness:t,align:o,innerRadiusRatio:a,color:r,shaded:i,...c}={...g.defaultProps,...n},x=e-t*o,p=e+t*(1-o);a&&(x=e*a,p=e),super(new l.rKP(x,p,128),g.createMaterial({...n,side:l.$EB})),(0,s.N)(this,c)}}class P extends l.eaF{constructor(n){let{radius:e,thickness:t,align:o,innerRadiusRatio:a,color:r,shaded:i,emissiveIntensity:c,...x}={...g.defaultProps,...n},p=e-t*o,d=e+t*(1-o);a&&(p=e*a,d=e),super(new l.O3Y((p+d)/2,(d-p)/2,128,512),g.createMaterial({...n,side:l.hB5})),(0,s.N)(this,x)}}class z extends b{constructor(n){super(n),this.material.onBeforeCompile=n=>c.bI.with(n).defines({USE_UV:""}).fragment.top(w.M).fragment.after("map_fragment","\n      vec2 p = vUv - 0.5;\n      float alpha = atan(p.y, p.x) / 6.2831853;\n      alpha = 1.0 - mod(alpha + 0.0, 1.0);\n      Vec3Ramp r = ramp(alpha,\n        ".concat((0,c.eR)(y.black),",\n        ").concat((0,c.eR)(y.white),",\n        ").concat((0,c.eR)(y.yellow),");\n      diffuseColor.rgb = mix(r.a, r.b, easeInOut4(r.t));\n    "))}}var k=t(77399);class C extends l.YJl{constructor({globalIntensity:n=1,debug:e=!1}={}){super(),this.name="lights";let t=new l.dth("#dbebf0","#645d61",n);this.add(t);let o=new l.ure("#e8e6d3",1.3*n);o.position.set(10,10,10),o.width=40,o.height=40,o.lookAt(0,0,0),this.add(o),e&&this.add(new k.g(o));let a=new l.$p8("#f2f0dd",.8*n);this.add(a)}}function S(n){let{precision:e=3}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=0,o=0,a=0;function r(){return"vec3(".concat(t.toFixed(e),", ").concat(o.toFixed(e),", ").concat(a.toFixed(e),")")}switch(typeof n){case"number":return t=(n>>16&255)/255,o=(n>>8&255)/255,a=(255&n)/255,r();case"string":if(n.startsWith("#")){if(4===n.length)return t=parseInt(n[1]+n[1],16)/255,o=parseInt(n[2]+n[2],16)/255,a=parseInt(n[3]+n[3],16)/255,r();return S(parseInt(n.slice(1),16),{precision:e})}throw Error("Invalid string: ".concat(n));case"object":if(Array.isArray(n))return[t,o,a]=n,r();if("r"in n)return t=n.r,o=n.g,a=n.b,r();if("x"in n)return t=n.x,o=n.y,a=n.z,r();throw Error("Invalid object: ".concat(n))}return"vec3(1.0, 0.0, 1.0)"}p.toff;var I=t(14203);let M="\n  ".concat(i.ShaderChunk.cube_uv_reflection_fragment,"\n  ").concat(I.O,"\n\n  varying vec3 vPosition;\n  varying vec3 vWorldNormal;\n\n  struct Plane {\n    vec3 origin;\n    vec3 normal;\n  };\n\n  float signedDistanceToPlane(Plane plane, vec3 p) {\n    return dot(plane.normal, p - plane.origin);\n  }\n\n  vec3 checker3(vec3 position, float scale, float edgeWidth, vec3 color1, vec3 color2) {\n    // Scale the position to control the size of the checker cubes\n    vec3 scaledPos = position / scale;\n\n    // Get the integer part (checker grid location)\n    vec3 checkerPos = floor(scaledPos);\n\n    // Get the fractional part (inside each cube)\n    vec3 fractPos = fract(scaledPos);\n\n    // Calculate the checkerboard pattern (even/odd cubes)\n    float checkerSum = mod(checkerPos.x + checkerPos.y + checkerPos.z, 2.0);\n\n    // Smooth transition using smoothstep on the fractional position\n    float edgeX = smoothstep(0.0, edgeWidth, fractPos.x);\n    float edgeY = smoothstep(0.0, edgeWidth, fractPos.y);\n    float edgeZ = smoothstep(0.0, edgeWidth, fractPos.z);\n\n    // Combine the edges to create a smooth transition\n    float blend = edgeX * edgeY * edgeZ;\n    blend = smoothstep(0.0, edgeWidth, min(min(fractPos.x, fractPos.y), fractPos.z));\n    \n    // Interpolate between black and white with the smoothstep value\n    vec3 baseColor = checkerSum == 0.0 ? color1 : color2;\n    vec3 oppositeColor = checkerSum == 0.0 ? color2 : color1;\n\n    // Use the smooth transition to blend between colors\n    return mix(baseColor, oppositeColor, blend);\n  }\n\n  float sphereGrid(vec3 position, float scale, float edgeWidth) {\n    // Scale the position to control the size of the checker cubes\n    vec3 scaledPos = position / scale;\n\n    // Get the integer part (checker grid location)\n    vec3 checkerPos = floor(scaledPos);\n\n    // Get the fractional part (inside each cube)\n    vec3 fractPos = fract(scaledPos);\n\n    vec3 p = fractPos - 0.5;\n    float alpha = 1.0 - length(p) * 2.0;\n\n    return smoothstep(0.0, edgeWidth, alpha - 0.1);    \n  }\n\n  void main() {\n    vec3 p = vWorldNormal * 0.33;\n    float n1 = snoise(p * 6.0 * 0.2 + 0.2);\n    float n2 = snoise(p * 20.0 + 10.1);\n    float n3 = snoise(p * 40.0 + 10.1);\n    float n4 = snoise(p * 1400.0 + 13.1);\n    float n = n1 * 0.5;\n    n += pow(fract((n1 + n2 * 0.015 + n3 * 0.01 + n4 * 0.005) * 85.0), 4.0) * 0.5;\n    n += pow(fract((n1 + n2 * 0.015) * 85.0), 4.0) * 0.25;\n    n += n4 * 0.2;\n    n += 0.8;\n    n = pow(n, 0.3);\n    float alpha = n;\n\n    gl_FragColor.rgb = mix(").concat(S(y.white),", ").concat(S(y.brightSkin),", alpha);\n    gl_FragColor.a = 1.0;\n\n    // float x = sphereGrid(vPosition, 1.0, 0.01);\n    // gl_FragColor.rgb = mix(").concat(S(y.black),", ").concat(S(y.brightSkin),", x);\n    // gl_FragColor.rgb = checker3(vPosition, 1.0, 0.1, ").concat(S(y.black),", ").concat(S(y.brightSkin),");\n  }\n");class _ extends l.eaF{constructor({debug:n=!1}={}){super(new l.WBB(5.5,12),new l.BKk({depthWrite:!1,side:l.hsX,vertexShader:"\n  varying vec3 vWorldNormal;\n  varying vec3 vPosition;\n\n  vec3 rotate(mat4 m, vec3 v) {\n    return vec3(\n      dot(v, vec3(m[0][0], m[1][0], m[2][0])),  // X component\n      dot(v, vec3(m[0][1], m[1][1], m[2][1])),  // Y component\n      dot(v, vec3(m[0][2], m[1][2], m[2][2]))   // Z component\n    );\n  }\n\n  void main() {\n    vPosition = position;\n    vWorldNormal = normalize(rotate(modelMatrix, position));\n\n    // gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    // Ignore the position, we only need the normal:\n    gl_Position = projectionMatrix * vec4(rotate(modelViewMatrix, position), 1.0);\n  }\n",fragmentShader:M,uniforms:{}})),n&&(this.material=new l.V9B({depthWrite:!1,color:"white",wireframe:!0})),this.onBeforeRender=(n,e,t,o,a,r)=>{this.position.copy(t.position)},this.renderOrder=-1,this.frustumCulled=!1,this.name="a-sky"}}var V=t(8144);class L extends l.eaF{constructor(n){let{radius:e,...t}={...L.defaultProps,...n},o=new l.WBB(e,18),a=new l.uSd({});a.onBeforeCompile=n=>c.bI.with(n).defines({USE_UV:""}).fragment.top(w.M).fragment.after("map_fragment","\n        vec2 p = vUv - 0.5;\n        float alpha = easeInOut(vUv.y, 1.6, 0.5);\n        Vec3Ramp r = ramp(alpha, ".concat((0,c.eR)(y.black),", ").concat((0,c.eR)(y.white),", ").concat((0,c.eR)(y.yellow),");\n        diffuseColor.rgb = mix(r.a, r.b, easeInOut3(r.t));\n      ")),super(o,a),(0,s.N)(this,t)}}L.defaultProps={radius:1};class T{set(n){this.props={...this.props,...n},this.props.center=this.props.center.clone(),this.props.normal=this.props.normal.clone().normalize(),this.props.binormal=this.props.binormal.clone().normalize()}update(n){let{radius:e,turnVelocity:t,turn:o,center:a,normal:r,binormal:l}=this.props,i=o+t*n;this.props.turn=i;let c=Math.cos(i*Math.PI*2),s=Math.sin(i*Math.PI*2);this.target.position.copy(a).addScaledVector(r,e*c).addScaledVector(l,e*s)}constructor(n,e){this.target=n,this.set({...T.defaultProps,...e})}}T.defaultProps={center:new l.Pq0,normal:new l.Pq0(1,0,0),binormal:new l.Pq0(0,1,0),radius:1,turnVelocity:1,turn:0};class A extends l.eaF{get satellite(){var n;return null!=(n=this._satellite)?n:this._satellite=new T(this)}constructor(n){let{radius:e,singleColor:t,emmissiveIntensity:o,lerpIn:a,lerpOut:r,...i}={...A.defaultProps,...n},{colorTop:p=null!=t?t:A.defaultProps.colorTop,colorBottom:d=null!=t?t:A.defaultProps.colorBottom}={...n},u=new l.WBB(e,12),f=new l.uSd({color:p,emissive:d});f.onBeforeCompile=n=>{c.bI.with(n).defines({USE_UV:""}).uniforms({uLerpIn:{value:a},uLerpOut:{value:r},uColorTop:{value:new l.Q1f(p)},uColorBottom:{value:new l.Q1f(d)}}).fragment.top(x.I,V.H).fragment.mainBeforeAll("\n          float alpha = inverseLerp(uLerpIn, uLerpOut, vUv.y);\n          vec3 sphereColor = mix(uColorBottom, uColorTop, easeInOut3(alpha));\n        ").fragment.after("map_fragment","\n          diffuseColor.rgb = sphereColor;\n        ").fragment.after("emissivemap_fragment","\n          totalEmissiveRadiance.rgb = sphereColor * ".concat(o.toFixed(2),";\n        "))},super(u,f),this._satellite=null,(0,s.N)(this,i)}}A.defaultProps={radius:.225,singleColor:null,colorTop:y.white,colorBottom:y.yellow,emmissiveIntensity:.25,lerpIn:-.2,lerpOut:1.2};class R extends l.eaF{constructor(n){let e=new l.WBB(.4,12),t=new l.uSd({});t.onBeforeCompile=n=>c.bI.with(n).varying({vWorldPosition:"vec3",vNormalWorld:"vec3",vViewDir:"vec3"}).vertex.mainAfterAll("\n        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n        vNormalWorld = normalize(mat3(modelMatrix) * normal);\n        vViewDir = normalize(cameraPosition - vWorldPosition);\n      ").fragment.top(x.I,"\n\nfloat contrast(float mValue, float mScale, float mMidPoint) {\n	// Why clamp? If necessary, it has to be done outside of this function.\n	// return clamp((mValue - mMidPoint) * mScale + mMidPoint, 0.0, 1.0);\n	return (mValue - mMidPoint) * mScale + mMidPoint;\n}\n\nfloat contrast(float mValue, float mScale) {\n	return contrast(mValue, mScale, 0.5);\n}\n\nvec3 contrast(vec3 mValue, float mScale, float mMidPoint) {\n	return vec3(contrast(mValue.r, mScale, mMidPoint), contrast(mValue.g, mScale, mMidPoint), contrast(mValue.b, mScale, mMidPoint));\n}\n\nvec3 contrast(vec3 mValue, float mScale) {\n	return contrast(mValue, mScale, 0.5);\n}\n\nfloat greyscaleFloat(vec3 color) {\n	return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 greyscale(vec3 color) {\n	return vec3(greyscaleFloat(color));\n}\n\nvec3 greyscale(vec3 color, float alpha) {\n	return mix(color, greyscale(color), alpha);\n}\n\n").fragment.after("map_fragment","\n        float fresnel = dot(vNormalWorld, vViewDir);\n        vec3 inner = ".concat((0,c.eR)(y.white),";\n        vec3 outer = ").concat((0,c.eR)(y.black),";\n        float alpha = easeInOut(1.0 - pow(fresnel, 1.5), 2.0, 0.0);\n        diffuseColor.rgb = mix(inner, outer, alpha);\n      ")).fragment.mainAfterAll("\n        // Final tuning\n        gl_FragColor.rgb = mix(contrast(greyscale(gl_FragColor.rgb), 1.5), diffuseColor.rgb, alpha);\n      "),super(e,t),(0,s.N)(this,n)}}class F extends l.eaF{constructor(n){let{color:e,thickness:t,length:o,shaded:a,...r}={...F.defaultProps,...n};super(new l.Ho_(t/2,t/2,o,12,1).rotateZ(.5*Math.PI),a?new l.uSd({color:e}):new l.V9B({color:e})),(0,s.N)(this,r)}}function N(n,e){return e.add(n),n}function*W(n,e){let t=yield*function*(n){let{ticker:e,scene:t}=n;e.set({activeDuration:u.$.development?3:180}),v("https://threejs.org/examples/textures/equirectangular/royal_esplanade_1k.hdr").then(e=>{new i.PMREMGenerator(n.renderer).fromEquirectangular(e).texture});let o=new l.YJl;return t.add(o),yield()=>{o.removeFromParent()},o}(n);if(1===e.renderCount){let{camera:e}=n;e.fov=n.aspect>1?25:180*(2*Math.atan(Math.tan(25*Math.PI/180/2)/n.aspect))/Math.PI,e.far=1e3,e.updateProjectionMatrix(),e.position.set(0,0,10)}t.add(new _),t.add(new C);let o=N(new L,t);t.add(new z({z:-1,radius:1.4,innerRadiusRatio:.805})),t.add(new P({z:-1,radius:.75,thickness:.01,color:y.yellow,emissiveIntensity:1})),t.add(new P({z:-1,radius:.8,thickness:.01,color:y.notSoWhite})),d.c.seed(6789402);let a=d.c.createPicker([[1,4],[2,2],[4,1]]);for(let{i:e}of function*(n){let e=0,t={get i(){return e},get t(){return e/8},get count(){return 8}};for(;e<n;e++)yield t}(8)){let o=d.c.pick(y),r=d.c.pick(y),i=new A({z:-1,radius:.1*a(),colorTop:o,colorBottom:r});i.rotation.set(d.c.between(2*Math.PI),d.c.between(2*Math.PI),d.c.between(2*Math.PI)),t.add(i),i.satellite.set({radius:0===e?.875:d.c.between(.25,.75)*(0,p.lerp)(1,1.5,e),center:new l.Pq0(0,0,-1-.4*e),turnVelocity:d.c.between(.05,.25)}),yield n.ticker.onTick(n=>{i.satellite.update(n.deltaTime)})}let r=new l.YJl;r.rotation.z=-.25*Math.PI,t.add(r),r.add(new A({x:-1.5,z:.5,singleColor:y.yellow})),r.add(new P({x:-1.81,radius:.1,thickness:.01,color:y.notSoWhite}));let c=N(new P({x:-2.315,radius:.2,thickness:.01,color:y.notSoWhite}),r);N(new F({x:-.2,thickness:.01,length:.4,shaded:!0,color:y.notSoWhite}),c),r.add(new A({x:1.7,z:.5,lerpIn:0,lerpOut:1})),r.add(new A({x:1.4,radius:.1,singleColor:y.black}));let x=N(new R({x:2.3}),r);N(new P({radius:.43,thickness:.015,color:y.black}),x),r.add(new F({x:1.5,thickness:.015,color:y.black}));let f=new l.YJl;f.rotation.z=.25*Math.PI,t.add(f),f.add(new F({x:-1.6,thickness:.01,length:.35,shaded:!0,color:y.notSoWhite})),f.add(new F({x:1.6,thickness:.01,length:.35,shaded:!0,color:y.notSoWhite}));let m=new l.YJl;m.rotation.y=.5*Math.PI,t.add(m),m.add(new F({x:-1.2,thickness:.01,length:.35,shaded:!0,color:y.notSoWhite})),m.add(new F({x:1.2,thickness:.01,length:.35,shaded:!0,color:y.notSoWhite})),(function(n){let e=n.split(".").pop();switch(e){case"hdr":return v(n);case"exr":return new Promise(e=>{h.load(n,n=>{e(n)})});default:return Promise.reject("Unsupported texture format: ".concat(e))}})("https://threejs.org/examples/textures/piz_compressed.exr").then(n=>{n.mapping=l.wfO,x.material.envMap=n,x.material.envMapIntensity=.25,x.material.envMapRotation.set(-.1*Math.PI,Math.PI,0),x.material.roughness=.3,x.material.metalness=.5,x.material.needsUpdate=!0,o.material.envMap=n,o.material.roughness=.2,o.material.envMapIntensity=.5,o.material.envMapRotation.set(-.1*Math.PI,Math.PI,0),o.material.needsUpdate=!0});let w=N(new l.YJl,t);w.rotation.z=.25*Math.PI;class g extends l.YJl{constructor(n){super();{let n=new l.Ho_(15,15,5,6,1,!0).rotateY(Math.PI/6),e=new l.uSd({color:new l.Q1f("white").lerp(y.black,.995),side:l.hsX,flatShading:!0});N(new l.eaF(n,e),this)}{let n=new l.Ho_(15,15,5,6,60,!0).rotateY(Math.PI/6),e=new l.uSd({color:y.black,wireframe:!0,flatShading:!0,side:l.hsX});N(new l.eaF(n,e),this)}(0,s.N)(this,n)}}N(new g({y:7.8}),w),N(new g({y:-7.8}),w)}function j(){return(0,o.jsx)("div",{className:"absolute-through",children:(0,o.jsx)(a.Q,{className:"bg-[#ddd]",children:(0,o.jsx)(r.yb,{children:(0,o.jsx)(r.YJ,{fn:W})})})})}F.defaultProps={color:y.black,thickness:.01,shaded:!1,length:1}},65927:(n,e,t)=>{"use strict";t.d(e,{S:()=>o});let o="\n#ifndef GLSL_BASIC\n#define GLSL_BASIC\n\nfloat clamp01(float x) {\n  return x < 0.0 ? 0.0 : x > 1.0 ? 1.0 : x;\n}\n\n#endif\n"}}]);