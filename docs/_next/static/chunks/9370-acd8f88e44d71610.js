"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9370],{1029:(n,e,t)=>{t.d(e,{N:()=>r});let a={vecX:["float","vec2","vec3","vec4"]},r=(n,e)=>{let t=[],r=Array.isArray(n)?n:[n].map(n=>n in a?a[n]:n).flat();if("function"==typeof e)for(let n of r)t.push(e(n).replaceAll(/\bT\b/g,n));else for(let n of r)t.push(e.replaceAll(/\bT\b/g,n));return t.join("\n")}},8144:(n,e,t)=>{t.d(e,{H:()=>o});var a=t(65927),r=t(1029);let o="\n  ".concat(a.S,"\n\n  float sin01(float x) {\n    return 0.5 + 0.5 * sin(x * 6.283185307179586);\n  }\n\n  vec2 scaleAround(vec2 p, vec2 c, float s) {\n    return c + (p - c) / s;\n  }\n\n  // Same as mix, but clamped.\n  ").concat((0,r.N)("vecX","\n    T lerp(in T a, in T b, in float x) {\n      return mix(a, b, clamp01(x));\n    }\n  "),"\n\n  float inverseLerpUnclamped(in float a, in float b, float x) {\n    return (x - a) / (b - a);\n  }\n\n  float inverseLerp(in float a, in float b, float x) {\n    return clamp01((x - a) / (b - a));\n  }\n\n  float threshold(in float x, in float thresholdValue) {\n    return x < thresholdValue ? 0. : 1.;\n  }\n\n  float threshold(in float x, in float thresholdValue, in float width) {\n    return width < 1e-9 \n      ? (x < thresholdValue ? 0. : 1.)\n      : clamp01((x - thresholdValue + width * .5) / width);\n  }\n\n  mat3 extractRotation(mat4 matrix) {\n    return mat3(matrix[0].xyz, matrix[1].xyz, matrix[2].xyz);\n  }\n\n  vec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    float x = c * p.x + s * p.y;\n    float y = -s * p.x + c * p.y;\n    return vec2(x, y);\n  }\n\n  vec2 rotateAround(vec2 p, float a, vec2 c) {\n    return c + rotate(p - c, a);\n  }\n\n  vec2 rotateScaleAround(vec2 p, float a, float s, vec2 c) {\n    return c + rotate((p - c) / s, a);\n  }\n  \n  float positiveModulo(float x) {\n    x = mod(x, 1.0);\n    return x < 0.0 ? x + 1.0 : x;\n  }\n\n  float positiveModulo(float x, float modulo) {\n    x = mod(x, modulo);\n    return x < 0.0 ? x + modulo : x;\n  }\n\n  // Limit a value to a maximum that the function tends to reach when x -> âˆž\n  // https://www.desmos.com/calculator/0vewkbnscu\n  float limited(float x, float maxValue) {\n    return x <= 0.0 ? x : maxValue * x / (maxValue + x);\n  }\n\n  // https://www.desmos.com/calculator/0vewkbnscu\n  float limited(float x, float minValue, float maxValue) {\n    float d = maxValue - minValue;\n    float xd = x - minValue;\n    return x <= minValue ? x : minValue + d * xd / (d + xd);\n  }\n\n  float sqLength(in vec2 p) {\n    return p.x * p.x + p.y * p.y;\n  }\n\n  float sqLength(in vec3 p) {\n    return p.x * p.x + p.y * p.y + p.z * p.z;\n  }\n\n  float pcurve(float x, float a, float b) {\n    float k = pow(a + b, a + b) / (pow(a, a) * pow(b, b));\n    return k * pow(x, a) * pow(1.0 - x, b);\n  }\n\n  float hash(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n  }\n\n  ").concat((0,r.N)("vecX","\n    T min3(in T a, in T b, in T c) {\n      return min(min(a, b), c);\n    }\n  "),"\n\n  ").concat((0,r.N)("vecX","\n    T min4(in T a, in T b, in T c, in T d) {\n      return min(min(a, b), min(c, d));\n    }\n  "),"\n")},14203:(n,e,t)=>{t.d(e,{O:()=>r});var a=t(1029);let r="\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\n\n\n\n\n// 2D:\n\nvec3 mod289_2d(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289_2d(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute_2d(vec3 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289_2d(i); // Avoid truncation effects in permutation\n  vec3 p = permute_2d( permute_2d( i.y + vec3(0.0, i1.y, 1.0 ))\n		+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// 3D: \n\nfloat snoise(vec3 v)\n{ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\n\n\n// addons:\n// Fractal noise, based on Stefan Gustavson's Simplex noise\n".concat((0,a.N)(["vec2","vec3"],"\n  float fnoise(T p, int octaves, float persistence) {\n    float total = 0.0;           // Final noise value\n    float amplitude = 1.0;       // Initial amplitude\n    float frequency = 1.0;       // Initial frequency\n    float maxValue = 0.0;        // Used for normalization\n\n    for (int i = 0; i < octaves; i++) {\n      total += snoise(p * frequency) * amplitude;\n\n      maxValue += amplitude;   // Keep track of max amplitude\n      amplitude *= persistence; // Reduce amplitude for next octave\n      frequency *= 2.0;        // Increase frequency for next octave\n    }\n\n    // Normalize the result to stay within the range [0, 1]\n    return total / maxValue;\n  }\n"),"\n")},14277:(n,e,t)=>{t.d(e,{D:()=>r});var a=t(67203);function r(){let[n,e]=(0,a.useState)(!1);return(0,a.useLayoutEffect)(()=>{e(!0)},[]),n}},22899:(n,e,t)=>{t.d(e,{I:()=>o});var a=t(65927);let r=["linear"];for(let n=1;n<=10;n++)r.push("easeIn".concat(n)),r.push("easeOut".concat(n)),r.push("easeInOut".concat(n)),r.push("easeOutIn".concat(n));let o="\n#ifndef GLSL_EASING\n#define GLSL_EASING\n\n".concat(a.S,"\n\nfloat easePow1(float x) {\n  return x;\n}\n\nfloat easePow2(float x) {\n  return x * x;\n}\n\nfloat easePow3(float x) {\n  return x * x * x;\n}\n\nfloat easePow4(float x) {\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow5(float x) {\n  float x0 = x;\n  x *= x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow6(float x) {\n  x *= x * x;\n  return x *= x;\n}\n\nfloat easePow7(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x;\n  return x0 * x;\n}\n\nfloat easePow8(float x) {\n  x *= x;\n  x *= x;\n  return x *= x;\n}\n\nfloat easePow9(float x) {\n  x *= x * x;\n  return x *= x * x;\n}\n\nfloat easePow10(float x) {\n  float x0 = x;\n  x *= x * x;\n  x *= x * x;\n  return x0 * x;\n}\n\nfloat linear(float x) {\n  return clamp01(x);\n}\n\n").concat(Array.from({length:10},(n,e)=>{let t=e+1;return"\n\nfloat easeIn".concat(t," (float x) {\n  return easePow").concat(t,"(clamp01(x));\n}\nfloat easeOut").concat(t," (float x) {\n  return 1.0 - easePow").concat(t,"(clamp01(1.0 - x));\n}\nfloat easeInOut").concat(t," (float x) {\n  return x < 0.5 \n    ? 0.5 * easePow").concat(t,"(2.0 * x) \n    : 1.0 - 0.5 * easePow").concat(t,"(2.0 * (1.0 - x));\n}\nfloat easeOutIn").concat(t," (float x) {\n  return x < 0.5\n    ? 0.5 * (1.0 - easePow").concat(t,"(1.0 - x * 2.0))\n    : 1.0 - 0.5 * (1.0 - easePow").concat(t,"(2.0 * x - 1.0));\n}\n\n").trim()}).join("\n\n"),"\n\n\n// https://www.desmos.com/calculator/mqou4lf9zc?lang=fr\nfloat easeInOut(float x, float p, float i) {\n  return  x <= 0.0 ? 0.0 :\n          x >= 1.0 ? 1.0 :\n          x <= i ? 1.0 / pow(i, p - 1.0) * pow(x, p) :\n          1.0 - 1.0 / pow(1.0 - i, p - 1.0) * pow(1.0 - x, p);\n}\n\n// https://www.desmos.com/calculator/nrjlezusdv\nfloat easeInThenOut(float x, float p) {\n  return 1.0 - pow(abs(2.0 * x - 1.0), p);\n}\n\n#endif\n")},60041:(n,e,t)=>{t.d(e,{b:()=>g,e:()=>w});var a=t(888),r=t(30158);let o=["common","uv_pars_vertex","displacementmap_pars_vertex","color_pars_vertex","fog_pars_vertex","normal_pars_vertex","morphtarget_pars_vertex","skinning_pars_vertex","shadowmap_pars_vertex","logdepthbuf_pars_vertex","clipping_planes_pars_vertex","uv_vertex","color_vertex","morphcolor_vertex","beginnormal_vertex","morphnormal_vertex","skinbase_vertex","skinnormal_vertex","defaultnormal_vertex","normal_vertex","begin_vertex","morphtarget_vertex","skinning_vertex","displacementmap_vertex","project_vertex","logdepthbuf_vertex","clipping_planes_vertex","worldpos_vertex","shadowmap_vertex","fog_vertex","common","packing","dithering_pars_fragment","color_pars_fragment","uv_pars_fragment","map_pars_fragment","alphamap_pars_fragment","alphatest_pars_fragment","alphahash_pars_fragment","aomap_pars_fragment","lightmap_pars_fragment","emissivemap_pars_fragment","iridescence_fragment","cube_uv_reflection_fragment","envmap_common_pars_fragment","envmap_physical_pars_fragment","fog_pars_fragment","lights_pars_begin","normal_pars_fragment","lights_physical_pars_fragment","transmission_pars_fragment","shadowmap_pars_fragment","bumpmap_pars_fragment","normalmap_pars_fragment","clearcoat_pars_fragment","iridescence_pars_fragment","roughnessmap_pars_fragment","metalnessmap_pars_fragment","logdepthbuf_pars_fragment","clipping_planes_pars_fragment","clipping_planes_fragment","logdepthbuf_fragment","map_fragment","color_fragment","alphamap_fragment","alphatest_fragment","alphahash_fragment","roughnessmap_fragment","metalnessmap_fragment","normal_fragment_begin","normal_fragment_maps","clearcoat_normal_fragment_begin","clearcoat_normal_fragment_maps","emissivemap_fragment","lights_physical_fragment","lights_fragment_begin","lights_fragment_maps","lights_fragment_end","aomap_fragment","transmission_fragment","opaque_fragment","tonemapping_fragment","colorspace_fragment","fog_fragment","premultiplied_alpha_fragment","dithering_fragment"];var c=t(49797),i=t(85795);class l{static from(n,e){if(e instanceof i.Observable){if("number"==typeof e.value)return new l(n,e);throw Error("Observable value must be a number")}let t=typeof e;return"object"===t&&(e.constructor===Object||e instanceof c.nc$)&&"value"in e?new l(n,e):"string"===t?new l(n,{value:new c.Q1f(e)}):new l(n,{value:e})}get value(){return this.target.value}computeDeclaration(){let n=this.name,e=this.target.value,t="";if(e instanceof Float32Array)return"uniform float ".concat(n,"[").concat(e.length,"];");if(Array.isArray(e)&&(t="[".concat(e.length,"]"),e=e[0]),"number"==typeof e)return"uniform float ".concat(n).concat(t,";");if(e.isVector2)return"uniform vec2 ".concat(n).concat(t,";");if(e.isVector3||e.isColor)return"uniform vec3 ".concat(n).concat(t,";");if(e.isVector4||e.isQuaternion)return"uniform vec4 ".concat(n).concat(t,";");if(e.isMatrix3)return"uniform mat3 ".concat(n).concat(t,";");if(e.isMatrix4)return"uniform mat4 ".concat(n).concat(t,";");if(e.isTexture)if(e.isCubeTexture)return"uniform samplerCube ".concat(n).concat(t,";");else return"uniform sampler2D ".concat(n).concat(t,";");throw console.log("unhandled value:",e),Error('unhandled value: "'.concat(null==e?void 0:e.constructor.name,'"'))}constructor(n,e){this.name=n,this.target=e}}function s(){let n=(0,a._)(["","s*",""],["","\\s*",""]);return s=function(){return n},n}let x=null,f=n=>(x=n,g),p="// ShaderForge (injected code) ->",m="// <- ShaderForge",u=n=>"".concat(p,"\n").concat(n.trim(),"\n").concat(m),v=n=>{let e=n=>n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),t=RegExp(String.raw(s(),e(m),e(p)),"g");return n.replaceAll(t,"")};class d{getPattern(n){let{throwError:e=!0}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t="#include <".concat(n,">"),a=this.type;if(e&&!1===x[a].includes(t))throw Error('"'.concat(t,'" is not present in the shader template program.'));return{pattern:t,type:a}}replace(n,e){if(n instanceof RegExp){let{type:t}=this;x[t]=x[t].replace(n,u(e))}else{let{type:t,pattern:a}=this.getPattern(n),r=u(e);x[t]=x[t].replace(a,r)}return g}inject(n,e,t){let{type:a,pattern:r}=this.getPattern(e),o="after"===n?"".concat(r,"\n").concat(u(t)):"".concat(u(t),"\n").concat(r);return x[a]=x[a].replace(r,o),g}injectTokenComments(){for(let n of o){let{type:e,pattern:t}=this.getPattern(n,{throwError:!1});x[e]=x[e].replace(t,"\n        ".concat(t,"\n        // ShaderForge TOKEN: ").concat(n,"\n      "))}return g}header(n){let e=this.type;return x[e]="".concat(n,"\n").concat(x[e]),g}before(n,e){return this.inject("before",n,e)}after(n,e){return this.inject("after",n,e)}top(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];return x[this.type]=x[this.type].replace("void main() {","\n      ".concat(u(e.join("\n\n")),"\n      void main() {\n    ")),g}mainBeforeAll(n){return x[this.type]=x[this.type].replace("void main() {","void main() {\n        ".concat(u(n))),g}mainAfterAll(n){return x[this.type]=x[this.type].replace(/}\s*$/,"\n      ".concat(u(n),"\n    }")),g}uniforms(n){if("string"==typeof n)this.top(n);else{let e=[];for(let[t,a]of Object.entries(n)){let n=l.from(t,a);e.push(n.computeDeclaration())}this.top(e.join("\n")),function(n){for(let[e,t]of Object.entries(n)){let n=l.from(e,t);if(e in x.uniforms){if(n.value!==x.uniforms[e].value)throw Error("Shader redefinition! (Uniform values are not equal)")}else x.uniforms[e]=n}}(n)}return g}clean(){return x[this.type]=v(x[this.type]),g}printFinalCode(){return console.log(x[this.type].replace(/#include <(.*)>/g,(n,e)=>{let t=r.ShaderChunk[e];if(!t)throw Error('Shader chunk "'.concat(e,'" not found'));return t})),g}constructor(n){this.type=n}}let h=new d("fragmentShader"),_=new d("vertexShader"),g=Object.assign(function(n){return n&&f(n),g},{shaderName:function(n){return x.shaderName="".concat(n," (ShaderForge)"),g},defines:function(n){return x.defines?Object.assign(x.defines,n):x.defines=n,g},uniforms:function(n){return _.uniforms(n),h.uniforms(n),g},varying:function(n){let e="";if("string"==typeof n)e=n;else{let t=[];for(let[e,a]of Object.entries(n))t.push("varying ".concat(a," ").concat(e,";"));e=t.join("\n")}return _.top(e),h.top(e),g},top:function(n){return _.top(n),h.top(n),g},vertex:_,fragment:h,header:function(n){return h.header(n),_.header(n),g},clean:function(){return h.clean(),_.clean(),g},with:f,wrap:(n,e)=>(n.onBeforeCompile=n=>{x=n},n)}),y=new c.Q1f;function w(n){let{r:e,g:t,b:a}=y.set(n);return"vec3(".concat(e.toFixed(3),", ").concat(t.toFixed(3),", ").concat(a.toFixed(3),")")}},65927:(n,e,t)=>{t.d(e,{S:()=>a});let a="\n#ifndef GLSL_BASIC\n#define GLSL_BASIC\n\nfloat clamp01(float x) {\n  return x < 0.0 ? 0.0 : x > 1.0 ? 1.0 : x;\n}\n\n#endif\n"},90927:(n,e,t)=>{t.d(e,{N:()=>l});var a=t(49797),r=t(22641);new a.Pq0(0,0,0),new a.O9p(0,0,0,"XYZ"),new a.Pq0(1,1,1);let o={x:0,y:0,z:0,rotationX:0,rotationY:0,rotationZ:0,rotationOrder:"XYZ",rotationUnit:"rad",scaleX:1,scaleY:1,scaleZ:1,scaleScalar:1,pivot:void 0,visible:void 0,name:void 0,parent:void 0,userData:void 0},c=new a.dwI,i=new a.Pq0;function l(n,e){let{x:t,y:l,z:s,position:x=new a.Pq0(t,l,s),rotationX:f,rotationY:p,rotationZ:m,rotationOrder:u,rotationUnit:v,rotation:d,scaleX:h,scaleY:_,scaleZ:g,scaleScalar:y,scale:w=new a.Pq0(h,_,g).multiplyScalar(y),pivot:b,visible:z,name:C,parent:S,userData:j}={...o,...e};return(0,r.jj)(x,n.position),(0,r.if)(null!=d?d:[f,p,m,u,v],n.rotation),(0,r.jj)(w,n.scale),void 0!==b&&(n.updateMatrix(),c.setFromMatrix4(n.matrix),(0,r.jj)(b,i).applyMatrix3(c),n.position.sub(i)),void 0!==z&&(n.visible=z),void 0!==C&&(n.name=C),void 0!==S&&S!==n.parent&&(null===S?n.removeFromParent():S.add(n)),void 0!==j&&Object.assign(n.userData,j),n}}}]);